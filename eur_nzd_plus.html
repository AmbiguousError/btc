<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EUR/NZD Trading Strategy Simulation</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/format/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.5.1/nouislider.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.5.1/nouislider.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f7f9;
            color: #333;
            margin: 0;
            padding: 10px;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin: 10px auto;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .chart-container {
            position: relative;
            height: 60vh;
        }
        .results {
            text-align: center;
        }
        .header {
            text-align: center;
        }
        .header h1 {
            font-size: 1.5em;
            margin-bottom: 0.5em;
        }
        .header p {
            font-size: 1em;
            color: #555;
            max-width: 800px;
            margin: 0 auto;
        }
        .controls-container {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            justify-content: center;
            flex-wrap: wrap;
        }
         .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .input-group label, .checkbox-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #555;
            font-weight: 600;
        }
        .input-group input, .input-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            margin-top: 10px;
        }
        .btn-adv { background-color: #28a745; }
        .btn-adv:hover { background-color: #218838; }
        .btn-opt { background-color: #ffc107; color: #333; }
        .btn-opt:hover { background-color: #e0a800; }
        .btn-vol { background-color: #17a2b8; }
        .btn-vol:hover { background-color: #138496; }
        .btn-ai { background-color: #6f42c1; }
        .btn-ai:hover { background-color: #5a3d9a; }
        .btn-ai:disabled { background-color: #cccccc; cursor: not-allowed; }
        .btn:hover { background-color: #0056b3; }
        .table-container { width: 100%; overflow-x: auto; max-height: 400px; }
        table {
            width: 100%;
            min-width: 600px;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; white-space: nowrap; }
        th { background-color: #f2f2f2; position: sticky; top: 0; }
        .revenue-positive { color: green; }
        .revenue-negative { color: red; }

        .collapsible-toggle {
            background-color: #f1f1f1;
            color: #444;
            cursor: pointer;
            padding: 15px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: left;
            outline: none;
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 20px;
            transition: background-color 0.2s;
        }

        .collapsible-toggle:hover {
            background-color: #e2e2e2;
        }

        .collapsible-toggle::after {
            content: '▼'; /* Down arrow for collapsed */
            float: right;
            transition: transform 0.2s;
        }

        .collapsible-toggle.expanded::after {
            content: '▲'; /* Up arrow for expanded */
        }
        
        .collapsible-content {
            padding: 15px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            display: none; /* Initially hidden */
        }
        
        #date-slider-container {
            padding: 20px 40px;
        }
        
        .analysis-container {
              text-align: center;
        }
        
        .strategy-description {
            text-align: left;
            font-size: 0.9em;
            color: #555;
            max-width: 900px;
            margin: 15px auto;
            padding: 10px;
            background-color: #eef2f5;
            border-left: 4px solid #17a2b8;
            border-radius: 4px;
        }

        .analysis-result {
            margin-top: 15px; 
            padding: 10px;
            text-align: left; 
            white-space: pre-wrap;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
            min-height: 50px;
        }
        .analysis-result ul {
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 10px;
        }
        .analysis-result li {
            margin-bottom: 5px;
        }
        .analysis-result strong {
            color: #333;
        }


        @media (min-width: 768px) {
            body { padding: 20px; }
            .container { width: 90%; margin: 20px auto; padding: 20px; }
            .header h1 { font-size: 2em; }
            .header p { font-size: 1.1em; }
            .btn { margin-top: 0; }
        }
    </style>
</head>
<body>
    
    <div class="container header">
        <h1>EUR/NZD Trading Strategy Simulation</h1>
        <p>This tool simulates trading strategies for the EUR/NZD currency pair. You can test a price-based moving average strategy, a volatility-based contrarian strategy, find optimal parameters, and analyze market data.</p>
        <div class="controls-container">
            <div class="input-group">
                <label for="initialInvestment">Initial Investment ($)</label>
                <input type="number" id="initialInvestment" value="1000000" min="1">
            </div>
        </div>
        <div id="date-slider-container">
            <label>Date Range:</label>
            <div id="date-slider"></div>
            <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                <span id="slider-start-date"></span>
                <span id="slider-end-date"></span>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>Default Strategy (65-Day MA, 5% Bands)</h2>
        <div class="controls-container">
            <button id="rerunBtn" class="btn">Rerun Default Simulation</button>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
            <canvas id="myChart"></canvas>
        </div>
         <div class="results">
            <p id="initial-investment-display">Initial Investment: $1,000,000</p>
            <p id="final-amount">Current Value: Loading...</p>
            <p id="default-revenue">Revenue: Loading...</p>
            <p id="default-revenue-percent">Revenue %: Loading...</p>
        </div>
        <button type="button" class="collapsible-toggle">View Transaction Log</button>
        <div class="collapsible-content">
            <div class="table-container">
                <div id="transaction-table"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Advanced Strategy Tester</h2>
        <div class="strategy-description">
            <p>Define a Moving Average (MA) crossover strategy and enhance it with optional risk management and confirmation filters.</p>
            <ul>
                <li style="margin-top: 8px;"><strong>Stop-Loss & Take-Profit:</strong> If enabled, a position will be automatically sold if the price drops by the Stop-Loss % or rises by the Take-Profit % from the entry price.</li>
                <li style="margin-top: 8px;"><strong>Confirmation Filters:</strong> Add extra conditions to the MA crossover signals.
                    <ul style="list-style-type: disc; margin-left: 20px;">
                        <li><strong>RSI Filter:</strong> A buy requires RSI to be below an overbought level; a sell requires it to be above an oversold level.</li>
                        <li><strong>Bollinger Bands® (BB) Filter:</strong> A buy requires the price to be below the middle BB line; a sell requires it to be above.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="controls-container" style="flex-direction: column; align-items: stretch; gap: 20px;">
             <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;">
                 <div class="input-group">
                    <label for="maPeriod">Moving Average Period</label>
                    <select id="maPeriod"></select>
                </div>
                <div class="input-group">
                    <label for="bandVariation">Variation Band (%)</label>
                    <select id="bandVariation"></select>
                </div>
            </div>
            <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; border-top: 1px solid #eee; padding-top: 15px;">
                <div class="input-group"><label for="rsiPeriod">RSI Period:</label><input type="number" id="rsiPeriod" value="14" min="2"></div>
                <div class="input-group"><label for="rsiOverbought">RSI Overbought:</label><input type="number" id="rsiOverbought" value="70" min="51"></div>
                <div class="input-group"><label for="rsiOversold">RSI Oversold:</label><input type="number" id="rsiOversold" value="30" max="49"></div>
            </div>
             <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; border-top: 1px solid #eee; padding-top: 15px;">
                <div class="input-group"><label for="bbPeriod">BB Period:</label><input type="number" id="bbPeriod" value="20" min="2"></div>
                <div class="input-group"><label for="bbStdDev">BB Std Dev:</label><input type="number" id="bbStdDev" value="2" min="1" step="0.1"></div>
            </div>
             <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; border-top: 1px solid #eee; padding-top: 15px;">
                <div class="input-group"><label for="stopLoss">Stop-Loss (%):</label><input type="number" id="stopLoss" value="5" min="0.1" step="0.1"></div>
                <div class="input-group"><label for="takeProfit">Take-Profit (%):</label><input type="number" id="takeProfit" value="15" min="0.1" step="0.1"></div>
            </div>
            <div class="checkbox-group" style="justify-content: center; border-top: 1px solid #eee; padding-top: 15px;">
                <input type="checkbox" id="useSLTP" checked class="h-5 w-5"><label for="useSLTP">Use SL/TP</label>
                <input type="checkbox" id="useRsiFilter" class="h-5 w-5"><label for="useRsiFilter">Use RSI Filter</label>
                <input type="checkbox" id="useBBFilter" class="h-5 w-5"><label for="useBBFilter">Use BB Filter</label>
            </div>

            <button id="runAdvancedBtn" class="btn btn-adv" style="margin-top: 20px;">Run Advanced Simulation</button>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
            <canvas id="advancedChart"></canvas>
        </div>
        <button type="button" class="collapsible-toggle">View Advanced Simulation Results</button>
        <div class="collapsible-content">
            <div class="results">
                <p id="advanced-final-amount">Current Value: Waiting for simulation...</p>
                <p id="advanced-revenue">Revenue: Waiting for simulation...</p>
                <p id="advanced-revenue-percent">Revenue %: Waiting for simulation...</p>
                <div class="table-container">
                    <div id="advanced-results-table"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Contrarian Volatility Strategy Tester</h2>
        <div class="strategy-description">
            <p>This strategy is based on the principle of mean reversion in volatility. It assumes that extreme levels of volatility are not sustainable and will eventually revert to their historical average.</p>
            <ul>
                <li><strong>Buy Signal:</strong> Generated when the 3M Tenor Average volatility crosses <strong>below</strong> a lower band, signaling market complacency and a potential breakout.</li>
                <li><strong>Sell Signal:</strong> Generated when the 3M Tenor Average volatility crosses <strong>above</strong> an upper band, signaling market panic or that a price move is over-extended.</li>
            </ul>
        </div>
        <div class="controls-container">
            <div class="input-group">
                <label for="volatilityMAPeriod">Volatility MA Period</label>
                <select id="volatilityMAPeriod"></select>
            </div>
            <div class="input-group">
                <label for="volatilityBand">Volatility Band (%)</label>
                <select id="volatilityBand"></select>
            </div>
            <button id="runVolatilityStrategyBtn" class="btn btn-vol">Run Volatility Strategy</button>
            <button id="runVolatilityOptimizationBtn" class="btn btn-opt">Find Optimal Volatility Strategy</button>
        </div>
        <div id="volatility-optimization-status" style="text-align: center; margin-top: 15px; font-weight: bold;"></div>
        <div class="chart-container" style="margin-top: 20px;">
            <canvas id="volatilityStrategyChart"></canvas>
        </div>
        <button type="button" class="collapsible-toggle">View Volatility Strategy Results</button>
        <div class="collapsible-content">
            <div class="results">
                <p id="volatility-strategy-params">Parameters: Not yet run.</p>
                <p id="volatility-strategy-final-amount">Current Value: Waiting for simulation...</p>
                <p id="volatility-strategy-revenue">Revenue: Waiting for simulation...</p>
                <p id="volatility-strategy-revenue-percent">Revenue %: Waiting for simulation...</p>
                <div class="table-container">
                    <div id="volatility-strategy-results-table"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>Lead Indicator Test: 3M Volatility vs. Daily Price</h2>
        <div class="controls-container">
            <button id="runIndicatorTestBtn" class="btn">Run Correlation Test</button>
        </div>
        <div class="chart-container" style="margin-top: 20px; height: 40vh;">
            <canvas id="correlationChart"></canvas>
        </div>
        <div class="results">
            <p id="correlation-results"></p>
        </div>
    </div>

    <div class="container">
        <h2>Optimized Strategy Finder</h2>
        <div class="controls-container">
             <button id="runOptimizationBtn" class="btn btn-opt">Find Optimal Strategy</button>
        </div>
        <div id="optimization-status" style="text-align: center; margin-top: 15px; font-weight: bold;"></div>
         <div class="chart-container" style="margin-top: 20px;">
            <canvas id="optimizedChart"></canvas>
        </div>
        <button type="button" class="collapsible-toggle">View Optimized Strategy Results</button>
        <div class="collapsible-content">
            <div class="results">
                <p id="optimized-params">Optimal Parameters: Not yet calculated.</p>
                <p id="optimized-final-amount">Current Value: Waiting for optimization...</p>
                <p id="optimized-revenue">Revenue: Waiting for optimization...</p>
                <p id="optimized-revenue-percent">Revenue %: Waiting for optimization...</p>
                <div class="table-container">
                    <div id="optimized-results-table"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container analysis-container">
        <h3>Gemini AI Qualitative Analysis</h3>
        <button id="getOptimizationAnalysisBtn" class="btn btn-ai" disabled>Analyze Optimal Strategy</button>
        <div id="optimization-analysis-result" class="analysis-result">Click the button above after running the optimizer to get an AI-powered analysis.</div>
    </div>


    <div class="container">
        <h2>Volatility Chart</h2>
        <div class="controls-container">
            <div class="input-group">
                <label for="tenor-select">Tenor:</label>
                <select id="tenor-select"></select>
            </div>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
            <canvas id="volatilityChart"></canvas>
        </div>
    </div>

    <div class="container analysis-container">
        <h3>Gemini AI Qualitative Analysis</h3>
        <button id="getVolatilityAnalysisBtn" class="btn btn-ai">Analyze Volatility Chart</button>
        <div id="volatility-analysis-result" class="analysis-result">Click the button above to analyze the current volatility chart.</div>
    </div>
    
    <div class="container">
        <h2>Volatility Moving Average</h2>
        <div class="controls-container">
            <div class="input-group">
                <label for="volatility-view-select">View:</label>
                <select id="volatility-view-select">
                    <option value="ma" selected>Moving Average</option>
                    <option value="average">Average (Bid/Ask)</option>
                </select>
            </div>
             <div class="input-group" id="volatility-ma-period-group">
                <label for="volatility-ma-period">Moving Average Period</label>
                <select id="volatility-ma-period"></select>
            </div>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
            <canvas id="volatilityMAChart"></canvas>
        </div>
    </div>

     <div class="container analysis-container">
        <h3>Gemini AI Qualitative Analysis</h3>
        <button id="getVolatilityMAAnalysisBtn" class="btn btn-ai">Analyze Volatility MA Chart</button>
        <div id="volatility-ma-analysis-result" class="analysis-result">Click the button above to analyze the current volatility moving average chart.</div>
    </div>

    <div class="container">
        <button type="button" class="collapsible-toggle">View Processed Data Tables</button>
        <div class="collapsible-content">
            <div id="data-tables-container">
                </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            let fullProcessedData = [];
            let volatilityData = [];
            let filteredData = [];
            let filteredVolatilityData = [];
            let mainChart = null;
            let advancedChart = null;
            let optimizedChart = null;
            let volatilityChart = null;
            let volatilityMAChart = null;
            let volatilityStrategyChart = null;
            let correlationChart = null;
            
            // Store optimization results globally for AI analysis
            let bestOptimizationParams = null;
            let bestOptimizationResult = null;


            // Parses date strings from the CSV into Date objects
            function parseDate(dateStr) {
                if (!dateStr) return null;

                // Handle YYYY-MM-DD format
                if (dateStr.includes('-')) {
                    const parts = dateStr.split(' ')[0].split('-');
                    if (parts.length === 3) {
                        const year = parseInt(parts[0], 10);
                        const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
                        const day = parseInt(parts[2], 10);
                        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                            return new Date(Date.UTC(year, month, day));
                        }
                    }
                }

                // Existing logic for DD/MM/YY or DD/MM/YYYY
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    const day = parseInt(parts[0], 10);
                    const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
                    let year = parseInt(parts[2], 10);
                    
                    if (year < 100) {
                        year += 2000;
                    }
                    
                    if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                        return new Date(Date.UTC(year, month, day));
                    }
                }
                return null;
            }
            
            // Calculates the Simple Moving Average (SMA) for a given dataset and period
            function calculateSMA(data, period) {
                if (!data || data.length < period) {
                    return new Array(data.length).fill(null);
                }
                const sma = new Array(period - 1).fill(null);
                let sum = 0;
                for (let i = 0; i < period; i++) {
                    sum += data[i];
                }
                sma.push(sum / period);
                for (let i = period; i < data.length; i++) {
                    sum = sum - data[i - period] + data[i];
                    sma.push(sum / period);
                }
                return sma;
            }
            
            // Simulates the default trading strategy and returns detailed results
            function getFullSimulation(initialInvestment, dailyRates, movingAverage, bandVariation, dates) {
                const plusBand = movingAverage.map(ma => ma ? ma * (1 + bandVariation) : null);
                const minusBand = movingAverage.map(ma => ma ? ma * (1 - bandVariation) : null);

                let portfolioValue = initialInvestment;
                let position = null;
                const buySignals = [], executedSellSignals = [], potentialSellSignals = [], potentialBuySignals = [], transactions = [];

                for (let i = 1; i < dailyRates.length; i++) {
                    if (!dailyRates[i] || !minusBand[i] || !plusBand[i] || !dailyRates[i-1] || !minusBand[i-1] || !plusBand[i-1]) continue;
                    
                    const priceCrossedBelow = dailyRates[i] < minusBand[i] && dailyRates[i-1] >= minusBand[i-1];
                    const priceCrossedAbove = dailyRates[i] > plusBand[i] && dailyRates[i-1] <= plusBand[i-1];

                    if (priceCrossedAbove) potentialSellSignals.push({ x: dates[i].valueOf(), y: dailyRates[i] });
                    if (priceCrossedBelow) potentialBuySignals.push({ x: dates[i].valueOf(), y: dailyRates[i] });
                    
                    if (position === null && priceCrossedBelow) {
                        position = { valueAtBuy: portfolioValue, buyPrice: dailyRates[i], buyDate: dates[i] };
                        buySignals.push({ x: dates[i].valueOf(), y: dailyRates[i] });
                    } else if (position !== null && priceCrossedAbove) {
                        const profitRatio = dailyRates[i] / position.buyPrice;
                        const previousValue = position.valueAtBuy;
                        portfolioValue *= profitRatio;
                        transactions.push({
                            buyDate: position.buyDate, buyPrice: position.buyPrice,
                            sellDate: dates[i], sellPrice: dailyRates[i],
                            revenueDollar: portfolioValue - previousValue,
                            revenuePercent: (profitRatio - 1) * 100,
                             reason: 'ma_crossover'
                        });
                        position = null;
                        executedSellSignals.push({ x: dates[i].valueOf(), y: dailyRates[i] });
                    }
                }
                return { portfolioValue, transactions, movingAverage, plusBand, minusBand, buySignals, executedSellSignals, potentialSellSignals, potentialBuySignals };
            }

            const calculateRSI = (data, period) => {
                const rsi = Array(data.length).fill(null);
                const prices = data.map(d => d.DailyRate);
                if (period >= prices.length) return rsi;

                let gains = 0, losses = 0;
                for (let i = 1; i <= period; i++) {
                    const change = prices[i] - prices[i - 1];
                    change > 0 ? gains += change : losses -= change;
                }
                let avgGain = gains / period;
                let avgLoss = losses / period;
                rsi[period] = 100 - (100 / (1 + (avgGain / avgLoss)));

                for (let i = period + 1; i < prices.length; i++) {
                    const change = prices[i] - prices[i - 1];
                    avgGain = (avgGain * (period - 1) + (change > 0 ? change : 0)) / period;
                    avgLoss = (avgLoss * (period - 1) + (change < 0 ? -change : 0)) / period;
                    rsi[i] = 100 - (100 / (1 + (avgLoss === 0 ? Infinity : avgGain / avgLoss)));
                }
                return rsi;
            };

            function calculateBollingerBands(data, period, stdDevMultiplier) {
                const prices = data.map(d => d.DailyRate);
                const middle = Array(prices.length).fill(null);
                const upper = Array(prices.length).fill(null);
                const lower = Array(prices.length).fill(null);

                for (let i = period - 1; i < prices.length; i++) {
                    const slice = prices.slice(i - period + 1, i + 1);
                    const sma = slice.reduce((sum, val) => sum + val, 0) / period;
                    const stdDev = Math.sqrt(slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period);
                    
                    middle[i] = sma;
                    upper[i] = sma + (stdDev * stdDevMultiplier);
                    lower[i] = sma - (stdDev * stdDevMultiplier);
                }
                return { middle, upper, lower };
            }

            // Simulates the ADVANCED trading strategy with new filters
            function getAdvancedSimulation(initialInvestment, data, settings) {
                const dailyRates = data.map(d => d.DailyRate);
                const dates = data.map(d => d.Date);

                const movingAverage = calculateSMA(dailyRates, settings.maPeriod);
                const plusBand = movingAverage.map(ma => ma ? ma * (1 + settings.bandVariation) : null);
                const minusBand = movingAverage.map(ma => ma ? ma * (1 - settings.bandVariation) : null);
                
                const rsi = calculateRSI(data, settings.rsiPeriod);
                const bb = calculateBollingerBands(data, settings.bbPeriod, settings.bbStdDev);
                
                let portfolioValue = initialInvestment;
                let position = null;
                const buySignals = [], executedSellSignals = [], transactions = [];
                const potentialBuySignals = [], potentialSellSignals = [];


                for (let i = 1; i < dailyRates.length; i++) {
                    const currentPrice = dailyRates[i];
                    if (!currentPrice || !minusBand[i] || !plusBand[i] || !dailyRates[i-1] || !minusBand[i-1] || !plusBand[i-1]) continue;

                    // Check for potential signals first for visualization
                    if (currentPrice < minusBand[i] && dailyRates[i-1] >= minusBand[i-1]) potentialBuySignals.push({ x: dates[i].valueOf(), y: currentPrice });
                    if (currentPrice > plusBand[i] && dailyRates[i-1] <= plusBand[i-1]) potentialSellSignals.push({ x: dates[i].valueOf(), y: currentPrice });

                    // --- SELLING LOGIC ---
                    if (position !== null) {
                        let sellReason = null;
                        const stopLossPrice = position.buyPrice * (1 - settings.stopLoss / 100);
                        const takeProfitPrice = position.buyPrice * (1 + settings.takeProfit / 100);

                        // 1. Check for Stop-Loss or Take-Profit
                        if (settings.useSLTP) {
                            if (currentPrice <= stopLossPrice) sellReason = 'stop_loss';
                            else if (currentPrice >= takeProfitPrice) sellReason = 'take_profit';
                        }
                        
                        // 2. Check for MA Crossover Signal (if no SL/TP triggered)
                        if (!sellReason && currentPrice > plusBand[i] && dailyRates[i-1] <= plusBand[i-1]) {
                             // Check Bollinger Bands Filter
                            const bbConditionSell = !settings.useBBFilter || currentPrice > bb.middle[i];
                            if(bbConditionSell) { // RSI for sell is not used in the sample code.
                                sellReason = 'ma_crossover';
                            }
                        }

                        if (sellReason) {
                            const profitRatio = currentPrice / position.buyPrice;
                            const previousValue = position.valueAtBuy;
                            portfolioValue *= profitRatio;
                            transactions.push({
                                buyDate: position.buyDate, buyPrice: position.buyPrice,
                                sellDate: dates[i], sellPrice: currentPrice,
                                revenueDollar: portfolioValue - previousValue,
                                revenuePercent: (profitRatio - 1) * 100,
                                reason: sellReason
                            });
                            position = null;
                            executedSellSignals.push({ x: dates[i].valueOf(), y: currentPrice });
                        }
                    } 
                    // --- BUYING LOGIC ---
                    else {
                        const priceCrossedBelow = currentPrice < minusBand[i] && dailyRates[i-1] >= minusBand[i-1];
                        
                        if (priceCrossedBelow) {
                            // Apply confirmation filters
                            const rsiConditionBuy = !settings.useRsiFilter || rsi[i] < settings.rsiOverbought; // Buy when not overbought
                            const bbConditionBuy = !settings.useBBFilter || currentPrice < bb.middle[i]; // Buy when below middle band
                            
                            if (rsiConditionBuy && bbConditionBuy) {
                                position = { valueAtBuy: portfolioValue, buyPrice: currentPrice, buyDate: dates[i] };
                                buySignals.push({ x: dates[i].valueOf(), y: currentPrice });
                            }
                        }
                    }
                }
                
                 return { portfolioValue, transactions, movingAverage, plusBand, minusBand, buySignals, executedSellSignals, potentialBuySignals, potentialSellSignals, bb };
            }

            function legendFocusOnClick(e, legendItem, legend) {
                const chart = legend.chart;
                const index = legendItem.datasetIndex;

                const currentFocused = chart.focusedDatasetIndex;

                if (currentFocused === index) {
                    chart.focusedDatasetIndex = null; // Unfocus
                    chart.data.datasets.forEach(dataset => {
                        if (dataset.originalBorderColor) {
                            dataset.borderColor = dataset.originalBorderColor;
                        }
                    });
                } else { // Focus on new item
                    chart.focusedDatasetIndex = index;
                    chart.data.datasets.forEach((dataset, i) => {
                        if (dataset.originalBorderColor) {
                            if (i === index) {
                                dataset.borderColor = dataset.originalBorderColor;
                            } else {
                                dataset.borderColor = 'rgba(200, 200, 200, 0.5)';
                            }
                        }
                    });
                }

                chart.update();
            }

            // Renders a chart with specified datasets and options
            function renderChart(chartInstance, canvasId, data, simResults) {
                if (chartInstance) chartInstance.destroy();
                
                const firstValidIndex = simResults.movingAverage.findIndex(val => val !== null);
                if (firstValidIndex === -1) return;

                const chartData = data.slice(firstValidIndex);
                const chartMA = simResults.movingAverage.slice(firstValidIndex);
                const chartPlusBand = simResults.plusBand.slice(firstValidIndex);
                const chartMinusBand = simResults.minusBand.slice(firstValidIndex);
                
                const datasets = [
                    { label: 'Daily Price', data: chartData.map(d => ({x: d.Date.valueOf(), y: d.DailyRate})), borderColor: 'rgb(54, 162, 235)', borderWidth: 1.5, pointRadius: 0, yAxisID: 'y' },
                    { label: simResults.maLabel, data: chartMA.map((val, i) => ({x: chartData[i].Date.valueOf(), y: val})), borderColor: 'rgb(255, 159, 64)', borderWidth: 1.5, pointRadius: 0, yAxisID: 'y' },
                    { label: `+${simResults.bandLabelText}% Band`, data: chartPlusBand.map((val, i) => ({x: chartData[i].Date.valueOf(), y: val})), borderColor: 'rgb(75, 192, 192)', borderDash: [5, 5], borderWidth: 1, pointRadius: 0, yAxisID: 'y' },
                    { label: `-${simResults.bandLabelText}% Band`, data: chartMinusBand.map((val, i) => ({x: chartData[i].Date.valueOf(), y: val})), borderColor: 'rgb(255, 99, 132)', borderDash: [5, 5], borderWidth: 1, pointRadius: 0, yAxisID: 'y' },
                    { label: 'Executed Buy', data: simResults.buySignals, pointStyle: 'triangle', radius: 7, rotation: 0, backgroundColor: 'rgba(40, 167, 69, 0.9)', type: 'scatter', yAxisID: 'y' },
                    { label: 'Executed Sell', data: simResults.executedSellSignals, pointStyle: 'triangle', radius: 7, rotation: 180, backgroundColor: 'rgba(220, 53, 69, 0.9)', type: 'scatter', yAxisID: 'y' },
                    { label: 'Potential Buy', data: simResults.potentialBuySignals, pointStyle: 'triangle', radius: 6, rotation: 0, backgroundColor: 'rgba(255, 255, 255, 0.1)', borderColor: 'rgba(40, 167, 69, 0.8)', borderWidth: 1.5, type: 'scatter', yAxisID: 'y' },
                    { label: 'Potential Sell', data: simResults.potentialSellSignals, pointStyle: 'triangle', radius: 6, rotation: 180, backgroundColor: 'rgba(255, 255, 255, 0.1)', borderColor: 'rgba(220, 53, 69, 0.8)', borderWidth: 1.5, type: 'scatter', yAxisID: 'y' }
                ];

                 // Add Bollinger Bands if available
                if (simResults.bb) {
                    const bbUpper = simResults.bb.upper.slice(firstValidIndex);
                    const bbLower = simResults.bb.lower.slice(firstValidIndex);
                    const bbMiddle = simResults.bb.middle.slice(firstValidIndex);
                     // Fill
                    datasets.push({
                        label: 'BB Area',
                        data: bbUpper.map((val, i) => ({ x: chartData[i].Date.valueOf(), y: val })),
                        fill: '+1', // Fill to the next dataset (bbLower)
                        backgroundColor: 'rgba(165, 180, 252, 0.1)',
                        borderColor: 'transparent',
                        pointRadius: 0,
                        yAxisID: 'y'
                    });
                     datasets.push({
                        label: 'BB Lower', // This will be hidden but is needed for the fill
                        data: bbLower.map((val, i) => ({ x: chartData[i].Date.valueOf(), y: val })),
                        borderColor: 'transparent',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                         yAxisID: 'y'
                    });
                    // Lines
                    datasets.push({ label: 'BB Upper', data: bbUpper.map((val, i) => ({x: chartData[i].Date.valueOf(), y: val})), borderColor: 'rgba(129, 140, 248, 0.5)', borderDash: [3, 3], borderWidth: 1, pointRadius: 0, yAxisID: 'y' });
                    datasets.push({ label: 'BB Lower', data: bbLower.map((val, i) => ({x: chartData[i].Date.valueOf(), y: val})), borderColor: 'rgba(129, 140, 248, 0.5)', borderDash: [3, 3], borderWidth: 1, pointRadius: 0, yAxisID: 'y' });
                     datasets.push({ label: 'BB Middle', data: bbMiddle.map((val, i) => ({x: chartData[i].Date.valueOf(), y: val})), borderColor: 'rgba(129, 140, 248, 0.8)', borderDash: [1, 1], borderWidth: 1, pointRadius: 0, yAxisID: 'y' });
                }
                
                const scales = { 
                    x: { type: 'time', time: { unit: 'year' }, title: { display: true, text: 'Date' } }, 
                    y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Rate' } }
                };

                const ctx = document.getElementById(canvasId).getContext('2d');
                return new Chart(ctx, {
                    type: 'line',
                    data: { datasets: datasets },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: scales,
                        plugins: { 
                             legend: {
                                labels: {
                                    filter: function(item, chart) {
                                        // Hide the BB Area and BB Lower from the legend
                                        return !item.text.includes('BB Area') && !item.text.includes('BB Lower');
                                    }
                                }
                            },
                            tooltip: { mode: 'index', intersect: false } 
                        }
                    }
                });
            }
            
            function renderVolatilityChart() {
                if (volatilityChart) {
                    volatilityChart.destroy();
                }

                const tenor = document.getElementById('tenor-select').value;
                const tenorFilteredData = filteredVolatilityData.filter(d => d.RC_Tenor === tenor);

                const labels = tenorFilteredData.map(d => d.EntryDate);
                const bidData = tenorFilteredData.map(d => d.Bid);
                const askData = tenorFilteredData.map(d => d.Ask);
                const avgData = tenorFilteredData.map(d => (d.Bid + d.Ask) / 2);

                const ctx = document.getElementById('volatilityChart').getContext('2d');
                volatilityChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Bid',
                            data: bidData,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            originalBorderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            pointRadius: 0
                        }, {
                            label: 'Ask',
                            data: askData,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            originalBorderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1,
                            pointRadius: 0
                        }, {
                            label: 'Average',
                            data: avgData,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            originalBorderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 2,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'year'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                onClick: legendFocusOnClick
                            }
                        }
                    }
                });
                volatilityChart.focusedDatasetIndex = null;
            }

            function renderVolatilityMAChart() {
                if(volatilityMAChart) {
                    volatilityMAChart.destroy();
                }
                
                const maPeriod = parseInt(document.getElementById('volatility-ma-period').value);
                const tenors = [...new Set(volatilityData.map(item => item.RC_Tenor))];
                const datasets = [];
                const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#E7E9ED', '#80E329', '#29E3D8', '#E3296D', '#2977E3', '#E3C329', '#8C29E3', '#E36E29', '#707070', '#000000'];

                const viewType = document.getElementById('volatility-view-select').value;
                const maPeriodGroup = document.getElementById('volatility-ma-period-group');
                maPeriodGroup.style.display = viewType === 'ma' ? 'block' : 'none';

                tenors.forEach((tenor, index) => {
                    const tenorFilteredData = filteredVolatilityData.filter(d => d.RC_Tenor === tenor);
                    const avgData = tenorFilteredData.map(d => (d.Bid + d.Ask) / 2);
                    const color = colors[index % colors.length];

                    if(viewType === 'ma') {
                        const maData = calculateSMA(avgData, maPeriod);
                        if (maData.some(d => d !== null)) {
                            datasets.push({
                                label: `${tenor} MA`,
                                data: maData.map((val, i) => val ? {x: tenorFilteredData[i].EntryDate.valueOf(), y: val} : null).filter(d => d),
                                borderColor: color,
                                originalBorderColor: color,
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            });
                        }
                    } else {
                        datasets.push({
                            label: `${tenor} Average`,
                            data: avgData.map((val, i) => val ? {x: tenorFilteredData[i].EntryDate.valueOf(), y: val} : null).filter(d => d),
                            borderColor: color,
                            originalBorderColor: color,
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        });
                    }
                });

                const ctx = document.getElementById('volatilityMAChart').getContext('2d');
                volatilityMAChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                     options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'year'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                onClick: legendFocusOnClick
                            }
                        }
                    }
                });
                volatilityMAChart.focusedDatasetIndex = null;
            }

            // Renders the transaction log table and final portfolio value
            function renderResults(transactions, tableContainerId, resultsContainerId, portfolioValue, initialInvestment, revenueId, revenuePercentId) {
                const tableContainer = document.getElementById(tableContainerId);
                if (resultsContainerId) {
                    document.getElementById(resultsContainerId).innerText = `Current Value: ${portfolioValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`;
                }
                
                if(revenueId) {
                 const revenue = portfolioValue - initialInvestment;
                 document.getElementById(revenueId).innerText = `Revenue: ${revenue.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`;
                }

                if(revenuePercentId) {
                 const revenuePercent = ((portfolioValue / initialInvestment) - 1) * 100;
                 document.getElementById(revenuePercentId).innerText = `Revenue %: ${revenuePercent.toFixed(2)}%`;
                }

                if (transactions.length === 0) {
                    tableContainer.innerHTML = '<p>No completed trades to display for this simulation.</p>';
                    return;
                }
                let tableHTML = '<table><thead><tr><th>Buy Date</th><th>Buy Price</th><th>Sell Date</th><th>Sell Price</th><th>Revenue ($)</th><th>Revenue (%)</th><th>Reason</th></tr></thead><tbody>';
                transactions.forEach(t => {
                    const revenueClass = t.revenueDollar >= 0 ? 'revenue-positive' : 'revenue-negative';
                    tableHTML += `<tr><td>${t.buyDate.toLocaleDateString()}</td><td>${t.buyPrice.toFixed(4)}</td><td>${t.sellDate.toLocaleDateString()}</td><td>${t.sellPrice.toFixed(4)}</td><td class="${revenueClass}">${t.revenueDollar.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}</td><td class="${revenueClass}">${t.revenuePercent.toFixed(2)}%</td><td>${t.reason || 'N/A'}</td></tr>`;
                });
                tableHTML += '</tbody></table>';
                tableContainer.innerHTML = tableHTML;
            }
            
            // Creates and returns the HTML for a data table
            function createDataTable(data, title) {
                let tableHTML = `<h3 style="margin-top: 30px;">${title}</h3><div class="table-container"><table><thead><tr><th>Date</th><th>Daily Rate</th><th>Moving Average</th><th>+ Band</th><th>- Band</th>`;
                tableHTML += '</tr></thead><tbody>';
                
                data.forEach(row => {
                    tableHTML += `<tr>
                        <td>${row.Date.toLocaleDateString()}</td>
                        <td>${row.DailyRate.toFixed(4)}</td>
                        <td>${row.MovingAverage ? row.MovingAverage.toFixed(4) : ''}</td>
                        <td>${row.PlusBand ? row.PlusBand.toFixed(4) : ''}</td>
                        <td>${row.MinusBand ? row.MinusBand.toFixed(4) : ''}</td>`;
                    tableHTML += `</tr>`;
                });
                tableHTML += '</tbody></table></div>';
                return tableHTML;
            }
            
            // Central function to run simulations
            function runSimulation(type) {
                const initialInvestment = parseFloat(document.getElementById('initialInvestment').value) || 1000000;
                let maPeriod, bandVariation, maLabel, movingAverage, chart, tableId, finalAmountId, isAdvanced = false, revenueId, revenuePercentId;
                
                const dataForSim = filteredData;

                switch(type) {
                    case 'default':
                        maPeriod = 65; 
                        bandVariation = 0.05;
                        movingAverage = dataForSim.map(d => d.ValueIndicator);
                        tableId = 'transaction-table';
                        finalAmountId = 'final-amount';
                        revenueId = 'default-revenue';
                        revenuePercentId = 'default-revenue-percent';
                        document.getElementById('initial-investment-display').innerText = `Initial Investment: ${initialInvestment.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`;
                        
                        maLabel = `${maPeriod}-day MA`;
                        const simResultsDefault = getFullSimulation(initialInvestment, dataForSim.map(d => d.DailyRate), movingAverage, bandVariation, dataForSim.map(d => d.Date));
                        simResultsDefault.maLabel = maLabel;
                        simResultsDefault.bandLabelText = (bandVariation * 100).toFixed(0);
                        mainChart = renderChart(mainChart, 'myChart', dataForSim, simResultsDefault);
                        renderResults(simResultsDefault.transactions, tableId, finalAmountId, simResultsDefault.portfolioValue, initialInvestment, revenueId, revenuePercentId);
                        break;

                    case 'advanced':
                        isAdvanced = true;
                         const settings = {
                            maPeriod: parseInt(document.getElementById('maPeriod').value),
                            bandVariation: parseFloat(document.getElementById('bandVariation').value) / 100,
                            rsiPeriod: parseInt(document.getElementById('rsiPeriod').value),
                            rsiOverbought: parseInt(document.getElementById('rsiOverbought').value),
                            rsiOversold: parseInt(document.getElementById('rsiOversold').value),
                            useRsiFilter: document.getElementById('useRsiFilter').checked,
                            bbPeriod: parseInt(document.getElementById('bbPeriod').value),
                            bbStdDev: parseFloat(document.getElementById('bbStdDev').value),
                            useBBFilter: document.getElementById('useBBFilter').checked,
                            stopLoss: parseFloat(document.getElementById('stopLoss').value),
                            takeProfit: parseFloat(document.getElementById('takeProfit').value),
                            useSLTP: document.getElementById('useSLTP').checked,
                        };

                        tableId = 'advanced-results-table';
                        finalAmountId = 'advanced-final-amount';
                        revenueId = 'advanced-revenue';
                        revenuePercentId = 'advanced-revenue-percent';
                        
                        const simResultsAdvanced = getAdvancedSimulation(initialInvestment, dataForSim, settings);
                        simResultsAdvanced.maLabel = `${settings.maPeriod}-day MA`;
                        simResultsAdvanced.bandLabelText = (settings.bandVariation * 100).toFixed(0);

                        advancedChart = renderChart(advancedChart, 'advancedChart', dataForSim, simResultsAdvanced);
                        renderResults(simResultsAdvanced.transactions, tableId, finalAmountId, simResultsAdvanced.portfolioValue, initialInvestment, revenueId, revenuePercentId);

                        const tableData = dataForSim.map((row, i) => ({
                              ...row,
                              MovingAverage: simResultsAdvanced.movingAverage[i],
                              PlusBand: simResultsAdvanced.plusBand[i],
                              MinusBand: simResultsAdvanced.minusBand[i]
                         }));
                        const first100 = tableData.slice(0, 100);
                        const last100 = tableData.slice(-100);
                        const dataTablesContainer = document.getElementById('data-tables-container');
                        dataTablesContainer.innerHTML = createDataTable(first100, 'First 100 Rows of Processed Data');
                        dataTablesContainer.innerHTML += createDataTable(last100, 'Last 100 Rows of Processed Data');
                        break;
                }
            }
            
            async function runOptimization() {
                const optimizationStatus = document.getElementById('optimization-status');
                optimizationStatus.innerText = 'Calculating optimal strategy... This may take a moment.';
                document.getElementById('getOptimizationAnalysisBtn').disabled = true;
                
                await new Promise(resolve => setTimeout(resolve, 0));

                const initialInvestment = parseFloat(document.getElementById('initialInvestment').value) || 1000000;
                let bestResult = { portfolioValue: -Infinity };
                let bestParams = {};
                
                const dataForSim = filteredData;

                const maPeriods = Array.from(document.getElementById('maPeriod').options).map(opt => parseInt(opt.value));
                const bandVariations = Array.from(document.getElementById('bandVariation').options).map(opt => parseFloat(opt.value));
                
                const dailyRates = dataForSim.map(d => d.DailyRate);
                const dates = dataForSim.map(d => d.Date);

                for (const ma of maPeriods) {
                    const movingAverage = calculateSMA(dailyRates, ma);
                    for (const band of bandVariations) {
                        const bandVar = band / 100;
                        const result = getFullSimulation(initialInvestment, dailyRates, movingAverage, bandVar, dates);
                        if(result.portfolioValue > bestResult.portfolioValue) {
                            bestResult = result;
                            bestParams = { ma, band };
                        }
                    }
                }

                // Store results globally for AI analysis
                bestOptimizationResult = bestResult;
                bestOptimizationParams = bestParams;

                optimizationStatus.innerText = 'Optimal strategy found!';
                
                // --- To draw the optimized chart, we need a simulation result object
                 const optMovingAverage = calculateSMA(dailyRates, bestParams.ma);
                 const optSimResults = getFullSimulation(initialInvestment, dailyRates, optMovingAverage, bestParams.band / 100, dates);
                 optSimResults.maLabel = `${bestParams.ma}-day MA`;
                 optSimResults.bandLabelText = (bestParams.band).toFixed(0);

                 optimizedChart = renderChart(optimizedChart, 'optimizedChart', dataForSim, optSimResults);
                 document.getElementById('optimized-params').innerText = `Optimal Parameters: ${bestParams.ma}-day MA, ${bestParams.band}% Bands`;
                 renderResults(optSimResults.transactions, 'optimized-results-table', 'optimized-final-amount', optSimResults.portfolioValue, initialInvestment, 'optimized-revenue', 'optimized-revenue-percent');

                document.getElementById('getOptimizationAnalysisBtn').disabled = false;
                document.getElementById('optimization-analysis-result').innerText = 'Click the button above to get an AI-powered analysis of the optimal strategy.';
            }

            function simpleMarkdownToHtml(text) {
                // This is a simplified parser. It handles the specific markdown returned by the API.
                let html = text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/^\s*[\*-]\s+(.*)$/gm, '<li>$1</li>')
                    .replace(/\n/g, '<br>');

                html = html.replace(/(<br>)?(<li>.*<\/li>)(<br>)?/gs, '<ul>$2</ul>');
                html = html.replace(/<\/ul>(<br>|\s)*<ul>/gs, '');
                
                html = html.replace(/<br><ul>/g, '<ul>');
                html = html.replace(/<\/ul><br>/g, '</ul>');

                return html;
            }

            async function getGeminiAnalysis(prompt, resultElementId, buttonElement) {
                const resultElement = document.getElementById(resultElementId);
                resultElement.innerHTML = '🧠 Analyzing with Gemini... Please wait.';
                buttonElement.disabled = true;

                try {
                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = "AIzaSyBe4FaOSzP9GaqTpcvW8lV-wKRu9nH82sA"; // API key is handled by the environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API call failed with status: ${response.status}. Body: ${errorBody}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        resultElement.innerHTML = simpleMarkdownToHtml(text);
                    } else {
                       resultElement.innerText = 'Could not get analysis from Gemini. The response was empty or malformed.';
                       console.log('Unexpected Gemini Response:', result);
                    }

                } catch (error) {
                    console.error("Gemini API Error:", error);
                    resultElement.innerText = `An error occurred while fetching analysis: ${error.message}`;
                } finally {
                    buttonElement.disabled = false;
                }
            }
            
            function calculateCorrelation(seriesA, seriesB, lag = 0) {
                let sA = seriesA.slice();
                let sB = seriesB.slice();

                if (lag > 0) { // sB lags sA
                    sA = sA.slice(0, -lag);
                    sB = sB.slice(lag);
                } else if (lag < 0) { // sA lags sB
                    sB = sB.slice(0, lag);
                    sA = sA.slice(-lag);
                }

                if (sA.length !== sB.length) {
                    const minLength = Math.min(sA.length, sB.length);
                    sA = sA.slice(0, minLength);
                    sB = sB.slice(0, minLength);
                }

                if (sA.length < 2) return 0; // Not enough data

                const meanA = sA.reduce((a, b) => a + b, 0) / sA.length;
                const meanB = sB.reduce((a, b) => a + b, 0) / sB.length;

                let numerator = 0;
                let denA = 0;
                let denB = 0;

                for (let i = 0; i < sA.length; i++) {
                    const diffA = sA[i] - meanA;
                    const diffB = sB[i] - meanB;
                    numerator += diffA * diffB;
                    denA += diffA * diffA;
                    denB += diffB * diffB;
                }

                if (denA === 0 || denB === 0) return 0;

                return numerator / Math.sqrt(denA * denB);
            }

            function runLeadIndicatorTest() {
                const priceDataMap = new Map(filteredData.map(d => [d.Date.getTime(), d.DailyRate]));
                const volDataMap = new Map(filteredVolatilityData
                    .filter(d => d.RC_Tenor === '3M')
                    .map(d => [d.EntryDate.getTime(), (d.Bid + d.Ask) / 2])
                );

                const alignedDates = [...priceDataMap.keys()].filter(date => volDataMap.has(date));
                const alignedPrices = alignedDates.map(date => priceDataMap.get(date));
                const alignedVols = alignedDates.map(date => volDataMap.get(date));
                
                if (alignedPrices.length < 30) {
                       document.getElementById('correlation-results').innerText = 'Not enough overlapping data points to run a meaningful correlation test.';
                       return;
                }

                const correlations = [];
                const lags = [];
                for (let lag = -30; lag <= 30; lag++) {
                    lags.push(lag);
                    correlations.push(calculateCorrelation(alignedPrices, alignedVols, lag));
                }

                if (correlationChart) {
                    correlationChart.destroy();
                }

                const ctx = document.getElementById('correlationChart').getContext('2d');
                correlationChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: lags,
                        datasets: [{
                            label: 'Correlation',
                            data: correlations,
                            backgroundColor: correlations.map(c => c >= 0 ? 'rgba(75, 192, 192, 0.6)' : 'rgba(255, 99, 132, 0.6)'),
                            borderColor: correlations.map(c => c >= 0 ? 'rgba(75, 192, 192, 1)' : 'rgba(255, 99, 132, 1)'),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { title: { display: true, text: 'Lag (in days) - Negative means Vol leads Price' } },
                            y: { title: { display: true, text: 'Pearson Correlation' }, min: -1, max: 1 }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    title: (tooltipItems) => `Lag: ${tooltipItems[0].label} days`,
                                    label: (tooltipItem) => `Correlation: ${tooltipItem.raw.toFixed(4)}`
                                }
                            }
                        }
                    }
                });

                let maxCorr = 0;
                let bestLag = 0;
                correlations.forEach((corr, index) => {
                    if (Math.abs(corr) > Math.abs(maxCorr)) {
                        maxCorr = corr;
                        bestLag = lags[index];
                    }
                });

                let resultText = `The highest correlation is ${maxCorr.toFixed(4)} at a lag of ${bestLag} days. \n`;
                if (bestLag < 0) {
                    resultText += `This suggests that 3M Tenor Average volatility is a leading indicator for the Daily Price by ${-bestLag} days. Changes in volatility tend to precede changes in price.`;
                } else if (bestLag > 0) {
                     resultText += `This suggests that the Daily Price is a leading indicator for 3M Tenor Average volatility by ${bestLag} days. Changes in price tend to precede changes in volatility.`;
                } else {
                    resultText += 'The strongest correlation is contemporaneous (0-day lag), suggesting volatility and price move together.';
                }
                 document.getElementById('correlation-results').innerText = resultText;
            }

            function runVolatilityStrategy(volMAPeriodOverride, volBandPctOverride) {
                const initialInvestment = parseFloat(document.getElementById('initialInvestment').value) || 1000000;
                const volMAPeriod = volMAPeriodOverride || parseInt(document.getElementById('volatilityMAPeriod').value, 10);
                const volBandPct = volBandPctOverride ? volBandPctOverride / 100 : parseFloat(document.getElementById('volatilityBand').value) / 100;
                
                const { portfolioValue, transactions, buySignals, sellSignals, alignedData, volMA, volPlusBand, volMinusBand } = getVolatilityStrategySimulation(initialInvestment, volMAPeriod, volBandPct);
                
                document.getElementById('volatility-strategy-params').innerText = `Parameters: ${volMAPeriod}-day Volatility MA, ${volBandPct * 100}% Bands`;
                
                renderVolatilityStrategyChart(alignedData, volMA, volPlusBand, volMinusBand, buySignals, sellSignals, volMAPeriod, volBandPct * 100);
                renderResults(
                    transactions, 
                    'volatility-strategy-results-table', 
                    'volatility-strategy-final-amount', 
                    portfolioValue, 
                    initialInvestment, 
                    'volatility-strategy-revenue', 
                    'volatility-strategy-revenue-percent'
                );
            }
            
            function getVolatilityStrategySimulation(initialInvestment, volMAPeriod, volBandPct) {
                 // Align price and volatility data
                const priceDataMap = new Map(filteredData.map(d => [d.Date.getTime(), d.DailyRate]));
                const volDataMap = new Map(filteredVolatilityData
                    .filter(d => d.RC_Tenor === '3M')
                    .map(d => [d.EntryDate.getTime(), (d.Bid + d.Ask) / 2])
                );

                const alignedData = [...priceDataMap.keys()]
                    .filter(date => volDataMap.has(date))
                    .map(date => ({
                        Date: new Date(date),
                        DailyRate: priceDataMap.get(date),
                        Volatility: volDataMap.get(date)
                    })).sort((a,b) => a.Date - b.Date);
                
                if (alignedData.length < volMAPeriod) {
                   return { portfolioValue: initialInvestment, transactions: [], buySignals: [], sellSignals: [], alignedData: [], volMA: [], volPlusBand: [], volMinusBand: [] };
                }

                const volatilities = alignedData.map(d => d.Volatility);
                const volMA = calculateSMA(volatilities, volMAPeriod);
                
                const volPlusBand = volMA.map(ma => ma ? ma * (1 + volBandPct) : null);
                const volMinusBand = volMA.map(ma => ma ? ma * (1 - volBandPct) : null);
                
                let portfolioValue = initialInvestment;
                let position = null;
                const buySignals = [];
                const sellSignals = [];
                const transactions = [];

                for (let i = 1; i < alignedData.length; i++) {
                     if (!volatilities[i] || !volPlusBand[i] || !volMinusBand[i] || !volatilities[i-1] || !volPlusBand[i-1] || !volMinusBand[i-1]) continue;

                    const volCrossedBelow = volatilities[i] < volMinusBand[i] && volatilities[i-1] >= volMinusBand[i-1];
                    const volCrossedAbove = volatilities[i] > volPlusBand[i] && volatilities[i-1] <= volPlusBand[i-1];

                    if (position === null && volCrossedBelow) { // Buy Signal
                        position = { valueAtBuy: portfolioValue, buyPrice: alignedData[i].DailyRate, buyDate: alignedData[i].Date };
                        buySignals.push({ x: alignedData[i].Date.valueOf(), y: alignedData[i].DailyRate });
                    } else if (position !== null && volCrossedAbove) { // Sell Signal
                        const profitRatio = alignedData[i].DailyRate / position.buyPrice;
                        const previousValue = position.valueAtBuy;
                        portfolioValue *= profitRatio;
                        transactions.push({
                            buyDate: position.buyDate, buyPrice: position.buyPrice,
                            sellDate: alignedData[i].Date, sellPrice: alignedData[i].DailyRate,
                            revenueDollar: portfolioValue - previousValue,
                            revenuePercent: (profitRatio - 1) * 100
                        });
                        position = null;
                        sellSignals.push({ x: alignedData[i].Date.valueOf(), y: alignedData[i].DailyRate });
                    }
                }

                return { portfolioValue, transactions, buySignals, sellSignals, alignedData, volMA, volPlusBand, volMinusBand };
            }

            async function runVolatilityOptimization() {
                const optimizationStatus = document.getElementById('volatility-optimization-status');
                optimizationStatus.innerText = 'Calculating optimal volatility strategy... This may take a moment.';
                
                await new Promise(resolve => setTimeout(resolve, 0));

                const initialInvestment = parseFloat(document.getElementById('initialInvestment').value) || 1000000;
                let bestResult = { portfolioValue: -Infinity };
                let bestParams = {};

                const volMAPeriods = Array.from(document.getElementById('volatilityMAPeriod').options).map(opt => parseInt(opt.value));
                const volBands = Array.from(document.getElementById('volatilityBand').options).map(opt => parseFloat(opt.value));

                for (const ma of volMAPeriods) {
                    for (const band of volBands) {
                        const bandPct = band / 100;
                        const result = getVolatilityStrategySimulation(initialInvestment, ma, bandPct);
                        if(result.portfolioValue > bestResult.portfolioValue) {
                            bestResult = result;
                            bestParams = { ma, band };
                        }
                    }
                }
                
                optimizationStatus.innerText = `Optimal Volatility Strategy Found: ${bestParams.ma}-day MA, ${bestParams.band}% Band`;
                runVolatilityStrategy(bestParams.ma, bestParams.band);
            }


            function renderVolatilityStrategyChart(alignedData, volMA, volPlusBand, volMinusBand, buySignals, sellSignals, volMAPeriod, volBandPct) {
                if (volatilityStrategyChart) {
                    volatilityStrategyChart.destroy();
                }

                const dates = alignedData.map(d => d.Date.valueOf());
                const dailyRates = alignedData.map(d => d.DailyRate);
                const volatilities = alignedData.map(d => d.Volatility);

                const ctx = document.getElementById('volatilityStrategyChart').getContext('2d');
                volatilityStrategyChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Price',
                                data: dailyRates,
                                borderColor: 'rgb(54, 162, 235)',
                                yAxisID: 'y',
                                pointRadius: 0
                            },
                            {
                                label: '3M Volatility',
                                data: volatilities,
                                borderColor: '#6f42c1',
                                yAxisID: 'y1',
                                pointRadius: 0
                            },
                            {
                                label: `${volMAPeriod}-day Vol MA`,
                                data: volMA,
                                borderColor: '#ffc107',
                                yAxisID: 'y1',
                                pointRadius: 0
                            },
                            {
                                label: `+${volBandPct.toFixed(0)}% Vol Band`,
                                data: volPlusBand,
                                borderColor: 'rgba(255, 99, 132, 0.8)',
                                borderDash: [5, 5],
                                yAxisID: 'y1',
                                pointRadius: 0
                            },
                             {
                                label: `-${volBandPct.toFixed(0)}% Vol Band`,
                                data: volMinusBand,
                                borderColor: 'rgba(75, 192, 192, 0.8)',
                                borderDash: [5, 5],
                                yAxisID: 'y1',
                                pointRadius: 0
                            },
                            { label: 'Buy Signal', data: buySignals, pointStyle: 'triangle', radius: 7, rotation: 0, backgroundColor: 'rgba(40, 167, 69, 0.9)', type: 'scatter', yAxisID: 'y' },
                            { label: 'Sell Signal', data: sellSignals, pointStyle: 'triangle', radius: 7, rotation: 180, backgroundColor: 'rgba(220, 53, 69, 0.9)', type: 'scatter', yAxisID: 'y' }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'time', time: { unit: 'year' }, title: { display: true, text: 'Date' } },
                            y: { type: 'linear', position: 'left', title: { display: true, text: 'EUR/NZD Rate' } },
                            y1: { type: 'linear', position: 'right', title: { display: true, text: '3M Volatility (%)' }, grid: { drawOnChartArea: false } }
                        },
                        plugins: {
                            tooltip: { mode: 'index', intersect: false }
                        }
                    }
                });
            }


            function filterDataByDateRange() {
                const slider = document.getElementById('date-slider').noUiSlider;
                const [startDateTimestamp, endDateTimestamp] = slider.get();
                
                filteredData = fullProcessedData.filter(d => {
                    const date = d.Date.getTime();
                    return date >= startDateTimestamp && date <= endDateTimestamp;
                });
                
                filteredVolatilityData = volatilityData.filter(d => {
                    const date = d.EntryDate.getTime();
                    return date >= startDateTimestamp && date <= endDateTimestamp;
                });

                runSimulation('default');
                runSimulation('advanced');
                renderVolatilityChart();
                renderVolatilityMAChart();
                
                // Reset optimization section
                document.getElementById('optimization-status').innerText = '';
                document.getElementById('optimized-params').innerText = 'Optimal Parameters: Not yet calculated.';
                document.getElementById('optimized-final-amount').innerText = 'Current Value: Waiting for optimization...';
                document.getElementById('optimized-revenue').innerText = 'Revenue: Waiting for optimization...';
                document.getElementById('optimized-revenue-percent').innerText = 'Revenue %: Waiting for optimization...';
                if(optimizedChart) optimizedChart.destroy();
                document.getElementById('optimized-results-table').innerHTML = '';
                document.getElementById('getOptimizationAnalysisBtn').disabled = true;

                // Reset correlation chart
                if (correlationChart) correlationChart.destroy();
                document.getElementById('correlation-results').innerText = '';
                
                 // Reset volatility strategy chart
                if (volatilityStrategyChart) volatilityStrategyChart.destroy();
                document.getElementById('volatility-strategy-params').innerText = 'Parameters: Not yet run.';
                document.getElementById('volatility-strategy-final-amount').innerText = 'Current Value: Waiting for simulation...';
                document.getElementById('volatility-strategy-revenue').innerText = 'Revenue: Waiting for simulation...';
                document.getElementById('volatility-strategy-revenue-percent').innerText = 'Revenue %: Waiting for simulation...';
                document.getElementById('volatility-strategy-results-table').innerHTML = '';
                document.getElementById('volatility-optimization-status').innerText = '';

            }
            
            async function initialize() {
                try {
                    console.log("Starting data initialization...");
                    const [fxResponse, volResponse] = await Promise.all([
                        fetch('./fx_NZD_EUR.csv').catch(e => { console.error("Fetch error for fx_NZD_EUR.csv:", e); throw e; }),
                        fetch('./VOL_EUR_NZD.csv').catch(e => { console.error("Fetch error for VOL_EUR_NZD.csv:", e); throw e; })
                    ]);

                    console.log("fx_NZD_EUR.csv response status:", fxResponse.status);
                    console.log("VOL_EUR_NZD.csv response status:", volResponse.status);

                    if (!fxResponse.ok) throw new Error(`Failed to fetch fx_NZD_EUR.csv. Status: ${fxResponse.status}`);
                    if (!volResponse.ok) throw new Error(`Failed to fetch VOL_EUR_NZD.csv. Status: ${volResponse.status}`);

                    const fxCsvData = await fxResponse.text();
                    const volCsvData = await volResponse.text();
                    console.log("Successfully fetched CSV data.");

                    
                    let rawData = fxCsvData.trim().split('\n').slice(1).map(row => {
                        const columns = row.split(',');
                        return {
                            Date: parseDate(columns[0]),
                            DailyRate: parseFloat(columns[1]),
                            ValueIndicator: parseFloat(columns[2])
                        };
                    });

                    for (let i = 1; i < rawData.length; i++) {
                        if (isNaN(rawData[i].DailyRate)) {
                            rawData[i].DailyRate = rawData[i-1].DailyRate;
                        }
                        if (isNaN(rawData[i].ValueIndicator)) {
                            rawData[i].ValueIndicator = rawData[i-1].ValueIndicator;
                        }
                    }

                    fullProcessedData = rawData.filter(row => row.Date && !isNaN(row.DailyRate) && !isNaN(row.ValueIndicator));
                    console.log("Processed", fullProcessedData.length, "rows from fx_NZD_EUR.csv");

                    
                    volatilityData = volCsvData.trim().split('\n').slice(1).map(row => {
                        const [EntryDate,Com,Term,DurationID,Bid,Ask,LastUpdate,RC_Tenor,MinDuration,MaxDuration] = row.split(',');
                        return {
                            EntryDate: parseDate(EntryDate),
                            RC_Tenor,
                            Bid: parseFloat(Bid),
                            Ask: parseFloat(Ask)
                        };
                    });
                    console.log("Processed", volatilityData.length, "rows from VOL_EUR_NZD.csv");


                    if (fullProcessedData.length > 0) {
                        const maSelect = document.getElementById('maPeriod');
                        const volMaSelect = document.getElementById('volatility-ma-period');
                        const volStrategyMaSelect = document.getElementById('volatilityMAPeriod');
                        for (let i = 10; i <= 200; i += 10) {
                             const option = document.createElement('option');
                            option.value = i;
                            option.text = `${i} days`;
                            if (i<=100) maSelect.appendChild(option.cloneNode(true));
                            if (i === 65) maSelect.querySelector('[value="60"]').selected = true; // Select closest available
                            volMaSelect.appendChild(option.cloneNode(true));
                            volStrategyMaSelect.appendChild(option.cloneNode(true));
                        }
                         maSelect.querySelector('[value="60"]').selected = true; // Select closest available
                         volMaSelect.querySelector('[value="60"]').selected = true;
                         volStrategyMaSelect.querySelector('[value="100"]').selected = true;
                        
                         volMaSelect.addEventListener('change', renderVolatilityMAChart);


                        const bandSelect = document.getElementById('bandVariation');
                        const volBandSelect = document.getElementById('volatilityBand');
                         for (let i = 1; i <= 10; i++) {
                            const option = document.createElement('option');
                            option.value = i;
                            option.text = `${i}%`;
                            if (i === 5) option.selected = true;
                            bandSelect.appendChild(option.cloneNode(true));
                            volBandSelect.appendChild(option.cloneNode(true));
                        }
                        
                        // Date Range Slider Setup
                        const dateSlider = document.getElementById('date-slider');
                        const startDate = fullProcessedData[0].Date.getTime();
                        const endDate = fullProcessedData[fullProcessedData.length - 1].Date.getTime();

                        noUiSlider.create(dateSlider, {
                            range: {
                                min: startDate,
                                max: endDate
                            },
                            start: [startDate, endDate],
                            connect: true,
                            tooltips: false
                        });
                        
                        dateSlider.noUiSlider.on('update', function (values, handle) {
                           document.getElementById('slider-start-date').innerHTML = new Date(+values[0]).toLocaleDateString();
                           document.getElementById('slider-end-date').innerHTML = new Date(+values[1]).toLocaleDateString();
                        });

                        dateSlider.noUiSlider.on('end', filterDataByDateRange);


                        document.getElementById('rerunBtn').addEventListener('click', () => runSimulation('default'));
                        document.getElementById('runAdvancedBtn').addEventListener('click', () => runSimulation('advanced'));
                        document.getElementById('runOptimizationBtn').addEventListener('click', runOptimization);
                        document.getElementById('runIndicatorTestBtn').addEventListener('click', runLeadIndicatorTest);
                        document.getElementById('runVolatilityStrategyBtn').addEventListener('click', () => runVolatilityStrategy());
                        document.getElementById('runVolatilityOptimizationBtn').addEventListener('click', runVolatilityOptimization);

                        
                        const tenorSelect = document.getElementById('tenor-select');
                        const tenors = [...new Set(volatilityData.map(item => item.RC_Tenor))];
                        tenors.forEach(tenor => {
                            const option = document.createElement('option');
                            option.value = tenor;
                            option.textContent = tenor;
                            if (tenor === '3M') {
                                option.selected = true;
                            }
                            tenorSelect.appendChild(option);
                        });
                        tenorSelect.addEventListener('change',() => {
                               renderVolatilityChart();
                               renderVolatilityMAChart();
                        });
                        
                        document.getElementById('volatility-view-select').addEventListener('change', renderVolatilityMAChart);
                        
                        // AI Analysis Button Listeners
                        document.getElementById('getOptimizationAnalysisBtn').addEventListener('click', function() {
                           if (bestOptimizationParams && bestOptimizationResult) {
                                const initialInvestment = parseFloat(document.getElementById('initialInvestment').value) || 1000000;
                                const slider = document.getElementById('date-slider').noUiSlider;
                                const [startDateTimestamp, endDateTimestamp] = slider.get();
                                const startDate = new Date(+startDateTimestamp).toLocaleDateString();
                                const endDate = new Date(+endDateTimestamp).toLocaleDateString();

                                const prompt = `
                                    As an expert financial analyst, provide a detailed qualitative analysis of the following EUR/NZD trading strategy optimization result.
                                    The analysis is for the period from ${startDate} to ${endDate}.
                                    The initial investment was ${initialInvestment.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}.

                                    Optimal Parameters Found:
                                    - Moving Average Period: ${bestOptimizationParams.ma} days
                                    - Variation Band: ${bestOptimizationParams.band}%

                                    Performance Results:
                                    - Final Portfolio Value: ${bestOptimizationResult.portfolioValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
                                    - Total Revenue: ${(bestOptimizationResult.portfolioValue - initialInvestment).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
                                    - Revenue Percentage: ${(((bestOptimizationResult.portfolioValue / initialInvestment) - 1) * 100).toFixed(2)}%
                                    - Number of Completed Trades: ${bestOptimizationResult.transactions.length}

                                    Please structure your analysis with the following sections:
                                    1.  **Parameter Interpretation:** What does a ${bestOptimizationParams.ma}-day MA suggest about the ideal market timing for this strategy? What does a ${bestOptimizationParams.band}% band imply about the required volatility for a trade signal (is it a high or low volatility strategy)?
                                    2.  **Performance Review:** Comment on the overall performance. Is the revenue significant? How does the number of trades impact the risk and potential costs (like commissions)?
                                    3.  **Risk Profile:** Based on these parameters, what is the likely risk profile of this strategy? Is it aggressive or conservative? What are the potential risks or market conditions where this strategy might underperform?
                                    4.  **Concluding Remarks:** Provide a summary conclusion about the viability of this optimized strategy.
                                `;
                                getGeminiAnalysis(prompt, 'optimization-analysis-result', this);
                           } else {
                                document.getElementById('optimization-analysis-result').innerText = "Please run the optimization first to generate data for analysis.";
                           }
                        });

                        document.getElementById('getVolatilityAnalysisBtn').addEventListener('click', function() {
                            const tenor = document.getElementById('tenor-select').value;
                            const slider = document.getElementById('date-slider').noUiSlider;
                            const [startDateTimestamp, endDateTimestamp] = slider.get();
                            const startDate = new Date(+startDateTimestamp).toLocaleDateString();
                            const endDate = new Date(+endDateTimestamp).toLocaleDateString();
                            const tenorFilteredData = filteredVolatilityData.filter(d => d.RC_Tenor === tenor);
                            
                            if (tenorFilteredData.length === 0) {
                                document.getElementById('volatility-analysis-result').innerText = "No volatility data available for the selected range and tenor.";
                                return;
                            }
                            
                            const avgBid = tenorFilteredData.reduce((sum, d) => sum + d.Bid, 0) / tenorFilteredData.length;
                            const avgAsk = tenorFilteredData.reduce((sum, d) => sum + d.Ask, 0) / tenorFilteredData.length;
                            const avgVol = (avgBid + avgAsk) / 2;

                            const prompt = `
                                As an expert financial analyst, provide a detailed qualitative analysis of the EUR/NZD implied volatility for the ${tenor} tenor, from ${startDate} to ${endDate}.
                                The data shows an average bid volatility of ${avgBid.toFixed(4)}% and an average ask volatility of ${avgAsk.toFixed(4)}%, resulting in an average mid-volatility of ${avgVol.toFixed(4)}%.

                                Based on the conceptual chart data, please structure your analysis with the following sections:
                                1.  **Volatility Trend Analysis:** Describe what the general trend of volatility (e.g., rising, falling, range-bound) suggests for the EUR/NZD pair during this period.
                                2.  **Potential Market Drivers:** What are the potential macroeconomic or geopolitical drivers that could explain periods of high or low volatility observed in the chart? (e.g., RBA/RBNZ announcements, US Federal Reserve policy, commodity prices).
                                3.  **Market Liquidity:** What does the bid-ask spread imply about market liquidity for options on this pair? Is it wide or tight, and what does that mean for traders?
                                4.  **Implications for Traders:** What are the key takeaways for options traders or corporate hedgers based on this volatility analysis? For instance, is it an expensive or cheap time to buy options?
                            `;
                            getGeminiAnalysis(prompt, 'volatility-analysis-result', this);
                        });

                        document.getElementById('getVolatilityMAAnalysisBtn').addEventListener('click', function() {
                            const maPeriod = document.getElementById('volatility-ma-period').value;
                            const viewType = document.getElementById('volatility-view-select').value;
                            const slider = document.getElementById('date-slider').noUiSlider;
                            const [startDateTimestamp, endDateTimestamp] = slider.get();
                            const startDate = new Date(+startDateTimestamp).toLocaleDateString();
                            const endDate = new Date(+endDateTimestamp).toLocaleDateString();
                            
                            let prompt;
                            if (viewType === 'ma') {
                                 prompt = `
                                    As an expert financial analyst, provide a detailed qualitative analysis of the moving averages of EUR/NZD implied volatility across different tenors, from ${startDate} to ${endDate}.
                                    A ${maPeriod}-day moving average is being applied to smooth the data.

                                    Based on the conceptual chart data, please structure your analysis with the following sections:
                                    1.  **Interpreting Term Structure:** Explain the significance of comparing moving averages of volatility for different tenors (e.g., what it means if the 1M MA is above the 1Y MA). This is known as the volatility term structure.
                                    2.  **Trend and Momentum:** What does the slope of these moving averages indicate about the market's expectation of future price swings? Are volatility expectations increasing or decreasing?
                                    3.  **Strategic Application:** How can a currency trader or a risk manager use this comparative view of volatility MAs to inform their hedging or trading strategies? For example, how could it help in choosing the tenor for an option?
                                `;
                            } else {
                                 prompt = `
                                    As an expert financial analyst, provide a detailed qualitative analysis of the average (mid) implied volatility term structure for EUR/NZD, from ${startDate} to ${endDate}.
                                    The chart displays the average volatility for multiple tenors simultaneously.

                                    Based on the conceptual chart data, please structure your analysis with the following sections:
                                    1.  **Term Structure Shape:** Describe the typical shape of the volatility term structure shown. Is it in 'contango' (upward sloping, where longer-term volatility is higher than shorter-term) or 'backwardation' (downward sloping)?
                                    2.  **Market Sentiment:** What does this shape imply about the market's current sentiment? Does it suggest near-term uncertainty or long-term stability (or vice-versa)?
                                    3.  **Impact of Events:** How might specific economic events (like central bank meetings or major data releases) be reflected in the term structure? For example, would you expect short-term or long-term volatility to be more affected?
                                `;
                            }

                            getGeminiAnalysis(prompt, 'volatility-ma-analysis-result', this);
                        });


                        // Setup collapsible sections
                        document.querySelectorAll('.collapsible-toggle').forEach(toggle => {
                            toggle.addEventListener('click', function() {
                                this.classList.toggle('expanded');
                                const content = this.nextElementSibling;
                                if (content.style.display === 'block') {
                                    content.style.display = 'none';
                                } else {
                                    content.style.display = 'block';
                                }
                            });
                        });
                        
                        filterDataByDateRange(); // Initial run with full date range

                    } else {
                        throw new Error('No processable data after cleaning. Please check the CSV file.');
                    }
                } catch(error) {
                    console.error("Initialization Error:", error);
                    document.getElementById('final-amount').innerText = `Error: ${error.message}`;
                    document.getElementById('advanced-final-amount').innerText = `Error: ${error.message}`;
                }
            }

            initialize();
        });
    </script>
</body>
</html>
