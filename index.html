<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 1.7 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USD Trading Opportunity Identifier</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better layout on smaller screens */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%; /* Make canvas responsive */
            height: 400px; /* Fixed height for charting */
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .input-group label {
            font-weight: 600;
            color: #4a5568;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        .btn-primary {
            background-color: #6366f1;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover {
            background-color: #4f46e5;
            transform: translateY(-1px);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.3);
        }
        .results-box {
            background-color: #edf2f7;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #d1d5db;
        }
        .results-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #2d3748;
        }
        .results-box p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #4a5568;
        }
        .message-box {
            background-color: #fefcbf;
            border: 1px solid #fbd38d;
            color: #92400e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
            text-align: center;
        }
        .error-message {
            background-color: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .optimization-results {
            background-color: #e0f2fe;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #90cdf4;
            margin-top: 20px;
        }
        .optimization-results h3 {
            color: #2b6cb0;
        }
        .warning-message {
            background-color: #ffe8d1; /* Light orange */
            border: 1px solid #ffcc80; /* Darker orange */
            color: #a0522d; /* Dark brown */
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: 500;
            text-align: center;
        }
        .hover-info-box {
            background-color: #1a202c; /* Dark background */
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.875rem;
            position: absolute;
            z-index: 10;
            pointer-events: none; /* Allows mouse events to pass through */
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: none; /* Hidden by default */
        }
        .chart-section {
            border: 1px solid #e2e8f0;
            border-radius: 15px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        .explanation-box {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .explanation-box h3 {
            font-size: 1.15rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: #2d3748;
        }
        .explanation-box p {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #4a5568;
        }
        .data-info {
            font-size: 0.95rem;
            color: #334155;
            margin-bottom: 10px;
            text-align: center;
        }
        .data-preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.85rem;
            text-align: left;
        }
        .data-preview-table th, .data-preview-table td {
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
        }
        .data-preview-table th {
            background-color: #e9eef4;
            font-weight: 600;
            color: #4a5568;
        }
        .data-preview-table tbody tr:nth-child(odd) {
            background-color: #f8fafc;
        }


        /* Responsive adjustments */
        @media (min-width: 768px) {
            .input-section {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-end;
            }
            .input-group {
                flex: 1;
                max-width: 48%; /* Adjust for spacing */
            }
        }
        @media (max-width: 767px) {
            .input-section {
                flex-direction: column;
                align-items: stretch;
            }
            .input-group {
                width: 100%;
            }
            .input-group input {
                width: 100%;
            }
            .btn-primary {
                width: 100%;
            }
            .optimization-inputs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">BTC/USD Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses **real historical BTC/USD price data from btc-usd-max.csv** and applies a Moving Average Crossover strategy to identify potential buy and sell signals.
            You can adjust the periods for the short and long moving averages. Hover over the "Current Strategy Simulation" chart to see price and date details.
        </p>

        <div class="explanation-box">
            <h3>How Buy and Sell Signals are Calculated (Moving Average Crossover Strategy):</h3>
            <p>
                This strategy uses two Moving Averages (MAs): a **Short MA** (faster, calculated over fewer data points/days, e.g., 2-day average) and a **Long MA** (slower, calculated over more data points/days, e.g., 5-day average).
                The core idea is to identify shifts in momentum:
            </p>
            <ul>
                <li><strong>Buy Trigger (Golden Cross):</strong> A signal to **BUY** is generated when the **Short MA crosses *above* the Long MA**. This indicates that short-term price momentum is gaining strength relative to the long-term trend, suggesting a potential uptrend.</li>
                <li><strong>Sell Trigger (Death Cross):</strong> A signal to **SELL** is generated when the **Short MA crosses *below* the Long MA**. This indicates that short-term price momentum is weakening relative to the long-term trend, suggesting a potential downtrend or a reversal of the uptrend.</li>
            </ul>
            <p>
                The model only buys if it's not already in a position and only sells if it is currently holding a position.
            </p>
        </div>

        <div class="input-section flex flex-col md:flex-row gap-4 mb-6">
            <div class="input-group">
                <label for="shortMA">Short MA Period (e.g., 2):</label>
                <input type="number" id="shortMA" value="2" min="2" max="50">
            </div>
            <div class="input-group">
                <label for="longMA">Long MA Period (e.g., 5):</label>
                <input type="number" id="longMA" value="5" min="3" max="100">
            </div>
            <button id="runSimulationBtn" class="btn-primary mt-auto">Run Simulation</button>
        </div>
        <div id="dataLengthWarning" class="warning-message hidden"></div>
        <p id="latestDataInfo" class="data-info hidden"></p>

        <div id="dataPreviewSection" class="results-box hidden">
            <h3>Latest 10 Data Points from CSV:</h3>
            <table class="data-preview-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Close Price (USD)</th> <!-- Updated currency unit -->
                    </tr>
                </thead>
                <tbody id="dataPreviewTableBody">
                    <!-- Data will be inserted here by JavaScript -->
                </tbody>
            </table>
        </div>


        <div id="currentSimulationSection" class="chart-section mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Current Strategy Simulation</h2>
            <div id="loadingSpinner" class="loading-spinner"></div>
            <canvas id="currentChartCanvas"></canvas>
            <div id="hoverInfoBox" class="hover-info-box"></div>
            <div id="currentSimulationResults" class="results-box hidden">
                <h3>Simulation Results:</h3>
                <p id="totalTrades"></p>
                <p id="winningTrades"></p>
                <p id="losingTrades"></p>
                <p id="simulatedProfit"></p>
                <div id="messageBox" class="message-box hidden"></div>
            </div>
        </div>


        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Strategy Optimization Tool</h2>
            <p class="text-gray-600 text-center mb-6">
                Find the optimum Short and Long Moving Average periods that would have maximized profit
                over the historical data.
            </p>
            <div class="optimization-inputs flex flex-col md:flex-row gap-4 mb-6">
                <div class="input-group">
                    <label for="minShortMA">Min Short MA:</label>
                    <input type="number" id="minShortMA" value="2" min="2" max="40">
                </div>
                <div class="input-group">
                    <label for="maxShortMA">Max Short MA:</label>
                    <input type="number" id="maxShortMA" value="5" min="5" max="50">
                </div>
                <div class="input-group">
                    <label for="minLongMA">Min Long MA:</label>
                    <input type="number" id="minLongMA" value="6" min="10" max="80">
                </div>
                <div class="input-group">
                    <label for="maxLongMA">Max Long MA:</label>
                    <input type="number" id="maxLongMA" value="15" min="30" max="100">
                </div>
                <button id="findOptimumBtn" class="btn-primary mt-auto">Find Optimum Strategy</button>
            </div>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden">
                <h3>Optimum Strategy Found:</h3>
                <p id="optimumShortMA"></p>
                <p id="optimumLongMA"></p>
                <p id="optimumProfit"></p>
                <p id="optimumTotalTrades"></p>
                <p id="optimumWinningTrades"></p>
                <p id="optimumLosingTrades"></p>
                <div id="optimizationMessageBox" class="message-box hidden"></div>
            </div>
            <div id="optimumStrategyChartSection" class="chart-section mt-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Optimum Strategy Chart</h2>
                <canvas id="optimumChartCanvas"></canvas>
                <div id="optimumHoverInfoBox" class="hover-info-box"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const currentChartCanvas = document.getElementById('currentChartCanvas');
            const currentCtx = currentChartCanvas.getContext('2d');
            const optimumChartCanvas = document.getElementById('optimumChartCanvas');
            const optimumCtx = optimumChartCanvas.getContext('2d');

            const shortMAPeriodInput = document.getElementById('shortMA');
            const longMAPeriodInput = document.getElementById('longMA');
            const runSimulationBtn = document.getElementById('runSimulationBtn');
            const currentSimulationResultsDiv = document.getElementById('currentSimulationResults');
            const totalTradesSpan = document.getElementById('totalTrades');
            const winningTradesSpan = document.getElementById('winningTrades');
            const losingTradesSpan = document.getElementById('losingTrades');
            const simulatedProfitSpan = document.getElementById('simulatedProfit');
            const messageBox = document.getElementById('messageBox');
            const loadingSpinner = document.getElementById('loadingSpinner');

            // Optimization elements
            const minShortMAInput = document.getElementById('minShortMA');
            const maxShortMAInput = document.getElementById('maxShortMA');
            const minLongMAInput = document.getElementById('minLongMA');
            const maxLongMAInput = document.getElementById('maxLongMA');
            const findOptimumBtn = document.getElementById('findOptimumBtn');
            const optimizationSpinner = document.getElementById('optimizationSpinner');
            const optimizationResultsDiv = document.getElementById('optimizationResults');
            const optimumShortMASpan = document.getElementById('optimumShortMA');
            const optimumLongMASpan = document.getElementById('optimumLongMA');
            const optimumProfitSpan = document.getElementById('optimumProfit');
            const optimumTotalTradesSpan = document.getElementById('optimumTotalTrades');
            const optimumWinningTradesSpan = document.getElementById('optimumWinningTrades');
            const optimumLosingTradesSpan = document.getElementById('optimumLosingTrades');
            const optimizationMessageBox = document.getElementById('optimizationMessageBox');
            const dataLengthWarning = document.getElementById('dataLengthWarning');

            // Data Info
            const latestDataInfo = document.getElementById('latestDataInfo');
            const dataPreviewSection = document.getElementById('dataPreviewSection');
            const dataPreviewTableBody = document.getElementById('dataPreviewTableBody');


            // Hover elements
            const hoverInfoBox = document.getElementById('hoverInfoBox');
            const optimumHoverInfoBox = document.getElementById('optimumHoverInfoBox');


            let historicalPrices = [];

            // Set canvas dimensions
            const CHART_HEIGHT = 400;
            let currentChartWidth = currentChartCanvas.offsetWidth;
            currentChartCanvas.height = CHART_HEIGHT;
            currentChartCanvas.width = currentChartWidth;
            optimumChartCanvas.height = CHART_HEIGHT;
            optimumChartCanvas.width = currentChartWidth;

            // Adjust canvas width on window resize for responsiveness
            window.addEventListener('resize', () => {
                currentChartWidth = currentChartCanvas.offsetWidth;
                currentChartCanvas.width = currentChartWidth;
                optimumChartCanvas.width = currentChartWidth;
                runSimulation();
                if (!optimizationResultsDiv.classList.contains('hidden') && bestOptimumPerformance) {
                    drawChart(optimumCtx, historicalPrices, calculateSMA(historicalPrices, bestOptimumShortMA), calculateSMA(historicalPrices, bestOptimumLongMA), bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, -1, -1, false, optimumHoverInfoBox);
                }
            });

            // --- Message Box Functions ---
            function showMessageBox(message, type = 'info', targetBox) {
                if (!targetBox) {
                    targetBox = messageBox;
                }
                targetBox.textContent = message;
                targetBox.classList.remove('hidden', 'message-box', 'error-message', 'warning-message');
                
                if (type === 'error') {
                    targetBox.classList.add('error-message');
                } else if (type === 'warning') {
                    targetBox.classList.add('warning-message');
                } else {
                    targetBox.classList.add('message-box');
                }
                targetBox.classList.remove('hidden');
            }

            function hideMessageBox(targetBox) {
                if (!targetBox) {
                    targetBox = messageBox;
                }
                targetBox.classList.add('hidden');
            }

            // --- CSV Data Fetching and Parsing ---
            async function fetchCSV(filePath) {
                loadingSpinner.style.display = 'block';
                showMessageBox('Loading historical data...', 'info', messageBox);
                try {
                    console.log('Attempting to fetch data from:', filePath);
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        console.error('Fetch response not OK:', response.status, response.statusText);
                        let errorMessage = `HTTP error! status: ${response.status} - ${response.statusText}`;
                        if (response.status === 0) {
                            errorMessage = 'Network Error: Unable to reach the server or CORS policy blocked the request. Check your internet connection or browser console for CORS details.';
                        }
                        throw new Error(errorMessage);
                    }
                    const csvText = await response.text();
                    console.log('CSV data fetched successfully.');
                    return parseCSV(csvText);
                } catch (error) {
                    console.error('Error fetching or parsing CSV:', error);
                    showMessageBox(`Failed to load data: ${error.message}. Please check console for details.`, 'error', messageBox);
                    return [];
                } finally {
                    loadingSpinner.style.display = 'none';
                }
            }

            function parseCSV(csvText) {
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) { // Changed to 2 because this CSV starts with headers directly
                    showMessageBox('CSV file is empty or has insufficient data rows after header.', 'error', messageBox);
                    return [];
                }

                // Headers are on the first line (index 0)
                const rawHeaders = lines[0].split(','); // Delimiter is comma
                const headers = rawHeaders.map(h => h.trim().replace(/"/g, ''));
                console.log('Raw headers line:', lines[0]); // Debug: see raw headers line
                console.log('Headers after trimming and unquoting:', headers); // Debug: check processed headers

                // Updated to match "price" and "snapped_at"
                const closePriceIndex = headers.indexOf('price'); 
                const dateIndex = headers.indexOf('snapped_at');

                if (closePriceIndex === -1) {
                    showMessageBox('CSV missing "price" column. Please check column headers (expected: "price").', 'error', messageBox);
                    return [];
                }
                 if (dateIndex === -1) {
                    showMessageBox('CSV missing "snapped_at" column. Chart x-axis labels might be less informative (expected: "snapped_at").', 'info', messageBox);
                }

                const data = [];
                // Start iterating from the second line for actual data (index 1)
                for (let i = 1; i < lines.length; i++) { // Adjusted loop start
                    const columns = lines[i].split(','); // Delimiter is comma
                    const closePrice = columns[closePriceIndex] ? parseFloat(columns[closePriceIndex]) : NaN;
                    const date = columns[dateIndex] ? columns[dateIndex].replace(/"/g, '') : '';

                    if (!isNaN(closePrice)) {
                        data.push({
                            price: closePrice,
                            date: date
                        });
                        // Debug: log parsed row data for a few rows
                        // if (i < 5) console.log(`Parsed row ${i}: Date=${date}, Close=${closePrice}, Is NaN?=${isNaN(closePrice)}`);
                    } else {
                        // if (i < 5) console.log(`Skipped row ${i} due to NaN closePrice: ${columns[closePriceIndex]}`);
                    }
                }
                console.log('CSV parsed. Number of data points:', data.length);
                console.log('Historical Prices after parsing (first 5):', data.slice(0, 5)); // Debug: show first few items
                return data; // Removed .reverse() here, as data should be chronological already
            }

            // --- Technical Analysis Functions ---
            function calculateSMA(data, period) {
                if (period <= 0 || period > data.length) {
                    return Array(data.length).fill(null);
                }
                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val.price, 0);
                        sma.push(sum / period);
                    }
                }
                return sma;
            }

            function calculateStrategyPerformance(pricesData, shortPeriod, longPeriod) {
                const shortMA = calculateSMA(pricesData, shortPeriod);
                const longMA = calculateSMA(pricesData, longPeriod);

                const signals = [];
                let totalProfitLoss = 0;
                let tradesCount = 0;
                let winningTrades = 0;
                let losingTrades = 0;
                let currentTradeEntryPrice = null;
                let inPosition = false;

                const startLookingIndex = Math.max(shortPeriod, longPeriod);


                for (let i = startLookingIndex; i < pricesData.length; i++) {
                    const currentPrice = pricesData[i].price;

                    if (shortMA[i] !== null && longMA[i] !== null && shortMA[i - 1] !== null && longMA[i - 1] !== null) {
                        // Buy Signal: Short MA crosses above Long MA (Golden Cross)
                        if (shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i]) {
                            if (!inPosition) {
                                signals.push({ index: i, type: 'buy', price: currentPrice });
                                inPosition = true;
                                currentTradeEntryPrice = currentPrice;
                            }
                        }
                        // Sell Signal: Short MA crosses below Long MA (Death Cross)
                        else if (shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i]) {
                            if (inPosition) {
                                const tradeProfitLoss = currentPrice - currentTradeEntryPrice;

                                signals.push({
                                    index: i,
                                    type: 'sell',
                                    price: currentPrice,
                                    entryPrice: currentTradeEntryPrice,
                                    profitLoss: tradeProfitLoss
                                });
                                tradesCount++;
                                totalProfitLoss += tradeProfitLoss;

                                if (tradeProfitLoss > 0) {
                                    winningTrades++;
                                } else if (tradeProfitLoss < 0) {
                                    losingTrades++;
                                }
                                inPosition = false;
                                currentTradeEntryPrice = 0;
                            }
                        }
                    }
                }

                if (inPosition && currentTradeEntryPrice !== null) {
                    tradesCount++;
                    const lastPrice = pricesData[pricesData.length - 1].price;
                    const profitLoss = lastPrice - currentTradeEntryPrice;
                    totalProfitLoss += profitLoss;
                    if (profitLoss > 0) {
                        winningTrades++;
                    } else if (profitLoss < 0) {
                        losingTrades++;
                    }
                }
                
                console.log(`Strategy Performance for Short MA ${shortPeriod}, Long MA ${longPeriod}:`, { totalProfitLoss, tradesCount, winningTrades, losingTrades, signals });

                return { totalProfitLoss, tradesCount, winningTrades, losingTrades, signals };
            }

            // --- Charting Functions ---
            function drawChart(ctx, pricesData, shortMA, longMA, signals, canvasWidth, canvasHeight, hoverX = -1, hoverY = -1, isMainChart = false, hoverInfoBoxElement = null) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                const prices = pricesData.map(d => d.price);

                const allValues = [...prices, ...shortMA.filter(v => v !== null), ...longMA.filter(v => v !== null)];
                const minPrice = Math.min(...allValues);
                const maxPrice = Math.max(...allValues);
                const priceRange = maxPrice - minPrice;

                console.log('Chart drawing values:', { minPrice: minPrice, maxPrice: maxPrice, priceRange: priceRange, pricesLength: pricesData.length });


                if (priceRange === 0) {
                    if (isMainChart) showMessageBox('Price range is zero. Cannot draw chart. This might happen if all loaded prices are identical, or there\'s insufficient data range.', 'error', messageBox);
                    return;
                }

                const xScale = canvasWidth / (prices.length - 1);
                const yScale = canvasHeight / priceRange;

                const getY = (price) => canvasHeight - ((price - minPrice) * yScale);
                const getX = (index) => index * xScale;

                // --- Draw Grid ---
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 0.5;

                // Horizontal grid lines
                const numHorizontalLines = 5;
                for (let i = 0; i <= numHorizontalLines; i++) {
                    const yGrid = canvasHeight / numHorizontalLines * i;
                    ctx.beginPath();
                    ctx.moveTo(0, yGrid);
                    ctx.lineTo(canvasWidth, yGrid);
                    ctx.stroke();
                }

                // Vertical grid lines
                const numVerticalLines = Math.min(prices.length, 10);
                const xInterval = canvasWidth / (numVerticalLines > 1 ? numVerticalLines - 1 : 1);
                for (let i = 0; i < numVerticalLines; i++) {
                    const xGrid = xInterval * i;
                    ctx.beginPath();
                    ctx.moveTo(xGrid, 0);
                    ctx.lineTo(xGrid, canvasHeight);
                    ctx.stroke();
                }


                // Draw Price Line
                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                prices.forEach((price, i) => {
                    if (i === 0) {
                        ctx.moveTo(getX(i), getY(price));
                    } else {
                        ctx.lineTo(getX(i), getY(price));
                    }
                });
                ctx.stroke();

                // Draw Short MA Line
                ctx.beginPath();
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1.5;
                shortMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (i === 0 || shortMA[i - 1] === null) {
                             ctx.moveTo(getX(i), getY(ma));
                        } else {
                             ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                // Draw Long MA Line
                ctx.beginPath();
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 1.5;
                longMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (i === 0 || longMA[i - 1] === null) {
                            ctx.moveTo(getX(i), getY(ma));
                        } else {
                            ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                // Draw Signals
                signals.forEach(signal => {
                    ctx.beginPath();
                    const x = getX(signal.index);
                    const y = getY(prices[signal.index]);

                    if (signal.type === 'buy') {
                        ctx.fillStyle = '#22c55e';
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                    } else { // sell signal
                        ctx.fillStyle = '#ef4444';
                        ctx.rect(x - 6, y - 6, 12, 12);
                    }
                    ctx.fill();

                    // Display Profit/Loss for sell trades on ANY chart that requests it
                    if (signal.type === 'sell' && signal.profitLoss !== undefined) {
                        const pL = signal.profitLoss.toFixed(2); // Changed to toFixed(2) for USD
                        ctx.fillStyle = signal.profitLoss >= 0 ? '#10b981' : '#ef4444';
                        ctx.font = 'bold 13px Inter';
                        const text = `${pL > 0 ? '+' : ''}${pL}`;
                        
                        const textWidth = ctx.measureText(text).width;
                        const textHeight = 13; 

                        let textX = x + 15;
                        let textY = y - 15;

                        // Adjusted positioning logic to ensure visibility within canvas bounds
                        const padding = 5; 

                        // Try above-right
                        if (textX + textWidth > canvasWidth - padding) { 
                            textX = x - textWidth - padding; 
                        }
                        if (textX < padding) textX = x + padding; 

                        if (textY < textHeight + padding) { 
                            textY = y + 15 + textHeight + padding; 
                        }
                        if (textY > canvasHeight - padding) textY = y - 15 - textHeight - padding; 

                        ctx.fillText(text, textX, textY);
                    }
                });

                // --- Draw Axes Labels (Improved) ---
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Inter';
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'right';

                // Y-axis labels
                const numYLabels = 5;
                for (let i = 0; i <= numYLabels; i++) {
                    const priceLabel = minPrice + (priceRange / numYLabels * i);
                    const yPos = getY(priceLabel);
                    ctx.fillText(`${priceLabel.toFixed(2)}`, canvasWidth - 10, yPos); // Changed to toFixed(2) for USD
                }
                ctx.textAlign = 'left';

                // X-axis labels (Dates)
                ctx.textBaseline = 'top';
                const numXLabels = Math.min(pricesData.length, 5);
                if (pricesData.length > 0) {
                    for (let i = 0; i < numXLabels; i++) {
                        const index = Math.floor(i * (pricesData.length - 1) / (numXLabels > 1 ? numXLabels - 1 : 1));
                        const date = new Date(pricesData[index].date);
                        const xPos = getX(index);
                        ctx.fillText(date.toLocaleDateString(), xPos + 5, canvasHeight - 25);
                    }
                }

                // --- Draw Crosshair and Hover Info ---
                if (hoverX !== -1 && hoverY !== -1 && hoverInfoBoxElement) { // Check if hoverInfoBoxElement is provided
                    // Draw vertical crosshair
                    ctx.beginPath();
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 1;
                    ctx.moveTo(hoverX, 0);
                    ctx.lineTo(hoverX, canvasHeight);
                    ctx.stroke();

                    // Draw horizontal crosshair
                    ctx.beginPath();
                    ctx.moveTo(0, hoverY);
                    ctx.lineTo(canvasWidth, hoverY);
                    ctx.stroke();

                    // Calculate closest data point
                    const dataIndex = Math.round(hoverX / xScale);
                    if (dataIndex >= 0 && dataIndex < pricesData.length) {
                        const hoveredData = pricesData[dataIndex];
                        const hoveredDate = new Date(hoveredData.date).toLocaleDateString();
                        const hoveredPrice = hoveredData.price.toFixed(2); // Changed to toFixed(2) for USD
                        const hoverMAShort = shortMA[dataIndex] !== null ? shortMA[dataIndex].toFixed(2) : 'N/A'; // Changed to toFixed(2) for USD
                        const hoverMALong = longMA[dataIndex] !== null ? longMA[dataIndex].toFixed(2) : 'N/A'; // Changed to toFixed(2) for USD

                        hoverInfoBoxElement.style.display = 'block'; // Use the passed element
                        hoverInfoBoxElement.innerHTML = `
                            <strong>Date:</strong> ${hoveredDate}<br>
                            <strong>Price:</strong> $${hoveredPrice}<br>
                            <strong>Short MA:</strong> ${hoverMAShort}<br>
                            <strong>Long MA:</strong> ${hoverMALong}
                        `;

                        // Position info box relative to the document, taking its *own* canvas position into into account
                        const currentCanvasRect = ctx.canvas.getBoundingClientRect(); 
                        let boxX = hoverX + currentCanvasRect.left + 15;
                        let boxY = hoverY + currentCanvasRect.top - (hoverInfoBoxElement.offsetHeight / 2);

                        if (boxX + hoverInfoBoxElement.offsetWidth > window.innerWidth) {
                            boxX = hoverX + currentCanvasRect.left - hoverInfoBoxElement.offsetWidth - 15;
                        }
                        if (boxY < currentCanvasRect.top) {
                            boxY = currentCanvasRect.top;
                        }
                        if (boxY + hoverInfoBoxElement.offsetHeight > window.innerHeight) {
                            boxY = window.innerHeight - hoverInfoBoxElement.offsetHeight - 10;
                        }

                        hoverInfoBoxElement.style.left = `${boxX}px`;
                        hoverInfoBoxElement.style.top = `${boxY}px`;
                    }
                } else if (hoverInfoBoxElement) { // Hide if not hovering or no data
                    hoverInfoBoxElement.style.display = 'none';
                }
            }

            // --- Main Simulation Logic (for manual input) ---
            function runSimulation() {
                hideMessageBox(messageBox); // Hide general messages for main chart
                dataLengthWarning.classList.add('hidden'); // Hide specific data length warning

                const shortPeriod = parseInt(shortMAPeriodInput.value);
                const longPeriod = parseInt(longMAPeriodInput.value);

                console.log('runSimulation started. shortPeriod:', shortPeriod, 'longPeriod:', longPeriod); // Debugging: log inputs
                console.log('historicalPrices length:', historicalPrices.length); // Debugging: log data length

                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded. Please ensure data is available.', 'error', messageBox);
                    currentSimulationResultsDiv.classList.add('hidden');
                    currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height); // Clear chart on error
                    return;
                }

                if (isNaN(shortPeriod) || isNaN(longPeriod) || shortPeriod <= 0 || longPeriod <= 0) {
                    showMessageBox('Please enter valid positive numbers for MA periods.', 'error', messageBox);
                    currentSimulationResultsDiv.classList.add('hidden');
                    currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height);
                    return;
                }
                if (shortPeriod >= longPeriod) {
                    showMessageBox('Short MA period must be less than Long MA period.', 'error', messageBox);
                    currentSimulationResultsDiv.classList.add('hidden');
                    currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height);
                    return;
                }
                // Warn if not enough data for the selected MA periods
                if (longPeriod > historicalPrices.length) {
                     const requiredData = longPeriod;
                     const availableData = historicalPrices.length;
                     showMessageBox(`Not enough data for Long MA period ${longPeriod}. You need at least ${requiredData} data points, but only ${availableData} are available. Adjust MA periods or provide more data.`, 'warning', dataLengthWarning); // Use general warning box
                     currentSimulationResultsDiv.classList.add('hidden');
                     currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height);
                     return;
                }

                const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);
                const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                const longMAValues = calculateSMA(historicalPrices, longPeriod);

                currentSimulationResultsDiv.classList.remove('hidden');
                totalTradesSpan.textContent = `Total completed trades: ${performance.tradesCount}`;
                winningTradesSpan.textContent = `Winning trades: ${performance.winningTrades}`;
                losingTradesSpan.textContent = `Losing trades: ${performance.losingTrades}`;
                simulatedProfitSpan.textContent = `Simulated Profit/Loss: $${performance.totalProfitLoss.toFixed(2)} USD (for 1 unit of BTC traded)`;
                simulatedProfitSpan.style.color = performance.totalProfitLoss >= 0 ? '#10b981' : '#ef4444';

                drawChart(currentCtx, historicalPrices, shortMAValues, longMAValues, performance.signals, currentChartCanvas.width, currentChartCanvas.height, -1, -1, true, hoverInfoBox);
            }

            let bestOptimumShortMA = 0;
            let bestOptimumLongMA = 0;
            let bestOptimumPerformance = null;

            // --- Optimization Logic ---
            async function findOptimumStrategy() {
                hideMessageBox(optimizationMessageBox);
                optimizationResultsDiv.classList.add('hidden');
                dataLengthWarning.classList.add('hidden');

                const minShort = parseInt(minShortMAInput.value);
                const maxShort = parseInt(maxShortMAInput.value);
                const minLong = parseInt(minLongMAInput.value);
                const maxLong = parseInt(maxLongMAInput.value);

                if (isNaN(minShort) || isNaN(maxShort) || isNaN(minLong) || isNaN(maxLong) ||
                    minShort <= 0 || maxShort <= 0 || minLong <= 0 || maxLong <= 0) {
                    showMessageBox('Please enter valid positive numbers for all optimization ranges.', 'error', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }
                if (minShort >= maxShort || minLong >= maxLong || maxShort >= minLong) {
                    showMessageBox('Optimization ranges are invalid. Ensure Min < Max for each, and Max Short < Min Long.', 'error', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }
                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded for optimization. Please ensure data is available.', 'error', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }
                if (maxLong > historicalPrices.length) {
                    const requiredData = maxLong;
                    const availableData = historicalPrices.length;
                    showMessageBox(`Optimization range's Max Long MA (${maxLong}) is too large. You need at least ${requiredData} data points, but only ${availableData} are available. Adjust range.`, 'warning', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }

                optimizationSpinner.style.display = 'block';
                showMessageBox('Searching for optimum strategy...', 'info', optimizationMessageBox);

                let bestProfit = -Infinity;
                let bestShortMA = 0;
                let bestLongMA = 0;
                bestOptimumPerformance = null;

                for (let shortPeriod = minShort; shortPeriod <= maxShort; shortPeriod++) {
                    for (let longPeriod = minLong; longPeriod <= maxLong; longPeriod++) {
                        if (shortPeriod >= longPeriod) {
                            continue;
                        }
                        if (longPeriod > historicalPrices.length) {
                            continue;
                        }

                        const currentPerformance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);

                        if (currentPerformance.totalProfitLoss > bestProfit) {
                            bestProfit = currentPerformance.totalProfitLoss;
                            bestShortMA = shortPeriod;
                            bestLongMA = longPeriod;
                            bestOptimumPerformance = currentPerformance;
                        }
                    }
                }

                optimizationSpinner.style.display = 'none';
                optimizationResultsDiv.classList.remove('hidden');

                optimumShortMASpan.textContent = `Optimum Short MA Period: ${bestShortMA}`;
                optimumLongMASpan.textContent = `Optimum Long MA Period: ${bestLongMA}`;
                optimumProfitSpan.textContent = `Maximum Simulated Profit: $${bestProfit.toFixed(2)} USD`;
                optimumProfitSpan.style.color = bestProfit >= 0 ? '#10b981' : '#ef4444';

                if (bestOptimumPerformance) {
                    optimumTotalTradesSpan.textContent = `Total completed trades: ${bestOptimumPerformance.tradesCount}`;
                    optimumWinningTradesSpan.textContent = `Winning trades: ${bestOptimumPerformance.winningTrades}`;
                    optimumLosingTradesSpan.textContent = `Losing trades: ${bestOptimumPerformance.losingTrades}`;
                } else {
                    optimumTotalTradesSpan.textContent = `Total completed trades: 0`;
                    optimumWinningTradesSpan.textContent = `Winning trades: 0`;
                    optimumLosingTradesSpan.textContent = `Losing trades: 0`;
                }

                if (bestProfit <= 0 && bestOptimumPerformance && bestOptimumPerformance.tradesCount > 0) {
                     showMessageBox(`Optimization complete. While trades were made, no net positive profit strategy was found within the tested ranges for this historical data. The displayed strategy represents the best outcome (least loss or break-even). This is common with simple strategies in complex markets.`, 'info', optimizationMessageBox);
                } else if (bestProfit <= 0 && bestOptimumPerformance && bestOptimumPerformance.tradesCount === 0) {
                     showMessageBox(`Optimization complete. No trades were made with any strategy within the tested ranges. This typically means the MA periods are too large for the data, or the price action was too flat for crossovers.`, 'info', optimizationMessageBox);
                }
                else {
                    showMessageBox('Optimization complete. Best strategy found!', 'info', optimizationMessageBox);
                }

                // Draw the optimum chart
                if (bestOptimumPerformance) {
                    const optimumShortMAValues = calculateSMA(historicalPrices, bestShortMA);
                    const optimumLongMAValues = calculateSMA(historicalPrices, bestLongMA);
                    drawChart(optimumCtx, historicalPrices, optimumShortMAValues, optimumLongMAValues, bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, -1, -1, false, optimumHoverInfoBox);
                } else {
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                }

                // Update main simulation inputs and run it with the optimum strategy (optional, but good for quick view)
                shortMAPeriodInput.value = bestShortMA;
                longMAPeriodInput.value = bestLongMA;
                runSimulation();
            }

            // Path for the CSV file (using /__run__/resources/ for Canvas environment)
            const csvFilePath = './btc-usd-max.csv'; // Updated file path

            historicalPrices = await fetchCSV(csvFilePath);

            // Display latest data info and preview table if loaded
            if (historicalPrices.length > 0) {
                const latestData = historicalPrices[historicalPrices.length - 1];
                latestDataInfo.textContent = `Latest Data: Date ${new Date(latestData.date).toLocaleDateString()}, Price $${latestData.price.toFixed(2)} USD`; // Changed currency unit and precision
                latestDataInfo.classList.remove('hidden');

                // Populate data preview table
                dataPreviewTableBody.innerHTML = ''; // Clear existing
                const numPreviewRows = Math.min(historicalPrices.length, 10);
                // Iterate backwards to show latest data at the top of the table
                for (let i = historicalPrices.length - 1; i >= historicalPrices.length - numPreviewRows; i--) {
                    const rowData = historicalPrices[i];
                    const row = dataPreviewTableBody.insertRow();
                    const dateCell = row.insertCell();
                    const priceCell = row.insertCell();
                    dateCell.textContent = new Date(rowData.date).toLocaleDateString();
                    priceCell.textContent = `$${rowData.price.toFixed(2)}`; // Changed currency unit and precision
                }
                dataPreviewSection.classList.remove('hidden');
            } else {
                latestDataInfo.classList.add('hidden');
                dataPreviewSection.classList.add('hidden');
            }


            runSimulationBtn.addEventListener('click', runSimulation);
            findOptimumBtn.addEventListener('click', findOptimumStrategy);

            // --- Rollover Interaction Setup for Current Chart ---
            currentChartCanvas.addEventListener('mousemove', (e) => {
                const rect = currentChartCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (historicalPrices.length > 0) {
                    const shortPeriod = parseInt(shortMAPeriodInput.value);
                    const longPeriod = parseInt(longMAPeriodInput.value);
                    const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                    const longMAValues = calculateSMA(historicalPrices, longPeriod);
                    const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);

                    drawChart(currentCtx, historicalPrices, shortMAValues, longMAValues, performance.signals, currentChartCanvas.width, currentChartCanvas.height, mouseX, mouseY, true, hoverInfoBox);
                }
            });

            currentChartCanvas.addEventListener('mouseout', () => {
                if (historicalPrices.length > 0) {
                    const shortPeriod = parseInt(shortMAPeriodInput.value);
                    const longPeriod = parseInt(longMAPeriodInput.value);
                    const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                    const longMAValues = calculateSMA(historicalPrices, longPeriod);
                    const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);
                    
                    drawChart(currentCtx, historicalPrices, shortMAValues, longMAValues, performance.signals, currentChartCanvas.width, currentChartCanvas.height, -1, -1, true, hoverInfoBox);
                }
                hoverInfoBox.style.display = 'none';
            });

            // --- Rollover Interaction Setup for Optimum Chart ---
            optimumChartCanvas.addEventListener('mousemove', (e) => {
                const rect = optimumChartCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (historicalPrices.length > 0 && bestOptimumPerformance) { // Only enable if optimization has run
                    const shortMAValues = calculateSMA(historicalPrices, bestOptimumShortMA);
                    const longMAValues = calculateSMA(historicalPrices, bestOptimumLongMA);

                    drawChart(optimumCtx, historicalPrices, optimumShortMAValues, optimumLongMAValues, bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, mouseX, mouseY, false, optimumHoverInfoBox);
                }
            });

            optimumChartCanvas.addEventListener('mouseout', () => {
                if (historicalPrices.length > 0 && bestOptimumPerformance) {
                    const shortMAValues = calculateSMA(historicalPrices, bestOptimumShortMA);
                    const longMAValues = calculateSMA(historicalPrices, bestOptimumLongMA);
                    
                    drawChart(optimumCtx, historicalPrices, optimumShortMAValues, optimumLongMAValues, bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, -1, -1, false, optimumHoverInfoBox);
                }
                optimumHoverInfoBox.style.display = 'none';
            });


            // Initial run on load only if data was loaded successfully.
            if (historicalPrices.length > 0) {
                runSimulation();
            }
        });
    </script>
</body>
</html>
