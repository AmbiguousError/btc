<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USD/Bitcoin Trading Opportunity Identifier</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better layout on smaller screens */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%; /* Make canvas responsive */
            height: 400px; /* Fixed height for charting */
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .input-group label {
            font-weight: 600;
            color: #4a5568;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        .btn-primary {
            background-color: #6366f1;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover {
            background-color: #4f46e5;
            transform: translateY(-1px);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.3);
        }
        .results-box {
            background-color: #edf2f7;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #d1d5db;
        }
        .results-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #2d3748;
        }
        .results-box p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #4a5568;
        }
        .message-box {
            background-color: #fefcbf;
            border: 1px solid #fbd38d;
            color: #92400e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
            text-align: center;
        }
        .error-message {
            background-color: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .optimization-results {
            background-color: #e0f2fe;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #90cdf4;
            margin-top: 20px;
        }
        .optimization-results h3 {
            color: #2b6cb0;
        }


        /* Responsive adjustments */
        @media (min-width: 768px) {
            .input-section {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-end;
            }
            .input-group {
                flex: 1;
                max-width: 48%; /* Adjust for spacing */
            }
        }
        @media (max-width: 767px) {
            .input-section {
                flex-direction: column;
                align-items: stretch;
            }
            .input-group {
                width: 100%;
            }
            .input-group input {
                width: 100%;
            }
            .btn-primary {
                width: 100%;
            }
            .optimization-inputs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">USD/Bitcoin Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses **real historical USD/Bitcoin price data from the provided GitHub CSV file** and applies a Moving Average Crossover strategy to identify potential buy and sell signals.
            You can adjust the periods for the short and long moving averages.
        </p>

        <div class="input-section flex flex-col md:flex-row gap-4 mb-6">
            <div class="input-group">
                <label for="shortMA">Short MA Period (e.g., 10):</label>
                <input type="number" id="shortMA" value="10" min="2" max="50">
            </div>
            <div class="input-group">
                <label for="longMA">Long MA Period (e.g., 30):</label>
                <input type="number" id="longMA" value="30" min="3" max="100">
            </div>
            <button id="runSimulationBtn" class="btn-primary mt-auto">Run Simulation</button>
        </div>

        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Strategy Optimization Tool</h2>
            <p class="text-gray-600 text-center mb-6">
                Find the optimum Short and Long Moving Average periods that would have maximized profit
                over the historical data.
            </p>
            <div class="optimization-inputs flex flex-col md:flex-row gap-4 mb-6">
                <div class="input-group">
                    <label for="minShortMA">Min Short MA:</label>
                    <input type="number" id="minShortMA" value="5" min="2" max="40">
                </div>
                <div class="input-group">
                    <label for="maxShortMA">Max Short MA:</label>
                    <input type="number" id="maxShortMA" value="20" min="5" max="50">
                </div>
                <div class="input-group">
                    <label for="minLongMA">Min Long MA:</label>
                    <input type="number" id="minLongMA" value="25" min="10" max="80">
                </div>
                <div class="input-group">
                    <label for="maxLongMA">Max Long MA:</label>
                    <input type="number" id="maxLongMA" value="60" min="30" max="100">
                </div>
                <button id="findOptimumBtn" class="btn-primary mt-auto">Find Optimum Strategy</button>
            </div>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden">
                <h3>Optimum Strategy Found:</h3>
                <p id="optimumShortMA"></p>
                <p id="optimumLongMA"></p>
                <p id="optimumProfit"></p>
                <p id="optimumTotalTrades"></p>
                <p id="optimumWinningTrades"></p>
                <p id="optimumLosingTrades"></p>
                <div id="optimizationMessageBox" class="message-box hidden"></div>
            </div>
        </div>


        <div id="loadingSpinner" class="loading-spinner"></div>
        <canvas id="chartCanvas"></canvas>

        <div id="results" class="results-box hidden">
            <h3>Current Simulation Results:</h3>
            <p id="totalTrades"></p>
            <p id="winningTrades"></p>
            <p id="losingTrades"></p>
            <p id="simulatedProfit"></p>
            <div id="messageBox" class="message-box hidden"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const chartCanvas = document.getElementById('chartCanvas');
            const ctx = chartCanvas.getContext('2d');
            const shortMAPeriodInput = document.getElementById('shortMA');
            const longMAPeriodInput = document.getElementById('longMA');
            const runSimulationBtn = document.getElementById('runSimulationBtn');
            const resultsDiv = document.getElementById('results');
            const totalTradesSpan = document.getElementById('totalTrades');
            const winningTradesSpan = document.getElementById('winningTrades');
            const losingTradesSpan = document.getElementById('losingTrades');
            const simulatedProfitSpan = document.getElementById('simulatedProfit');
            const messageBox = document.getElementById('messageBox');
            const loadingSpinner = document.getElementById('loadingSpinner');

            // Optimization elements
            const minShortMAInput = document.getElementById('minShortMA');
            const maxShortMAInput = document.getElementById('maxShortMA');
            const minLongMAInput = document.getElementById('minLongMA');
            const maxLongMAInput = document.getElementById('maxLongMA'); // Corrected from minLongMAInput
            const findOptimumBtn = document.getElementById('findOptimumBtn');
            const optimizationSpinner = document.getElementById('optimizationSpinner');
            const optimizationResultsDiv = document.getElementById('optimizationResults');
            const optimumShortMASpan = document.getElementById('optimumShortMA');
            const optimumLongMASpan = document.getElementById('optimumLongMA');
            const optimumProfitSpan = document.getElementById('optimumProfit');
            const optimumTotalTradesSpan = document.getElementById('optimumTotalTrades');
            const optimumWinningTradesSpan = document.getElementById('optimumWinningTrades');
            const optimumLosingTradesSpan = document.getElementById('optimumLosingTrades');
            const optimizationMessageBox = document.getElementById('optimizationMessageBox');


            let historicalPrices = [];

            // Set canvas dimensions
            const CHART_HEIGHT = 400;
            let CHART_WIDTH = chartCanvas.offsetWidth;
            chartCanvas.height = CHART_HEIGHT;
            chartCanvas.width = CHART_WIDTH;

            // Adjust canvas width on window resize for responsiveness
            window.addEventListener('resize', () => {
                chartCanvas.width = chartCanvas.offsetWidth;
                CHART_WIDTH = chartCanvas.offsetWidth;
                runSimulation();
            });

            // --- Message Box Functions ---
            function showMessageBox(message, type = 'info', targetBox = messageBox) {
                targetBox.textContent = message;
                targetBox.classList.remove('hidden', 'message-box', 'error-message');
                targetBox.classList.add('message-box');

                if (type === 'error') {
                    targetBox.classList.add('error-message');
                } else {
                    targetBox.classList.remove('error-message');
                }
                targetBox.classList.remove('hidden');
            }

            function hideMessageBox(targetBox = messageBox) {
                targetBox.classList.add('hidden');
            }

            // --- CSV Data Fetching and Parsing ---
            async function fetchCSV(filePath) {
                loadingSpinner.style.display = 'block';
                showMessageBox('Loading historical data...', 'info');
                try {
                    console.log('Attempting to fetch data from:', filePath); // Log the URL
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        // Log full error response for debugging
                        console.error('Fetch response not OK:', response.status, response.statusText);
                        if (response.type === 'opaque') {
                             throw new Error('CORS Error: Cannot directly load data from this external URL due to browser security policies. Please use a local file or a proxy server.');
                        }
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }
                    const csvText = await response.text();
                    console.log('CSV data fetched successfully.'); // Confirm fetch success
                    return parseCSV(csvText);
                } catch (error) {
                    console.error('Error fetching or parsing CSV:', error);
                    showMessageBox(`Failed to load data: ${error.message}. Please check console for details.`, 'error');
                    return [];
                } finally {
                    loadingSpinner.style.display = 'none';
                }
            }

            function parseCSV(csvText) {
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    showMessageBox('CSV file is empty or has no data rows.', 'error');
                    return [];
                }

                const rawHeaders = lines[0].split(';');
                const headers = rawHeaders.map(h => h.trim().replace(/"/g, ''));

                const closePriceIndex = headers.indexOf('close');
                const dateIndex = headers.indexOf('timeClose');

                if (closePriceIndex === -1) {
                    showMessageBox('CSV missing "close" price column. Please check column headers (expected: "close").', 'error');
                    return [];
                }
                 if (dateIndex === -1) {
                    showMessageBox('CSV missing "timeClose" column. Chart x-axis labels might be less informative (expected: "timeClose").', 'info');
                }

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const columns = lines[i].split(';');
                    const closePrice = parseFloat(columns[closePriceIndex]);
                    const date = columns[dateIndex] ? columns[dateIndex].replace(/"/g, '') : '';

                    if (!isNaN(closePrice)) {
                        data.push({
                            price: closePrice,
                            date: date
                        });
                    }
                }
                console.log('CSV parsed. Number of data points:', data.length); // Confirm data parsing
                return data.reverse();
            }

            // --- Technical Analysis Functions ---
            function calculateSMA(data, period) {
                if (period <= 0 || period > data.length) {
                    return Array(data.length).fill(null);
                }
                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val.price, 0);
                        sma.push(sum / period);
                    }
                }
                return sma;
            }

            function calculateStrategyPerformance(pricesData, shortPeriod, longPeriod) {
                const shortMA = calculateSMA(pricesData, shortPeriod);
                const longMA = calculateSMA(pricesData, longPeriod);

                if (shortMA.includes(null) || longMA.includes(null) || shortMA.length === 0 || longMA.length === 0) {
                    return { totalProfitLoss: 0, tradesCount: 0, winningTrades: 0, losingTrades: 0, signals: [] };
                }

                const signals = [];
                let totalProfitLoss = 0;
                let tradesCount = 0;
                let winningTrades = 0;
                let losingTrades = 0;
                let currentTradeEntryPrice = null;
                let inPosition = false;

                for (let i = 1; i < pricesData.length; i++) {
                    const currentPrice = pricesData[i].price;

                    if (shortMA[i] !== null && longMA[i] !== null && shortMA[i - 1] !== null && longMA[i - 1] !== null) {
                        // Buy Signal: Short MA crosses above Long MA
                        if (shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i]) {
                            if (!inPosition) {
                                signals.push({ index: i, type: 'buy', price: currentPrice });
                                inPosition = true;
                                currentTradeEntryPrice = currentPrice;
                            }
                        }
                        // Sell Signal: Short MA crosses below Long MA
                        else if (shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i]) {
                            if (inPosition) {
                                signals.push({ index: i, type: 'sell', price: currentPrice, entryPrice: currentTradeEntryPrice });
                                tradesCount++;
                                const profitLoss = currentPrice - currentTradeEntryPrice;
                                totalProfitLoss += profitLoss;

                                if (profitLoss > 0) {
                                    winningTrades++;
                                } else if (profitLoss < 0) {
                                    losingTrades++;
                                }
                                inPosition = false;
                                currentTradeEntryPrice = 0;
                            }
                        }
                    }
                }

                if (inPosition && currentTradeEntryPrice !== null) {
                    tradesCount++;
                    const lastPrice = pricesData[pricesData.length - 1].price;
                    const profitLoss = lastPrice - currentTradeEntryPrice;
                    totalProfitLoss += profitLoss;
                    if (profitLoss > 0) {
                        winningTrades++;
                    } else if (profitLoss < 0) {
                        losingTrades++;
                    }
                }

                return { totalProfitLoss, tradesCount, winningTrades, losingTrades, signals };
            }

            // --- Charting Functions ---
            function drawChart(pricesData, shortMA, longMA, signals) {
                ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                const prices = pricesData.map(d => d.price);

                const allValues = [...prices, ...shortMA.filter(v => v !== null), ...longMA.filter(v => v !== null)];
                const minPrice = Math.min(...allValues);
                const maxPrice = Math.max(...allValues);
                const priceRange = maxPrice - minPrice;

                if (priceRange === 0) {
                    showMessageBox('Price range is zero. Cannot draw chart.', 'error');
                    return;
                }

                const xScale = chartCanvas.width / (prices.length - 1);
                const yScale = chartCanvas.height / priceRange;

                const getY = (price) => chartCanvas.height - ((price - minPrice) * yScale);
                const getX = (index) => index * xScale;

                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Inter';
                ctx.fillText(`$${maxPrice.toFixed(2)}`, 5, 15);
                ctx.fillText(`$${minPrice.toFixed(2)}`, 5, chartCanvas.height - 5);
                if (pricesData.length > 0) {
                    const startDate = new Date(pricesData[0].date);
                    ctx.fillText(startDate.toLocaleDateString(), 5, chartCanvas.height - 5);
                    const endDate = new Date(pricesData[pricesData.length - 1].date);
                    ctx.fillText(endDate.toLocaleDateString(), chartCanvas.width - ctx.measureText(endDate.toLocaleDateString()).width - 5, chartCanvas.height - 5);
                }

                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                prices.forEach((price, i) => {
                    if (i === 0) {
                        ctx.moveTo(getX(i), getY(price));
                    } else {
                        ctx.lineTo(getX(i), getY(price));
                    }
                });
                ctx.stroke();

                ctx.beginPath();
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1.5;
                shortMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (shortMA[i - 1] === null) {
                             ctx.moveTo(getX(i), getY(ma));
                        } else {
                             ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                ctx.beginPath();
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 1.5;
                longMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (longMA[i - 1] === null) {
                            ctx.moveTo(getX(i), getY(ma));
                        } else {
                            ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                signals.forEach(signal => {
                    ctx.beginPath();
                    const x = getX(signal.index);
                    const y = getY(prices[signal.index]);

                    if (signal.type === 'buy') {
                        ctx.fillStyle = '#22c55e';
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                    } else {
                        ctx.fillStyle = '#ef4444';
                        ctx.rect(x - 6, y - 6, 12, 12);
                    }
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.font = '10px Inter';
                    ctx.fillText(signal.type.toUpperCase(), x + 8, y - 8);
                });
            }

            // --- Main Simulation Logic (for manual input) ---
            function runSimulation() {
                hideMessageBox();

                const shortPeriod = parseInt(shortMAPeriodInput.value);
                const longPeriod = parseInt(longMAPeriodInput.value);

                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded. Please ensure data is available.', 'error');
                    resultsDiv.classList.add('hidden');
                    return;
                }

                if (isNaN(shortPeriod) || isNaN(longPeriod) || shortPeriod <= 0 || longPeriod <= 0) {
                    showMessageBox('Please enter valid positive numbers for MA periods.', 'error');
                    resultsDiv.classList.add('hidden');
                    return;
                }
                if (shortPeriod >= longPeriod) {
                    showMessageBox('Short MA period must be less than Long MA period.', 'error');
                    resultsDiv.classList.add('hidden');
                    return;
                }
                if (longPeriod > historicalPrices.length) {
                     showMessageBox(`Long MA period (${longPeriod}) cannot be greater than the number of available data points (${historicalPrices.length}).`, 'error');
                     resultsDiv.classList.add('hidden');
                     return;
                }

                const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);
                const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                const longMAValues = calculateSMA(historicalPrices, longPeriod);

                resultsDiv.classList.remove('hidden');
                totalTradesSpan.textContent = `Total completed trades: ${performance.tradesCount}`;
                winningTradesSpan.textContent = `Winning trades: ${performance.winningTrades}`;
                losingTradesSpan.textContent = `Losing trades: ${performance.losingTrades}`;
                simulatedProfitSpan.textContent = `Simulated Profit/Loss: $${performance.totalProfitLoss.toFixed(2)} USD (for 1 unit of Bitcoin traded)`;
                simulatedProfitSpan.style.color = performance.totalProfitLoss >= 0 ? '#10b981' : '#ef4444';

                chartCanvas.width = chartCanvas.offsetWidth;
                drawChart(historicalPrices, shortMAValues, longMAValues, performance.signals);
            }

            // --- Optimization Logic ---
            async function findOptimumStrategy() {
                hideMessageBox(optimizationMessageBox);
                optimizationResultsDiv.classList.add('hidden');

                const minShort = parseInt(minShortMAInput.value);
                const maxShort = parseInt(maxShortMAInput.value);
                const minLong = parseInt(minLongMAInput.value);
                const maxLong = parseInt(maxLongMAInput.value); // Corrected typo here

                if (isNaN(minShort) || isNaN(maxShort) || isNaN(minLong) || isNaN(maxLong) ||
                    minShort <= 0 || maxShort <= 0 || minLong <= 0 || maxLong <= 0) {
                    showMessageBox('Please enter valid positive numbers for all optimization ranges.', 'error', optimizationMessageBox);
                    return;
                }
                if (minShort >= maxShort || minLong >= maxLong || maxShort >= minLong) {
                    showMessageBox('Optimization ranges are invalid. Ensure Min < Max for each, and Max Short < Min Long.', 'error', optimizationMessageBox);
                    return;
                }
                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded for optimization. Please ensure data is available.', 'error', optimizationMessageBox);
                    return;
                }
                if (maxLong > historicalPrices.length) {
                    showMessageBox(`Max Long MA (${maxLong}) cannot be greater than the number of data points (${historicalPrices.length}). Adjust range.`, 'error', optimizationMessageBox);
                    return;
                }

                optimizationSpinner.style.display = 'block';
                showMessageBox('Searching for optimum strategy...', 'info', optimizationMessageBox);

                let bestProfit = -Infinity;
                let bestShortMA = 0;
                let bestLongMA = 0;
                let bestPerformance = null;

                for (let shortPeriod = minShort; shortPeriod <= maxShort; shortPeriod++) {
                    for (let longPeriod = minLong; longPeriod <= maxLong; longPeriod++) {
                        if (shortPeriod >= longPeriod) {
                            continue;
                        }
                        if (longPeriod > historicalPrices.length) {
                            continue;
                        }

                        const currentPerformance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);

                        if (currentPerformance.totalProfitLoss > bestProfit) {
                            bestProfit = currentPerformance.totalProfitLoss;
                            bestShortMA = shortPeriod;
                            bestLongMA = longPeriod;
                            bestPerformance = currentPerformance;
                        }
                    }
                }

                optimizationSpinner.style.display = 'none';
                optimizationResultsDiv.classList.remove('hidden');

                optimumShortMASpan.textContent = `Optimum Short MA Period: ${bestShortMA}`;
                optimumLongMASpan.textContent = `Optimum Long MA Period: ${bestLongMA}`;
                optimumProfitSpan.textContent = `Maximum Simulated Profit: $${bestProfit.toFixed(2)} USD`;
                optimumProfitSpan.style.color = bestProfit >= 0 ? '#10b981' : '#ef4444';

                if (bestPerformance) {
                    optimumTotalTradesSpan.textContent = `Total completed trades: ${bestPerformance.tradesCount}`;
                    optimumWinningTradesSpan.textContent = `Winning trades: ${bestPerformance.winningTrades}`;
                    optimumLosingTradesSpan.textContent = `Losing trades: ${bestPerformance.losingTrades}`;
                } else {
                    optimumTotalTradesSpan.textContent = `Total completed trades: 0`;
                    optimumWinningTradesSpan.textContent = `Winning trades: 0`;
                    optimumLosingTradesSpan.textContent = `Losing trades: 0`;
                }

                if (bestProfit <= 0 && bestPerformance && bestPerformance.tradesCount > 0) {
                     showMessageBox(`Optimization complete. While trades were made, no net positive profit strategy was found within the tested ranges for this historical data. The displayed strategy represents the best outcome (least loss or break-even).`, 'info', optimizationMessageBox);
                } else if (bestProfit <= 0 && bestPerformance && bestPerformance.tradesCount === 0) {
                     showMessageBox(`Optimization complete. No trades were made with any strategy within the tested ranges. This typically means the MA periods are too large or the price action was too flat for crossovers.`, 'info', optimizationMessageBox);
                }
                else {
                    showMessageBox('Optimization complete. Best strategy found!', 'info', optimizationMessageBox);
                }

                shortMAPeriodInput.value = bestShortMA;
                longMAPeriodInput.value = bestLongMA;
                runSimulation();
            }

            const csvFilePath = 'https://raw.githubusercontent.com/AmbiguousError/btc/refs/heads/main/BTC.csv';

            historicalPrices = await fetchCSV(csvFilePath);

            runSimulationBtn.addEventListener('click', runSimulation);
            findOptimumBtn.addEventListener('click', findOptimumStrategy);

            if (historicalPrices.length > 0) {
                runSimulation();
            }
        });
    </script>
</body>
</html>
