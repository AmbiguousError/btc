<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 3.6 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USD Trading Opportunity Identifier with RSI and Optimization</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%;
            height: auto;
        }
        #currentChartCanvas, #optimumChartCanvas, #comprehensiveOptimumChartCanvas, #rsiFilteredChartCanvas {
            aspect-ratio: 16 / 9;
             max-height: 450px;
        }
        #rsiChartCanvas, #rsiFilteredRsiChartCanvas {
            aspect-ratio: 16 / 5;
            max-height: 150px;
        }
        .input-group { display: flex; flex-direction: column; gap: 8px; }
        .input-group label, .checkbox-group label { font-weight: 600; color: #4a5568; }
        .input-group input[type="number"], .input-group input[type="date"] {
            padding: 10px; border: 1px solid #cbd5e0; border-radius: 8px; font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus { outline: none; border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .btn-primary {
            background-color: #6366f1; color: white; padding: 12px 20px; border-radius: 8px; font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out; cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover { background-color: #4f46e5; transform: translateY(-1px); }
        .results-box { background-color: #edf2f7; border-radius: 10px; padding: 20px; border: 1px solid #d1d5db; }
        .explanation-box { background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; }
        .explanation-box h3, .results-box h3, .optimization-results h3 { font-size: 1.15rem; font-weight: 700; margin-bottom: 10px; color: #2d3748; }
        .explanation-box p, .results-box p, .optimization-results p { font-size: 0.95rem; line-height: 1.6; color: #4a5568; }
        .message-box { background-color: #fefcbf; border: 1px solid #fbd38d; color: #92400e; padding: 15px; border-radius: 8px; margin-top: 15px; font-weight: 500; text-align: center; }
        .error-message { background-color: #fed7d7; border-color: #fc8181; color: #c53030; }
        .warning-message { background-color: #ffe8d1; border: 1px solid #ffcc80; color: #a0522d; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid #6366f1; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 0 auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hover-info-box { background-color: #1a202c; color: #fff; padding: 8px 12px; border-radius: 5px; font-size: 0.875rem; position: absolute; z-index: 10; pointer-events: none; white-space: nowrap; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none; }
        .chart-section { border: 1px solid #e2e8f0; border-radius: 15px; padding: 20px; background-color: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .optimization-results { background-color: #e0f2fe; border-radius: 10px; padding: 20px; border: 1px solid #90cdf4; margin-top: 20px; }
        .data-preview-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.85rem; text-align: left; }
        .data-preview-table th, .data-preview-table td { border: 1px solid #e2e8f0; padding: 8px 12px; }
        .data-preview-table th { background-color: #e9eef4; font-weight: 600; color: #4a5568; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">BTC/USD Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses historical BTC/USD data, a Moving Average Crossover strategy, and an optional RSI filter to find and optimize trading signals.
        </p>

        <div class="explanation-box">
            <h3>How Signals Are Calculated</h3>
            <p><strong>1. Moving Average (MA) Crossover Strategy:</strong> The core signals are generated when a short-term MA crosses a long-term MA.</p>
            <ul>
                <li><strong>Buy (Golden Cross):</strong> Short MA crosses *above* Long MA.</li>
                <li><strong>Sell (Death Cross):</strong> Short MA crosses *below* Long MA.</li>
            </ul>
            <p class="mt-4"><strong>2. Optional RSI Filter:</strong> The RSI (0-100) measures momentum. If enabled, it filters MA signals:</p>
            <ul>
                <li>A **Buy** signal is only valid if RSI is **below** the overbought level (e.g., 70).</li>
                <li>A **Sell** signal is only valid if RSI is **above** the oversold level (e.g., 30).</li>
            </ul>
        </div>
        
        <div class="date-range-section grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div class="input-group"><label for="startDate">Start Date:</label><input type="date" id="startDate"></div>
            <div class="input-group"><label for="endDate">End Date:</label><input type="date" id="endDate"></div>
        </div>

        <div class="border-t border-gray-200 pt-6">
             <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Strategy Parameters</h2>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="input-group"><label for="initialInvestment">Initial Investment ($):</label><input type="number" id="initialInvestment" value="100" min="1"></div>
                <div class="input-group"><label for="taxRate">Tax Rate (%):</label><input type="number" id="taxRate" value="28" min="0" max="100"></div>
                <div class="input-group"><label for="serviceFee">Service Fee (%):</label><input type="number" id="serviceFee" value="0.1" min="0" max="10" step="0.1"></div>
                <div class="input-group"><label for="shortMA">Short MA Period:</label><input type="number" id="shortMA" value="2" min="2"></div>
                <div class="input-group"><label for="longMA">Long MA Period:</label><input type="number" id="longMA" value="5" min="3"></div>
                <div class="input-group"><label for="rsiPeriod">RSI Period:</label><input type="number" id="rsiPeriod" value="14" min="2"></div>
                <div class="input-group"><label for="rsiOverbought">RSI Overbought:</label><input type="number" id="rsiOverbought" value="70" min="51"></div>
                <div class="input-group"><label for="rsiOversold">RSI Oversold:</label><input type="number" id="rsiOversold" value="30" max="49"></div>
                <div class="checkbox-group mt-4 col-span-2 md:col-span-4">
                    <input type="checkbox" id="useRsiFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useRsiFilter">Use RSI to Filter Signals</label>
                </div>
            </div>
            <button id="runSimulationBtn" class="btn-primary w-full mt-6">Run Simulation</button>
        </div>

        <div id="dataPreviewSection" class="results-box hidden">
            <h3>Data Preview for Selected Range:</h3>
            <table class="data-preview-table"><tbody id="dataPreviewTableBody"></tbody></table>
        </div>
        
        <div id="currentSimulationSection" class="chart-section mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Current Strategy Simulation</h2>
            <div id="loadingSpinner" class="loading-spinner"></div>
            <canvas id="currentChartCanvas"></canvas>
            <canvas id="rsiChartCanvas" class="mt-4"></canvas>
            <div id="hoverInfoBox" class="hover-info-box"></div>
            <div id="currentSimulationResults" class="results-box hidden mt-4"></div>
        </div>

        <div id="rsiFilteredSimulationSection" class="chart-section mt-6 border-t-4 border-indigo-300 pt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">RSI-Filtered Strategy Simulation</h2>
             <p class="text-gray-600 text-center mb-6">This is a copy of the simulation above, but with the RSI filter forcibly enabled to show how it avoids signals in overbought/oversold zones.</p>
            <canvas id="rsiFilteredChartCanvas"></canvas>
            <canvas id="rsiFilteredRsiChartCanvas" class="mt-4"></canvas>
            <div id="rsiFilteredHoverInfoBox" class="hover-info-box"></div>
            <div id="rsiFilteredSimulationResults" class="results-box hidden mt-4"></div>
        </div>

        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Manual Strategy Optimization</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="input-group"><label for="minShortMA">Min Short MA:</label><input type="number" id="minShortMA" value="2"></div>
                <div class="input-group"><label for="maxShortMA">Max Short MA:</label><input type="number" id="maxShortMA" value="10"></div>
                <div class="input-group"><label for="minLongMA">Min Long MA:</label><input type="number" id="minLongMA" value="11"></div>
                <div class="input-group"><label for="maxLongMA">Max Long MA:</label><input type="number" id="maxLongMA" value="30"></div>
            </div>
            <button id="findOptimumBtn" class="btn-primary w-full mt-6">Find Optimum Strategy</button>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden mt-4"></div>
            <div id="optimumStrategyChartSection" class="chart-section mt-4 hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-2 text-center">Optimum Strategy Chart</h3>
                <canvas id="optimumChartCanvas"></canvas>
                <div id="optimumHoverInfoBox" class="hover-info-box"></div>
            </div>
        </div>

        <div class="comprehensive-optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Comprehensive Strategy Optimization</h2>
            <p class="text-gray-600 text-center mb-6">Tests all Short MA periods from 2-30 against all longer MA periods up to 100.</p>
            <button id="findComprehensiveOptimumBtn" class="btn-primary w-full">Find Comprehensive Optimum Strategy</button>
            <div id="comprehensiveOptimizationSpinner" class="loading-spinner"></div>
            <div id="comprehensiveOptimizationResults" class="optimization-results hidden mt-4"></div>
            <div id="comprehensiveOptimumStrategyChartSection" class="chart-section mt-4 hidden">
                 <h3 class="text-xl font-bold text-gray-800 mb-2 text-center">Comprehensive Optimum Strategy Chart</h3>
                <canvas id="comprehensiveOptimumChartCanvas"></canvas>
                <div id="comprehensiveOptimumHoverInfoBox" class="hover-info-box"></div>
                <div id="comprehensiveTradesTableContainer" class="mt-4 hidden">
                    <h4 class="text-lg font-bold text-gray-700 mb-2">Trade Log:</h4>
                    <div class="overflow-x-auto">
                        <table class="data-preview-table w-full">
                            <thead>
                                <tr>
                                    <th>Buy Date</th><th>BTC Bought</th><th>Sell Date</th><th>Gross P/L</th><th>Tax Paid</th><th>Net P/L</th>
                                </tr>
                            </thead>
                            <tbody id="comprehensiveTradesTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    // --- Global Variables ---
    let historicalPrices = [];
    let filteredPrices = [];
    let currentStrategyData = null;
    let rsiFilteredStrategyData = null;
    let optimumStrategyData = null;
    let comprehensiveStrategyData = null;

    // --- DOM Element Cache ---
    const elements = {
        // Canvases
        currentChartCanvas: document.getElementById('currentChartCanvas'),
        rsiChartCanvas: document.getElementById('rsiChartCanvas'),
        rsiFilteredChartCanvas: document.getElementById('rsiFilteredChartCanvas'),
        rsiFilteredRsiChartCanvas: document.getElementById('rsiFilteredRsiChartCanvas'),
        optimumChartCanvas: document.getElementById('optimumChartCanvas'),
        comprehensiveOptimumChartCanvas: document.getElementById('comprehensiveOptimumChartCanvas'),
        // Inputs
        startDate: document.getElementById('startDate'),
        endDate: document.getElementById('endDate'),
        initialInvestment: document.getElementById('initialInvestment'),
        taxRate: document.getElementById('taxRate'),
        serviceFee: document.getElementById('serviceFee'),
        shortMA: document.getElementById('shortMA'),
        longMA: document.getElementById('longMA'),
        rsiPeriod: document.getElementById('rsiPeriod'),
        rsiOverbought: document.getElementById('rsiOverbought'),
        rsiOversold: document.getElementById('rsiOversold'),
        useRsiFilter: document.getElementById('useRsiFilter'),
        minShortMA: document.getElementById('minShortMA'),
        maxShortMA: document.getElementById('maxShortMA'),
        minLongMA: document.getElementById('minLongMA'),
        maxLongMA: document.getElementById('maxLongMA'),
        // Buttons
        runSimulationBtn: document.getElementById('runSimulationBtn'),
        findOptimumBtn: document.getElementById('findOptimumBtn'),
        findComprehensiveOptimumBtn: document.getElementById('findComprehensiveOptimumBtn'),
        // Spinners
        loadingSpinner: document.getElementById('loadingSpinner'),
        optimizationSpinner: document.getElementById('optimizationSpinner'),
        comprehensiveOptimizationSpinner: document.getElementById('comprehensiveOptimizationSpinner'),
        // Results & Info
        dataPreviewSection: document.getElementById('dataPreviewSection'),
        dataPreviewTableBody: document.getElementById('dataPreviewTableBody'),
        currentSimulationResults: document.getElementById('currentSimulationResults'),
        rsiFilteredSimulationResults: document.getElementById('rsiFilteredSimulationResults'),
        optimizationResults: document.getElementById('optimizationResults'),
        comprehensiveOptimizationResults: document.getElementById('comprehensiveOptimizationResults'),
        currentSimulationSection: document.getElementById('currentSimulationSection'),
        rsiFilteredSimulationSection: document.getElementById('rsiFilteredSimulationSection'),
        optimumStrategyChartSection: document.getElementById('optimumStrategyChartSection'),
        comprehensiveOptimumStrategyChartSection: document.getElementById('comprehensiveOptimumStrategyChartSection'),
        comprehensiveTradesTableContainer: document.getElementById('comprehensiveTradesTableContainer'),
        comprehensiveTradesTableBody: document.getElementById('comprehensiveTradesTableBody'),
        // Hover Boxes
        hoverInfoBox: document.getElementById('hoverInfoBox'),
        rsiFilteredHoverInfoBox: document.getElementById('rsiFilteredHoverInfoBox'),
        optimumHoverInfoBox: document.getElementById('optimumHoverInfoBox'),
        comprehensiveHoverInfoBox: document.getElementById('comprehensiveOptimumHoverInfoBox')
    };

    // --- Message/UI Helpers ---
    const showSpinner = spinner => spinner.style.display = 'block';
    const hideSpinner = spinner => spinner.style.display = 'none';
    
    function showResults(container, content) {
        container.innerHTML = content;
        container.classList.remove('hidden');
    }
    
    // --- Data Handling ---
    async function fetchCSV(filePath) {
        showSpinner(elements.loadingSpinner);
        try {
            const response = await fetch(filePath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const csvText = await response.text();
            return parseCSV(csvText);
        } catch (error) {
            showResults(elements.currentSimulationResults, `<div class="error-message">Failed to load data: ${error.message}.</div>`);
            return [];
        } finally {
            hideSpinner(elements.loadingSpinner);
        }
    }

    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        const closePriceIndex = headers.indexOf('price');
        const dateIndex = headers.indexOf('snapped_at');
        if (closePriceIndex === -1 || dateIndex === -1) throw new Error('CSV missing "price" or "snapped_at" column.');
        
        return lines.slice(1).map(line => {
            const cols = line.split(',');
            const price = parseFloat(cols[closePriceIndex]);
            const date = cols[dateIndex]?.replace(/"/g, '').replace(' UTC', '');
            return !isNaN(price) && date ? { price, date } : null;
        }).filter(Boolean);
    }
    
    function filterDataByDateRange(data, startDate, endDate) {
        const start = startDate ? new Date(startDate).getTime() : -Infinity;
        const end = endDate ? new Date(endDate).getTime() : Infinity;
        return data.filter(p => {
            const pointDate = new Date(p.date).getTime();
            return pointDate >= start && pointDate <= end;
        });
    }

    function updateDataPreviewTable(data) {
        elements.dataPreviewTableBody.innerHTML = '';
        if (data.length === 0) {
            elements.dataPreviewSection.classList.add('hidden');
            return;
        }
        const previewData = [...data.slice(0, 5)];
        if (data.length > 10) {
            previewData.push(null);
            previewData.push(...data.slice(data.length - 5));
        } else if (data.length > 5) {
            previewData.push(...data.slice(5));
        }

        previewData.forEach(rowData => {
            const row = elements.dataPreviewTableBody.insertRow();
            if (rowData === null) {
                const cell = row.insertCell();
                cell.colSpan = 2;
                cell.textContent = '...';
                cell.style.textAlign = 'center';
            } else {
                row.insertCell().textContent = new Date(rowData.date).toLocaleDateString();
                row.insertCell().textContent = `$${rowData.price.toFixed(2)}`;
            }
        });
        elements.dataPreviewSection.classList.remove('hidden');
    }

    // --- Technical Analysis Calculations ---
    const calculateSMA = (data, period) => {
        const sma = Array(data.length).fill(null);
        for (let i = period - 1; i < data.length; i++) {
            sma[i] = data.slice(i - period + 1, i + 1).reduce((sum, d) => sum + d.price, 0) / period;
        }
        return sma;
    };
    
    const calculateRSI = (data, period) => {
        const rsi = Array(data.length).fill(null);
        if (period >= data.length) return rsi;
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const change = data[i].price - data[i - 1].price;
            change > 0 ? gains += change : losses -= change;
        }
        let avgGain = gains / period, avgLoss = losses / period;
        rsi[period] = 100 - (100 / (1 + (avgGain / avgLoss)));

        for (let i = period + 1; i < data.length; i++) {
            const change = data[i].price - data[i - 1].price;
            avgGain = (avgGain * (period - 1) + (change > 0 ? change : 0)) / period;
            avgLoss = (avgLoss * (period - 1) + (change < 0 ? -change : 0)) / period;
            rsi[i] = 100 - (100 / (1 + (avgLoss === 0 ? Infinity : avgGain / avgLoss)));
        }
        return rsi;
    };

    function calculateStrategyPerformance(prices, shortMA, longMA, rsi, settings) {
        let cash = settings.initialInvestment;
        let btc = 0;
        let signals = [];
        const taxRate = settings.taxRate / 100;
        const serviceFee = settings.serviceFee / 100;

        for (let i = 1; i < prices.length; i++) {
            const price = prices[i].price;
            const goldenCross = shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i];
            const deathCross = shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i];

            if (goldenCross && cash > 0 && (!settings.useRsiFilter || rsi[i] < settings.rsiOverbought)) {
                const cashToInvest = cash;
                const fee = cashToInvest * serviceFee;
                const netCashForBtc = cashToInvest - fee;
                
                btc = netCashForBtc / price;
                cash = 0;
                signals.push({ index: i, type: 'buy', price, btc, cost: cashToInvest });
            } else if (deathCross && btc > 0 && (!settings.useRsiFilter || rsi[i] > settings.rsiOversold)) {
                const grossSellValue = btc * price;
                const fee = grossSellValue * serviceFee;
                const netSellValue = grossSellValue - fee;

                const buySignal = signals.filter(s => s.type === 'buy').pop();
                const buyCost = buySignal.cost;
                
                const grossProfit = netSellValue - buyCost;
                const tax = grossProfit > 0 ? grossProfit * taxRate : 0;
                const netProfit = grossProfit - tax;

                cash = netSellValue - tax;
                btc = 0;
                signals.push({ index: i, type: 'sell', price, btc: 0, cashValue: cash, grossProfit, tax, netProfit });
            }
        }
        
        const finalValue = btc > 0 ? (btc * prices[prices.length - 1].price) * (1 - serviceFee) : cash;
        return { signals, finalValue };
    }


    // --- Charting ---
    function setupCanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        return { ctx, width: rect.width, height: rect.height };
    }

    function drawChart(canvas, pricesData, shortMA, longMA, signals, hoverInfo) {
        const { ctx, width, height } = setupCanvas(canvas);
        ctx.clearRect(0, 0, width, height);

        const prices = pricesData.map(d => d.price);
        const allValues = [...prices, ...shortMA, ...longMA].filter(v => v !== null);
        if (allValues.length === 0) return;
        
        let min = Math.min(...allValues), max = Math.max(...allValues);
        const padding = (max - min) * 0.1;
        min -= padding; max += padding;

        const xScale = width / (prices.length -1 || 1);
        const yScale = height / (max - min || 1);
        const getX = i => i * xScale;
        const getY = price => height - ((price - min) * yScale);
        
        drawChartDetails(ctx, width, height, min, max, getX, pricesData);

        const createPoints = (data, yFunc) => data.map((d, i) => d === null ? null : {x: getX(i), y: yFunc(d)});
        drawDataLine(ctx, createPoints(prices, getY), '#3b82f6', 2);
        drawDataLine(ctx, createPoints(shortMA, getY), '#ef4444', 1.5);
        drawDataLine(ctx, createPoints(longMA, getY), '#10b981', 1.5);
        
        signals.forEach(s => {
            const x = getX(s.index), y = getY(s.price);
            ctx.beginPath();
            ctx.fillStyle = s.type === 'buy' ? '#22c55e' : '#ef4444';
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
        });

        if (hoverInfo && hoverInfo.x !== -1) {
            drawCrosshair(ctx, hoverInfo.x, hoverInfo.y, width, height);
            const i = Math.round(hoverInfo.x / xScale);
            if (pricesData[i]) {
                const infoHtml = `<strong>Date:</strong> ${new Date(pricesData[i].date).toLocaleDateString()}<br>
                                  <strong>Price:</strong> $${prices[i].toFixed(2)}<br>
                                  <strong>Short MA:</strong> ${shortMA[i]?.toFixed(2) || 'N/A'}<br>
                                  <strong>Long MA:</strong> ${longMA[i]?.toFixed(2) || 'N/A'}`;
                showHoverBox(hoverInfo.box, infoHtml, hoverInfo.x, hoverInfo.y, canvas);
            }
        } else if (hoverInfo) {
            hideHoverBox(hoverInfo.box);
        }
    }

    function drawChartDetails(ctx, width, height, min, max, getX, pricesData) {
        ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 0.5;
        ctx.font = '10px Inter'; ctx.fillStyle = '#6b7280';

        const numYLabels = 5;
        for (let i = 0; i <= numYLabels; i++) {
            const y = (height / numYLabels) * i;
            const price = max - (i * (height / numYLabels) / height * (max - min));
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            ctx.textAlign = 'right'; ctx.fillText(price.toFixed(2), width - 5, y - 5);
        }
        
        const numXLabels = Math.min(Math.floor(width / 100), pricesData.length);
        if (pricesData.length > 1 && numXLabels > 1) {
            for (let i = 0; i < numXLabels; i++) {
                const index = Math.floor(i * (pricesData.length - 1) / (numXLabels - 1));
                const x = getX(index);
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                ctx.textAlign = 'center'; ctx.fillText(new Date(pricesData[index].date).toLocaleDateString(), x, height - 5);
            }
        }

        const legend = [{c: '#3b82f6', t: 'Price'}, {c: '#ef4444', t: 'Short MA'}, {c: '#10b981', t: 'Long MA'}];
        ctx.textAlign = 'left';
        legend.forEach((item, i) => {
            ctx.fillStyle = item.c;
            ctx.fillRect(10 + i * 90, 10, 15, 2);
            ctx.fillStyle = '#6b7280';
            ctx.fillText(item.t, 30 + i * 90, 12);
        });
    }
    
    function drawRSIChart(ctx, width, height, rsiData, settings, hoverInfo) {
        ctx.clearRect(0, 0, width, height);
        if (rsiData.length === 0) return;

        const xScale = width / (rsiData.length - 1 || 1);
        const yScale = height / 100;
        const getX = i => i * xScale;
        const getY = val => height - (val * yScale);

        ctx.fillStyle = 'rgba(239, 68, 68, 0.05)';
        ctx.fillRect(0, 0, width, getY(settings.rsiOverbought));
        ctx.fillStyle = 'rgba(34, 197, 94, 0.05)';
        ctx.fillRect(0, getY(settings.rsiOversold), width, height);
        
        ctx.font = '10px Inter'; ctx.fillStyle = '#6b7280'; ctx.textAlign = 'right';
        ctx.fillText(settings.rsiOverbought, width - 5, getY(settings.rsiOverbought) + 10);
        ctx.fillText(settings.rsiOversold, width - 5, getY(settings.rsiOversold) - 2);

        drawDataLine(ctx, rsiData.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}), '#4f46e5', 1.5);
        
        if (hoverInfo && hoverInfo.x !== -1) {
            drawCrosshair(ctx, hoverInfo.x, hoverInfo.y, width, height);
            const i = Math.round(hoverInfo.x / xScale);
            if (rsiData[i] !== null) {
                const currentHoverText = hoverInfo.box.innerHTML;
                const rsiText = `<br><strong>RSI:</strong> ${rsiData[i].toFixed(2)}`;
                if (!currentHoverText.includes(rsiText)) {
                     hoverInfo.box.innerHTML += rsiText;
                }
            }
        }
    }
    
    function drawDataLine(ctx, points, color, width) {
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = width;
        let first = true;
        points.forEach(p => {
            if (p !== null) {
                first ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
                first = false;
            } else {
                first = true;
            }
        });
        ctx.stroke();
    }
    
    function drawCrosshair(ctx, x, y, width, height) {
        ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
    }

    function showHoverBox(box, html, x, y, canvas) {
        box.innerHTML = html;
        box.style.display = 'block';
        const rect = canvas.getBoundingClientRect();
        let left = rect.left + window.scrollX + x + 15;
        let top = rect.top + window.scrollY + y - box.offsetHeight / 2;
        if (left + box.offsetWidth > window.innerWidth) left = rect.left + window.scrollX + x - box.offsetWidth - 15;
        box.style.left = `${left}px`;
        box.style.top = `${top}px`;
    }
    const hideHoverBox = box => box.style.display = 'none';

    // --- Simulation & Optimization Logic ---
    function getSettings() {
        return {
            initialInvestment: parseFloat(elements.initialInvestment.value),
            taxRate: parseFloat(elements.taxRate.value),
            serviceFee: parseFloat(elements.serviceFee.value),
            shortPeriod: parseInt(elements.shortMA.value),
            longPeriod: parseInt(elements.longMA.value),
            rsiPeriod: parseInt(elements.rsiPeriod.value),
            rsiOverbought: parseInt(elements.rsiOverbought.value),
            rsiOversold: parseInt(elements.rsiOversold.value),
            useRsiFilter: elements.useRsiFilter.checked,
            startDate: elements.startDate.value,
            endDate: elements.endDate.value,
        };
    }

    function renderPerformanceResults(container, perf, initialInvestment) {
        const netProfit = perf.finalValue - initialInvestment;
        const profitColor = netProfit >= 0 ? 'text-green-600' : 'text-red-600';
        const trades = perf.signals.filter(s => s.type === 'sell');

        showResults(container, `
            <h3>Results:</h3>
            <p>Final Portfolio Value: <span class="font-bold">$${perf.finalValue.toFixed(2)}</span></p>
            <p>Net Profit/Loss: <span class="font-bold ${profitColor}">$${netProfit.toFixed(2)}</span></p>
            <p>Total completed trades: ${trades.length}</p>
        `);
    }
    
    // --- Main Drawing Functions ---
    function drawCurrentCharts(hoverInfo) {
        if (!currentStrategyData) return;
        const { prices, shortMA, longMA, rsi, signals, settings } = currentStrategyData;
        drawChart(elements.currentChartCanvas, prices, shortMA, longMA, signals, hoverInfo);
        const { ctx, width, height } = setupCanvas(elements.rsiChartCanvas);
        drawRSIChart(ctx, width, height, rsi, settings, hoverInfo);
    }

    function drawRsiFilteredCharts(hoverInfo) {
        if (!rsiFilteredStrategyData) return;
        const { prices, shortMA, longMA, rsi, signals, settings } = rsiFilteredStrategyData;
        drawChart(elements.rsiFilteredChartCanvas, prices, shortMA, longMA, signals, hoverInfo);
        const { ctx, width, height } = setupCanvas(elements.rsiFilteredRsiChartCanvas);
        drawRSIChart(ctx, width, height, rsi, settings, hoverInfo);
    }
    
    function runSimulation() {
        const settings = getSettings();
        filteredPrices = filterDataByDateRange(historicalPrices, settings.startDate, settings.endDate);
        updateDataPreviewTable(filteredPrices);
        
        const maxPeriod = Math.max(settings.longPeriod, settings.rsiPeriod);
        if (filteredPrices.length < maxPeriod) {
            showResults(elements.currentSimulationResults, `<div class="warning-message">Not enough data. Need ${maxPeriod}, have ${filteredPrices.length}.</div>`);
            return;
        }

        const shortMA = calculateSMA(filteredPrices, settings.shortPeriod);
        const longMA = calculateSMA(filteredPrices, settings.longPeriod);
        const rsi = calculateRSI(filteredPrices, settings.rsiPeriod);
        
        // Normal simulation data
        const performance = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, settings);
        currentStrategyData = { prices: filteredPrices, shortMA, longMA, rsi, signals: performance.signals, settings };
        renderPerformanceResults(elements.currentSimulationResults, performance, settings.initialInvestment);

        // RSI-Filtered simulation data
        const rsiFilteredSettings = {...settings, useRsiFilter: true};
        const rsiFilteredPerformance = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, rsiFilteredSettings);
        rsiFilteredStrategyData = { prices: filteredPrices, shortMA, longMA, rsi, signals: rsiFilteredPerformance.signals, settings: rsiFilteredSettings };
        renderPerformanceResults(elements.rsiFilteredSimulationResults, rsiFilteredPerformance, settings.initialInvestment);

        // Initial draw without hover
        drawCurrentCharts(null);
        drawRsiFilteredCharts(null);
    }
    
    function findOptimum(isComprehensive = false) {
        const settings = getSettings();
        filteredPrices = filterDataByDateRange(historicalPrices, settings.startDate, settings.endDate);
        const container = isComprehensive ? elements.comprehensiveOptimizationResults : elements.optimizationResults;
        const spinner = isComprehensive ? elements.comprehensiveOptimizationSpinner : elements.optimizationSpinner;
        
        showSpinner(spinner);
        showResults(container, "<h3>Optimizing...</h3><p>This may take a moment.</p>");

        setTimeout(() => {
            let bestPerf = { finalValue: -Infinity }, bestShort = 0, bestLong = 0;
            const rsi = calculateRSI(filteredPrices, settings.rsiPeriod);

            const loopRunner = () => {
                if (isComprehensive) {
                    const maxShortComprehensive = 30;
                    const maxLongComprehensive = 100;
                     if (maxLongComprehensive > filteredPrices.length) {
                        showResults(container, `<div class="warning-message">Not enough data. Need ${maxLongComprehensive}, have ${filteredPrices.length}.</div>`);
                        hideSpinner(spinner);
                        return;
                    }
                    for (let short = 2; short <= maxShortComprehensive; short++) {
                        for (let long = short + 1; long <= maxLongComprehensive; long++) {
                            runTest(short, long);
                        }
                    }
                } else {
                    const minShort = parseInt(elements.minShortMA.value);
                    const maxShort = parseInt(elements.maxShortMA.value);
                    const minLong = parseInt(elements.minLongMA.value);
                    const maxLong = parseInt(elements.maxLongMA.value);
                    if (maxLong > filteredPrices.length) {
                        showResults(container, `<div class="warning-message">Not enough data. Need ${maxLong}, have ${filteredPrices.length}.</div>`);
                        hideSpinner(spinner);
                        return;
                    }
                    for (let short = minShort; short <= maxShort; short++) {
                        for (let long = minLong; long <= maxLong; long++) {
                            if (short >= long) continue;
                            runTest(short, long);
                        }
                    }
                }
            }

            const runTest = (short, long) => {
                const shortMA = calculateSMA(filteredPrices, short);
                const longMA = calculateSMA(filteredPrices, long);
                const perf = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, {...settings, shortPeriod: short, longPeriod: long});
                if (perf.finalValue > bestPerf.finalValue) {
                    bestPerf = perf; bestShort = short; bestLong = long;
                }
            };
            
            loopRunner();

            hideSpinner(spinner);
            const netProfit = bestPerf.finalValue - settings.initialInvestment;
            const profitColor = netProfit >= 0 ? 'text-green-600' : 'text-red-600';
            showResults(container, `
                <h3>Optimum Strategy Found:</h3>
                <p>Short MA: ${bestShort}, Long MA: ${bestLong}</p>
                <p>Final Value: <span class="font-bold">$${bestPerf.finalValue.toFixed(2)}</span></p>
                <p>Net Profit: <span class="font-bold ${profitColor}">$${netProfit.toFixed(2)}</span></p>
            `);

            const chartSection = isComprehensive ? elements.comprehensiveOptimumStrategyChartSection : elements.optimizationResults;
            const chartCanvas = isComprehensive ? elements.comprehensiveOptimumChartCanvas : elements.optimumChartCanvas;
            chartSection.classList.remove('hidden');
            const bestShortMA = calculateSMA(filteredPrices, bestShort);
            const bestLongMA = calculateSMA(filteredPrices, bestLong);

            if(isComprehensive){
                comprehensiveStrategyData = {prices: filteredPrices, shortMA: bestShortMA, longMA: bestLongMA, signals: bestPerf.signals, rsi, settings: {...settings, shortPeriod: bestShort, longPeriod: bestLong}};
                drawChart(chartCanvas, comprehensiveStrategyData.prices, comprehensiveStrategyData.shortMA, comprehensiveStrategyData.longMA, comprehensiveStrategyData.signals);
                renderTradesTable(bestPerf.signals, filteredPrices);
            } else {
                optimumStrategyData = {prices: filteredPrices, shortMA: bestShortMA, longMA: bestLongMA, signals: bestPerf.signals, rsi, settings: {...settings, shortPeriod: bestShort, longPeriod: bestLong}};
                drawChart(chartCanvas, optimumStrategyData.prices, optimumStrategyData.shortMA, optimumStrategyData.longMA, optimumStrategyData.signals);
            }

            elements.shortMA.value = bestShort;
            elements.longMA.value = bestLong;
            runSimulation();
        }, 10);
    }
    
    function renderTradesTable(signals, pricesData) {
        elements.comprehensiveTradesTableBody.innerHTML = '';
        const trades = [];
        let buySignal = null;
        for (const signal of signals) {
            if (signal.type === 'buy') {
                buySignal = signal;
            } else if (signal.type === 'sell' && buySignal) {
                trades.push({ buy: buySignal, sell: signal });
                buySignal = null;
            }
        }

        if(trades.length > 0){
            trades.forEach(trade => {
                const row = elements.comprehensiveTradesTableBody.insertRow();
                row.insertCell().textContent = new Date(pricesData[trade.buy.index].date).toLocaleDateString();
                row.insertCell().textContent = `${trade.buy.btc.toFixed(6)}`;
                row.insertCell().textContent = new Date(pricesData[trade.sell.index].date).toLocaleDateString();
                const grossCell = row.insertCell();
                grossCell.textContent = `$${trade.sell.grossProfit.toFixed(2)}`;
                grossCell.className = trade.sell.grossProfit >= 0 ? 'text-green-600' : 'text-red-600';
                const taxCell = row.insertCell();
                taxCell.textContent = `$${trade.sell.tax.toFixed(2)}`;
                const netCell = row.insertCell();
                netCell.textContent = `$${trade.sell.netProfit.toFixed(2)}`;
                netCell.className = trade.sell.netProfit >= 0 ? 'text-green-600' : 'text-red-600';

            });
            elements.comprehensiveTradesTableContainer.classList.remove('hidden');
        } else {
            elements.comprehensiveTradesTableContainer.classList.add('hidden');
        }
    }

    function setupEventListeners() {
        elements.runSimulationBtn.addEventListener('click', runSimulation);
        elements.findOptimumBtn.addEventListener('click', () => findOptimum(false));
        elements.findComprehensiveOptimumBtn.addEventListener('click', () => findOptimum(true));
        
        const createHoverListener = (container, redrawFn, getHoverBox) => {
             if (!container) return;
             container.addEventListener('mousemove', e => {
                const rect = container.querySelector('canvas').getBoundingClientRect();
                redrawFn({x: e.clientX - rect.left, y: e.clientY - rect.top, box: getHoverBox()});
            });
            container.addEventListener('mouseout', () => {
                redrawFn(null);
                const hoverBox = getHoverBox();
                if(hoverBox) hideHoverBox(hoverBox);
            });
        };

        createHoverListener(elements.currentSimulationSection, drawCurrentCharts, () => elements.hoverInfoBox);
        createHoverListener(elements.rsiFilteredSimulationSection, drawRsiFilteredCharts, () => elements.rsiFilteredHoverInfoBox);

        createHoverListener(elements.optimumStrategyChartSection, (hover) => {
            if(!optimumStrategyData) return;
            drawChart(elements.optimumChartCanvas, optimumStrategyData.prices, optimumStrategyData.shortMA, optimumStrategyData.longMA, optimumStrategyData.signals, hover);
        }, () => elements.optimumHoverInfoBox);

        createHoverListener(elements.comprehensiveOptimumStrategyChartSection, (hover) => {
             if(!comprehensiveStrategyData) return;
            drawChart(elements.comprehensiveOptimumChartCanvas, comprehensiveStrategyData.prices, comprehensiveStrategyData.shortMA, comprehensiveStrategyData.longMA, comprehensiveStrategyData.signals, hover);
        }, () => elements.comprehensiveHoverInfoBox);
    }

    async function initialize() {
        historicalPrices = await fetchCSV('./btc-usd-max.csv');
        if (historicalPrices.length > 0) {
            const lastDate = new Date(historicalPrices[historicalPrices.length - 1].date);
            elements.endDate.value = lastDate.toISOString().split('T')[0];
            const oneYearAgo = new Date(lastDate);
            oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
            elements.startDate.value = oneYearAgo.toISOString().split('T')[0];
            runSimulation();
        }
        setupEventListeners();
        window.addEventListener('resize', runSimulation);
    }

    initialize();
});
</script>
</body>
</html>
