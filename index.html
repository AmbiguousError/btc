<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USD/Bitcoin Trading Opportunity Identifier</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better layout on smaller screens */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%; /* Make canvas responsive */
            height: 400px; /* Fixed height for charting */
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .input-group label {
            font-weight: 600;
            color: #4a5568;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        .btn-primary {
            background-color: #6366f1;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover {
            background-color: #4f46e5;
            transform: translateY(-1px);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.3);
        }
        .results-box {
            background-color: #edf2f7;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #d1d5db;
        }
        .results-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #2d3748;
        }
        .results-box p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #4a5568;
        }
        .message-box {
            background-color: #fefcbf;
            border: 1px solid #fbd38d;
            color: #92400e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
            text-align: center;
        }
        .error-message {
            background-color: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .optimization-results {
            background-color: #e0f2fe;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #90cdf4;
            margin-top: 20px;
        }
        .optimization-results h3 {
            color: #2b6cb0;
        }
        .warning-message {
            background-color: #ffe8d1; /* Light orange */
            border: 1px solid #ffcc80; /* Darker orange */
            color: #a0522d; /* Dark brown */
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: 500;
            text-align: center;
        }
        .hover-info-box {
            background-color: #1a202c; /* Dark background */
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.875rem;
            position: absolute;
            z-index: 10;
            pointer-events: none; /* Allows mouse events to pass through */
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: none; /* Hidden by default */
        }


        /* Responsive adjustments */
        @media (min-width: 768px) {
            .input-section {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-end;
            }
            .input-group {
                flex: 1;
                max-width: 48%; /* Adjust for spacing */
            }
        }
        @media (max-width: 767px) {
            .input-section {
                flex-direction: column;
                align-items: stretch;
            }
            .input-group {
                width: 100%;
            }
            .input-group input {
                width: 100%;
            }
            .btn-primary {
                width: 100%;
            }
            .optimization-inputs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">USD/Bitcoin Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses **real historical USD/Bitcoin price data from the provided GitHub CSV file** and applies a Moving Average Crossover strategy to identify potential buy and sell signals.
            You can adjust the periods for the short and long moving averages. Hover over the "Current Strategy Simulation" chart to see price and date details.
        </p>

        <div class="input-section flex flex-col md:flex-row gap-4 mb-6">
            <div class="input-group">
                <label for="shortMA">Short MA Period (e.g., 2):</label>
                <input type="number" id="shortMA" value="2" min="2" max="50">
            </div>
            <div class="input-group">
                <label for="longMA">Long MA Period (e.g., 5):</label>
                <input type="number" id="longMA" value="5" min="3" max="100">
            </div>
            <button id="runSimulationBtn" class="btn-primary mt-auto">Run Simulation</button>
        </div>
        <div id="dataLengthWarning" class="warning-message hidden"></div>


        <div id="currentSimulationSection" class="chart-section mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Current Strategy Simulation</h2>
            <div id="loadingSpinner" class="loading-spinner"></div>
            <canvas id="currentChartCanvas"></canvas>
            <div id="hoverInfoBox" class="hover-info-box"></div>
            <div id="currentSimulationResults" class="results-box hidden">
                <h3>Simulation Results:</h3>
                <p id="totalTrades"></p>
                <p id="winningTrades"></p>
                <p id="losingTrades"></p>
                <p id="simulatedProfit"></p>
                <div id="messageBox" class="message-box hidden"></div>
            </div>
        </div>


        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Strategy Optimization Tool</h2>
            <p class="text-gray-600 text-center mb-6">
                Find the optimum Short and Long Moving Average periods that would have maximized profit
                over the historical data.
            </p>
            <div class="optimization-inputs flex flex-col md:flex-row gap-4 mb-6">
                <div class="input-group">
                    <label for="minShortMA">Min Short MA:</label>
                    <input type="number" id="minShortMA" value="2" min="2" max="40">
                </div>
                <div class="input-group">
                    <label for="maxShortMA">Max Short MA:</label>
                    <input type="number" id="maxShortMA" value="5" min="5" max="50">
                </div>
                <div class="input-group">
                    <label for="minLongMA">Min Long MA:</label>
                    <input type="number" id="minLongMA" value="6" min="10" max="80">
                </div>
                <div class="input-group">
                    <label for="maxLongMA">Max Long MA:</label>
                    <input type="number" id="maxLongMA" value="15" min="30" max="100">
                </div>
                <button id="findOptimumBtn" class="btn-primary mt-auto">Find Optimum Strategy</button>
            </div>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden">
                <h3>Optimum Strategy Found:</h3>
                <p id="optimumShortMA"></p>
                <p id="optimumLongMA"></p>
                <p id="optimumProfit"></p>
                <p id="optimumTotalTrades"></p>
                <p id="optimumWinningTrades"></p>
                <p id="optimumLosingTrades"></p>
                <div id="optimizationMessageBox" class="message-box hidden"></div>
            </div>
            <div id="optimumStrategyChartSection" class="chart-section mt-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Optimum Strategy Chart</h2>
                <canvas id="optimumChartCanvas"></canvas>
                <div id="optimumHoverInfoBox" class="hover-info-box"></div> <!-- New hover info box for optimum chart -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const currentChartCanvas = document.getElementById('currentChartCanvas');
            const currentCtx = currentChartCanvas.getContext('2d');
            const optimumChartCanvas = document.getElementById('optimumChartCanvas');
            const optimumCtx = optimumChartCanvas.getContext('2d');

            const shortMAPeriodInput = document.getElementById('shortMA');
            const longMAPeriodInput = document.getElementById('longMA');
            const runSimulationBtn = document.getElementById('runSimulationBtn');
            const currentSimulationResultsDiv = document.getElementById('currentSimulationResults'); // Changed ID
            const totalTradesSpan = document.getElementById('totalTrades');
            const winningTradesSpan = document.getElementById('winningTrades');
            const losingTradesSpan = document.getElementById('losingTrades');
            const simulatedProfitSpan = document.getElementById('simulatedProfit');
            const messageBox = document.getElementById('messageBox'); // For current sim messages
            const loadingSpinner = document.getElementById('loadingSpinner'); // For initial data load

            // Optimization elements
            const minShortMAInput = document.getElementById('minShortMA');
            const maxShortMAInput = document.getElementById('maxShortMA');
            const minLongMAInput = document.getElementById('minLongMA');
            const maxLongMAInput = document.getElementById('maxLongMA');
            const findOptimumBtn = document.getElementById('findOptimumBtn');
            const optimizationSpinner = document.getElementById('optimizationSpinner'); // For optimization process
            const optimizationResultsDiv = document.getElementById('optimizationResults');
            const optimumShortMASpan = document.getElementById('optimumShortMA');
            const optimumLongMASpan = document.getElementById('optimumLongMA');
            const optimumProfitSpan = document.getElementById('optimumProfit');
            const optimumTotalTradesSpan = document.getElementById('optimumTotalTrades');
            const optimumWinningTradesSpan = document.getElementById('optimumWinningTrades');
            const optimumLosingTradesSpan = document.getElementById('optimumLosingTrades');
            const optimizationMessageBox = document.getElementById('optimizationMessageBox'); // For optimization messages
            const dataLengthWarning = document.getElementById('dataLengthWarning'); // General warning


            // Hover elements
            const hoverInfoBox = document.getElementById('hoverInfoBox'); // For main chart
            const optimumHoverInfoBox = document.getElementById('optimumHoverInfoBox'); // For optimum chart


            let historicalPrices = [];

            // Set canvas dimensions
            const CHART_HEIGHT = 400;
            // Use currentChartCanvas for initial width, then apply to both
            let currentChartWidth = currentChartCanvas.offsetWidth;
            currentChartCanvas.height = CHART_HEIGHT;
            currentChartCanvas.width = currentChartWidth;
            optimumChartCanvas.height = CHART_HEIGHT;
            optimumChartCanvas.width = currentChartWidth; 

            // Adjust canvas width on window resize for responsiveness
            window.addEventListener('resize', () => {
                currentChartWidth = currentChartCanvas.offsetWidth; // Recalculate width
                currentChartCanvas.width = currentChartWidth;
                optimumChartCanvas.width = currentChartWidth;
                runSimulation(); // Redraw current sim chart
                // Re-draw optimum chart if results are visible
                if (!optimizationResultsDiv.classList.contains('hidden') && bestOptimumPerformance) {
                    drawChart(optimumCtx, historicalPrices, calculateSMA(historicalPrices, bestOptimumShortMA), calculateSMA(historicalPrices, bestOptimumLongMA), bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, -1, -1, false, optimumHoverInfoBox);
                }
            });

            // --- Message Box Functions ---
            // Now explicitly takes a targetBox
            function showMessageBox(message, type = 'info', targetBox) {
                if (!targetBox) { // Default to main messageBox if not specified
                    targetBox = messageBox;
                }
                targetBox.textContent = message;
                targetBox.classList.remove('hidden', 'message-box', 'error-message', 'warning-message');
                
                if (type === 'error') {
                    targetBox.classList.add('error-message');
                } else if (type === 'warning') {
                    targetBox.classList.add('warning-message');
                } else {
                    targetBox.classList.add('message-box');
                }
                targetBox.classList.remove('hidden');
            }

            function hideMessageBox(targetBox) {
                if (!targetBox) { // Default to main messageBox if not specified
                    targetBox = messageBox;
                }
                targetBox.classList.add('hidden');
            }

            // --- CSV Data Fetching and Parsing ---
            async function fetchCSV(filePath) {
                loadingSpinner.style.display = 'block';
                showMessageBox('Loading historical data...', 'info', messageBox); // Use messageBox for initial load
                try {
                    console.log('Attempting to fetch data from:', filePath);
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        console.error('Fetch response not OK:', response.status, response.statusText);
                        if (response.type === 'opaque' || (response.status === 0 && !navigator.onLine)) {
                             throw new Error('Network/CORS Error: Data could not be loaded. This typically happens when trying to fetch from an external URL like GitHub without proper CORS headers or a proxy.');
                        }
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }
                    const csvText = await response.text();
                    console.log('CSV data fetched successfully.');
                    return parseCSV(csvText);
                } catch (error) {
                    console.error('Error fetching or parsing CSV:', error);
                    showMessageBox(`Failed to load data: ${error.message}. Please check console for details.`, 'error', messageBox); // Use messageBox
                    return [];
                } finally {
                    loadingSpinner.style.display = 'none';
                }
            }

            function parseCSV(csvText) {
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    showMessageBox('CSV file is empty or has no data rows.', 'error', messageBox); // Use messageBox
                    return [];
                }

                const rawHeaders = lines[0].split(';');
                const headers = rawHeaders.map(h => h.trim().replace(/"/g, ''));

                const closePriceIndex = headers.indexOf('close');
                const dateIndex = headers.indexOf('timeClose');

                if (closePriceIndex === -1) {
                    showMessageBox('CSV missing "close" price column. Please check column headers (expected: "close").', 'error', messageBox); // Use messageBox
                    return [];
                }
                 if (dateIndex === -1) {
                    showMessageBox('CSV missing "timeClose" column. Chart x-axis labels might be less informative (expected: "timeClose").', 'info', messageBox); // Use messageBox
                }

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const columns = lines[i].split(';');
                    const closePrice = parseFloat(columns[closePriceIndex]);
                    const date = columns[dateIndex] ? columns[dateIndex].replace(/"/g, '') : '';

                    if (!isNaN(closePrice)) {
                        data.push({
                            price: closePrice,
                            date: date
                        });
                    }
                }
                console.log('CSV parsed. Number of data points:', data.length);
                return data.reverse();
            }

            // --- Technical Analysis Functions ---
            function calculateSMA(data, period) {
                if (period <= 0 || period > data.length) {
                    return Array(data.length).fill(null);
                }
                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val.price, 0);
                        sma.push(sum / period);
                    }
                }
                return sma;
            }

            function calculateStrategyPerformance(pricesData, shortPeriod, longPeriod) {
                const shortMA = calculateSMA(pricesData, shortPeriod);
                const longMA = calculateSMA(pricesData, longPeriod);

                const signals = [];
                let totalProfitLoss = 0;
                let tradesCount = 0;
                let winningTrades = 0;
                let losingTrades = 0;
                let currentTradeEntryPrice = null;
                let inPosition = false;

                // Determine the starting index for checking crossovers.
                // We need enough data points for both MAs to be valid at `i` and `i-1`.
                const startLookingIndex = Math.max(shortPeriod, longPeriod);


                for (let i = startLookingIndex; i < pricesData.length; i++) {
                    const currentPrice = pricesData[i].price;

                    // Ensure both MAs are calculable at current and previous points
                    if (shortMA[i] !== null && longMA[i] !== null && shortMA[i - 1] !== null && longMA[i - 1] !== null) {
                        // Buy Signal: Short MA crosses above Long MA (Golden Cross)
                        // This indicates a potential upward trend, suggesting a buying opportunity.
                        if (shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i]) {
                            if (!inPosition) {
                                signals.push({ index: i, type: 'buy', price: currentPrice });
                                inPosition = true;
                                currentTradeEntryPrice = currentPrice;
                            }
                        }
                        // Sell Signal: Short MA crosses below Long MA (Death Cross)
                        // This indicates a potential downward trend, suggesting a selling opportunity or exit.
                        else if (shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i]) {
                            if (inPosition) {
                                // Calculate P/L for this specific trade
                                const tradeProfitLoss = currentPrice - currentTradeEntryPrice;

                                signals.push({
                                    index: i,
                                    type: 'sell',
                                    price: currentPrice,
                                    entryPrice: currentTradeEntryPrice,
                                    profitLoss: tradeProfitLoss // Store individual trade P/L
                                });
                                tradesCount++;
                                totalProfitLoss += tradeProfitLoss;

                                if (tradeProfitLoss > 0) {
                                    winningTrades++;
                                } else if (tradeProfitLoss < 0) {
                                    losingTrades++;
                                }
                                inPosition = false;
                                currentTradeEntryPrice = 0;
                            }
                        }
                    }
                }

                // If a buy signal was the last signal and the position is still open, close it at the last price
                // This simulates closing the trade at the end of the available historical data.
                if (inPosition && currentTradeEntryPrice !== null) {
                    tradesCount++;
                    const lastPrice = pricesData[pricesData.length - 1].price;
                    const profitLoss = lastPrice - currentTradeEntryPrice;
                    totalProfitLoss += profitLoss;
                    if (profitLoss > 0) {
                        winningTrades++;
                    } else if (profitLoss < 0) {
                        losingTrades++;
                    }
                }
                
                console.log(`Strategy Performance for Short MA ${shortPeriod}, Long MA ${longPeriod}:`, { totalProfitLoss, tradesCount, winningTrades, losingTrades, signals });

                return { totalProfitLoss, tradesCount, winningTrades, losingTrades, signals };
            }

            // --- Charting Functions ---
            // drawChart now takes ctx, canvasWidth, canvasHeight to be reusable
            function drawChart(ctx, pricesData, shortMA, longMA, signals, canvasWidth, canvasHeight, hoverX = -1, hoverY = -1, isMainChart = false, hoverInfoBoxElement = null) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                const prices = pricesData.map(d => d.price);

                const allValues = [...prices, ...shortMA.filter(v => v !== null), ...longMA.filter(v => v !== null)];
                const minPrice = Math.min(...allValues);
                const maxPrice = Math.max(...allValues);
                const priceRange = maxPrice - minPrice;

                if (priceRange === 0) {
                    if (isMainChart) showMessageBox('Price range is zero. Cannot draw chart.', 'error', messageBox); // Use main messageBox
                    return;
                }

                const xScale = canvasWidth / (prices.length - 1);
                const yScale = canvasHeight / priceRange;

                const getY = (price) => canvasHeight - ((price - minPrice) * yScale);
                const getX = (index) => index * xScale;

                // --- Draw Grid ---
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 0.5;

                // Horizontal grid lines
                const numHorizontalLines = 5;
                for (let i = 0; i <= numHorizontalLines; i++) {
                    const yGrid = canvasHeight / numHorizontalLines * i;
                    ctx.beginPath();
                    ctx.moveTo(0, yGrid);
                    ctx.lineTo(canvasWidth, yGrid);
                    ctx.stroke();
                }

                // Vertical grid lines
                const numVerticalLines = Math.min(prices.length, 10);
                const xInterval = canvasWidth / (numVerticalLines > 1 ? numVerticalLines - 1 : 1);
                for (let i = 0; i < numVerticalLines; i++) {
                    const xGrid = xInterval * i;
                    ctx.beginPath();
                    ctx.moveTo(xGrid, 0);
                    ctx.lineTo(xGrid, canvasHeight);
                    ctx.stroke();
                }


                // Draw Price Line
                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                prices.forEach((price, i) => {
                    if (i === 0) {
                        ctx.moveTo(getX(i), getY(price));
                    } else {
                        ctx.lineTo(getX(i), getY(price));
                    }
                });
                ctx.stroke();

                // Draw Short MA Line
                ctx.beginPath();
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1.5;
                shortMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (i === 0 || shortMA[i - 1] === null) {
                             ctx.moveTo(getX(i), getY(ma));
                        } else {
                             ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                // Draw Long MA Line
                ctx.beginPath();
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 1.5;
                longMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (i === 0 || longMA[i - 1] === null) {
                            ctx.moveTo(getX(i), getY(ma));
                        } else {
                            ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                // Draw Signals
                signals.forEach(signal => {
                    ctx.beginPath();
                    const x = getX(signal.index);
                    const y = getY(prices[signal.index]);

                    if (signal.type === 'buy') {
                        ctx.fillStyle = '#22c55e';
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                    } else { // sell signal
                        ctx.fillStyle = '#ef4444';
                        ctx.rect(x - 6, y - 6, 12, 12);
                    }
                    ctx.fill();

                    // Display Profit/Loss for sell trades ONLY on the main chart
                    if (isMainChart && signal.type === 'sell' && signal.profitLoss !== undefined) {
                        const pL = signal.profitLoss.toFixed(2);
                        ctx.fillStyle = signal.profitLoss >= 0 ? '#10b981' : '#ef4444';
                        ctx.font = 'bold 13px Inter';
                        const text = `${pL > 0 ? '+' : ''}${pL}`;
                        
                        const textWidth = ctx.measureText(text).width;
                        const textHeight = 13; 

                        let textX = x + 15;
                        let textY = y - 15;

                        // Basic boundary checks (more sophisticated collision detection would be complex)
                        if (textX + textWidth > canvasWidth) textX = x - textWidth - 15;
                        if (textY < textHeight) textY = y + 15 + textHeight;


                        ctx.fillText(text, textX, textY);
                    }
                });

                // --- Draw Axes Labels (Improved) ---
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Inter';
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'right';

                // Y-axis labels
                const numYLabels = 5;
                for (let i = 0; i <= numYLabels; i++) {
                    const priceLabel = minPrice + (priceRange / numYLabels * i);
                    const yPos = getY(priceLabel);
                    ctx.fillText(`$${priceLabel.toFixed(2)}`, canvasWidth - 10, yPos);
                }
                ctx.textAlign = 'left';

                // X-axis labels (Dates)
                ctx.textBaseline = 'top';
                const numXLabels = Math.min(pricesData.length, 5);
                if (pricesData.length > 0) {
                    for (let i = 0; i < numXLabels; i++) {
                        const index = Math.floor(i * (pricesData.length - 1) / (numXLabels > 1 ? numXLabels - 1 : 1));
                        const date = new Date(pricesData[index].date);
                        const xPos = getX(index);
                        ctx.fillText(date.toLocaleDateString(), xPos + 5, canvasHeight - 25);
                    }
                }

                // --- Draw Crosshair and Hover Info ---
                if (hoverX !== -1 && hoverY !== -1 && hoverInfoBoxElement) { // Check if hoverInfoBoxElement is provided
                    // Draw vertical crosshair
                    ctx.beginPath();
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 1;
                    ctx.moveTo(hoverX, 0);
                    ctx.lineTo(hoverX, canvasHeight);
                    ctx.stroke();

                    // Draw horizontal crosshair
                    ctx.beginPath();
                    ctx.moveTo(0, hoverY);
                    ctx.lineTo(canvasWidth, hoverY);
                    ctx.stroke();

                    // Calculate closest data point
                    const dataIndex = Math.round(hoverX / xScale);
                    if (dataIndex >= 0 && dataIndex < pricesData.length) {
                        const hoveredData = pricesData[dataIndex];
                        const hoveredDate = new Date(hoveredData.date).toLocaleDateString();
                        const hoveredPrice = hoveredData.price.toFixed(2);
                        const hoverMAShort = shortMA[dataIndex] !== null ? shortMA[dataIndex].toFixed(2) : 'N/A';
                        const hoverMALong = longMA[dataIndex] !== null ? longMA[dataIndex].toFixed(2) : 'N/A';

                        hoverInfoBoxElement.style.display = 'block'; // Use the passed element
                        hoverInfoBoxElement.innerHTML = `
                            <strong>Date:</strong> ${hoveredDate}<br>
                            <strong>Price:</strong> $${hoveredPrice}<br>
                            <strong>Short MA:</strong> ${hoverMAShort}<br>
                            <strong>Long MA:</strong> ${hoverMALong}
                        `;

                        // Position info box relative to the document, taking its *own* canvas position into account
                        const currentCanvasRect = ctx.canvas.getBoundingClientRect(); 
                        let boxX = hoverX + currentCanvasRect.left + 15;
                        let boxY = hoverY + currentCanvasRect.top - (hoverInfoBoxElement.offsetHeight / 2);

                        if (boxX + hoverInfoBoxElement.offsetWidth > window.innerWidth) {
                            boxX = hoverX + currentCanvasRect.left - hoverInfoBoxElement.offsetWidth - 15;
                        }
                        if (boxY < currentCanvasRect.top) {
                            boxY = currentCanvasRect.top;
                        }
                        if (boxY + hoverInfoBoxElement.offsetHeight > window.innerHeight) {
                            boxY = window.innerHeight - hoverInfoBoxElement.offsetHeight - 10;
                        }

                        hoverInfoBoxElement.style.left = `${boxX}px`;
                        hoverInfoBoxElement.style.top = `${boxY}px`;
                    }
                } else if (hoverInfoBoxElement) { // Hide if not hovering or no data
                    hoverInfoBoxElement.style.display = 'none';
                }
            }

            // --- Main Simulation Logic (for manual input) ---
            function runSimulation() {
                hideMessageBox(messageBox); // Hide general messages for main chart
                dataLengthWarning.classList.add('hidden'); // Hide specific data length warning

                const shortPeriod = parseInt(shortMAPeriodInput.value);
                const longPeriod = parseInt(longMAPeriodInput.value);

                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded. Please ensure data is available.', 'error', messageBox);
                    currentSimulationResultsDiv.classList.add('hidden');
                    currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height); // Clear chart on error
                    return;
                }

                if (isNaN(shortPeriod) || isNaN(longPeriod) || shortPeriod <= 0 || longPeriod <= 0) {
                    showMessageBox('Please enter valid positive numbers for MA periods.', 'error', messageBox);
                    currentSimulationResultsDiv.classList.add('hidden');
                    currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height);
                    return;
                }
                if (shortPeriod >= longPeriod) {
                    showMessageBox('Short MA period must be less than Long MA period.', 'error', messageBox);
                    currentSimulationResultsDiv.classList.add('hidden');
                    currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height);
                    return;
                }
                // Warn if not enough data for the selected MA periods
                if (longPeriod > historicalPrices.length) {
                     const requiredData = longPeriod;
                     const availableData = historicalPrices.length;
                     showMessageBox(`Not enough data for Long MA period ${longPeriod}. You need at least ${requiredData} data points, but only ${availableData} are available. Adjust MA periods or provide more data.`, 'warning', dataLengthWarning); // Use general warning box
                     currentSimulationResultsDiv.classList.add('hidden');
                     currentCtx.clearRect(0, 0, currentChartCanvas.width, currentChartCanvas.height);
                     return;
                }

                const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);
                const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                const longMAValues = calculateSMA(historicalPrices, longPeriod);

                currentSimulationResultsDiv.classList.remove('hidden');
                totalTradesSpan.textContent = `Total completed trades: ${performance.tradesCount}`;
                winningTradesSpan.textContent = `Winning trades: ${performance.winningTrades}`;
                losingTradesSpan.textContent = `Losing trades: ${performance.losingTrades}`;
                simulatedProfitSpan.textContent = `Simulated Profit/Loss: $${performance.totalProfitLoss.toFixed(2)} USD (for 1 unit of Bitcoin traded)`;
                simulatedProfitSpan.style.color = performance.totalProfitLoss >= 0 ? '#10b981' : '#ef4444';

                drawChart(currentCtx, historicalPrices, shortMAValues, longMAValues, performance.signals, currentChartCanvas.width, currentChartCanvas.height, -1, -1, true, hoverInfoBox); // isMainChart = true
            }

            let bestOptimumShortMA = 0; // Stored for redraw on resize
            let bestOptimumLongMA = 0;  // Stored for redraw on resize
            let bestOptimumPerformance = null; // Stored for redraw on resize

            // --- Optimization Logic ---
            async function findOptimumStrategy() {
                hideMessageBox(optimizationMessageBox); // Hide optimization messages
                optimizationResultsDiv.classList.add('hidden');
                dataLengthWarning.classList.add('hidden'); // Hide general warning

                const minShort = parseInt(minShortMAInput.value);
                const maxShort = parseInt(maxShortMAInput.value);
                const minLong = parseInt(minLongMAInput.value);
                const maxLong = parseInt(maxLongMAInput.value);

                if (isNaN(minShort) || isNaN(maxShort) || isNaN(minLong) || isNaN(maxLong) ||
                    minShort <= 0 || maxShort <= 0 || minLong <= 0 || maxLong <= 0) {
                    showMessageBox('Please enter valid positive numbers for all optimization ranges.', 'error', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height); // Clear chart on error
                    return;
                }
                if (minShort >= maxShort || minLong >= maxLong || maxShort >= minLong) {
                    showMessageBox('Optimization ranges are invalid. Ensure Min < Max for each, and Max Short < Min Long.', 'error', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }
                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded for optimization. Please ensure data is available.', 'error', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }
                if (maxLong > historicalPrices.length) {
                    const requiredData = maxLong;
                    const availableData = historicalPrices.length;
                    showMessageBox(`Optimization range's Max Long MA (${maxLong}) is too large. You need at least ${requiredData} data points, but only ${availableData} are available. Adjust range.`, 'warning', optimizationMessageBox);
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height);
                    return;
                }

                optimizationSpinner.style.display = 'block';
                showMessageBox('Searching for optimum strategy...', 'info', optimizationMessageBox);

                let bestProfit = -Infinity;
                let bestShortMA = 0;
                let bestLongMA = 0;
                bestOptimumPerformance = null; // Reset before new optimization

                for (let shortPeriod = minShort; shortPeriod <= maxShort; shortPeriod++) {
                    for (let longPeriod = minLong; longPeriod <= maxLong; longPeriod++) {
                        if (shortPeriod >= longPeriod) {
                            continue;
                        }
                        if (longPeriod > historicalPrices.length) {
                            continue;
                        }

                        const currentPerformance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);

                        if (currentPerformance.totalProfitLoss > bestProfit) {
                            bestProfit = currentPerformance.totalProfitLoss;
                            bestShortMA = shortPeriod;
                            bestLongMA = longPeriod;
                            bestOptimumPerformance = currentPerformance;
                        }
                    }
                }

                optimizationSpinner.style.display = 'none';
                optimizationResultsDiv.classList.remove('hidden');

                optimumShortMASpan.textContent = `Optimum Short MA Period: ${bestShortMA}`;
                optimumLongMASpan.textContent = `Optimum Long MA Period: ${bestLongMA}`;
                optimumProfitSpan.textContent = `Maximum Simulated Profit: $${bestProfit.toFixed(2)} USD`;
                optimumProfitSpan.style.color = bestProfit >= 0 ? '#10b981' : '#ef4444';

                if (bestOptimumPerformance) {
                    optimumTotalTradesSpan.textContent = `Total completed trades: ${bestOptimumPerformance.tradesCount}`;
                    optimumWinningTradesSpan.textContent = `Winning trades: ${bestOptimumPerformance.winningTrades}`;
                    optimumLosingTradesSpan.textContent = `Losing trades: ${bestOptimumPerformance.losingTrades}`;
                } else {
                    optimumTotalTradesSpan.textContent = `Total completed trades: 0`;
                    optimumWinningTradesSpan.textContent = `Winning trades: 0`;
                    optimumLosingTradesSpan.textContent = `Losing trades: 0`;
                }

                if (bestProfit <= 0 && bestOptimumPerformance && bestOptimumPerformance.tradesCount > 0) {
                     showMessageBox(`Optimization complete. While trades were made, no net positive profit strategy was found within the tested ranges for this historical data. The displayed strategy represents the best outcome (least loss or break-even). This is common with simple strategies in complex markets.`, 'info', optimizationMessageBox);
                } else if (bestProfit <= 0 && bestOptimumPerformance && bestOptimumPerformance.tradesCount === 0) {
                     showMessageBox(`Optimization complete. No trades were made with any strategy within the tested ranges. This typically means the MA periods are too large for the data, or the price action was too flat for crossovers.`, 'info', optimizationMessageBox);
                }
                else {
                    showMessageBox('Optimization complete. Best strategy found!', 'info', optimizationMessageBox);
                }

                // Draw the optimum chart
                if (bestOptimumPerformance) {
                    const optimumShortMAValues = calculateSMA(historicalPrices, bestShortMA);
                    const optimumLongMAValues = calculateSMA(historicalPrices, bestLongMA);
                    drawChart(optimumCtx, historicalPrices, optimumShortMAValues, optimumLongMAValues, bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, -1, -1, false, optimumHoverInfoBox); // isMainChart = false
                } else {
                    optimumCtx.clearRect(0, 0, optimumChartCanvas.width, optimumChartCanvas.height); // Clear if no best found
                }

                // Update main simulation inputs and run it with the optimum strategy (optional, but good for quick view)
                shortMAPeriodInput.value = bestShortMA;
                longMAPeriodInput.value = bestLongMA;
                runSimulation(); // This will update the main chart and its results
            }

            // Path for the GitHub raw CSV file
            const csvFilePath = 'https://raw.githubusercontent.com/AmbiguousError/btc/refs/heads/main/BTC.csv';

            // Attempt to fetch from GitHub (will likely hit CORS error in this environment if not hosted via GitHub Pages)
            historicalPrices = await fetchCSV(csvFilePath);

            runSimulationBtn.addEventListener('click', runSimulation);
            findOptimumBtn.addEventListener('click', findOptimumStrategy);

            // --- Rollover Interaction Setup for Current Chart ---
            currentChartCanvas.addEventListener('mousemove', (e) => {
                const rect = currentChartCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (historicalPrices.length > 0) {
                    const shortPeriod = parseInt(shortMAPeriodInput.value);
                    const longPeriod = parseInt(longMAPeriodInput.value);
                    const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                    const longMAValues = calculateSMA(historicalPrices, longPeriod);
                    const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);

                    drawChart(currentCtx, historicalPrices, shortMAValues, longMAValues, performance.signals, currentChartCanvas.width, currentChartCanvas.height, mouseX, mouseY, true, hoverInfoBox);
                }
            });

            currentChartCanvas.addEventListener('mouseout', () => {
                if (historicalPrices.length > 0) {
                    const shortPeriod = parseInt(shortMAPeriodInput.value);
                    const longPeriod = parseInt(longMAPeriodInput.value);
                    const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                    const longMAValues = calculateSMA(historicalPrices, longPeriod);
                    const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);
                    
                    drawChart(currentCtx, historicalPrices, shortMAValues, longMAValues, performance.signals, currentChartCanvas.width, currentChartCanvas.height, -1, -1, true, hoverInfoBox);
                }
                hoverInfoBox.style.display = 'none';
            });

            // --- Rollover Interaction Setup for Optimum Chart ---
            optimumChartCanvas.addEventListener('mousemove', (e) => {
                const rect = optimumChartCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (historicalPrices.length > 0 && bestOptimumPerformance) { // Only enable if optimization has run
                    const shortMAValues = calculateSMA(historicalPrices, bestOptimumShortMA);
                    const longMAValues = calculateSMA(historicalPrices, bestOptimumLongMA);

                    drawChart(optimumCtx, historicalPrices, shortMAValues, longMAValues, bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, mouseX, mouseY, false, optimumHoverInfoBox);
                }
            });

            optimumChartCanvas.addEventListener('mouseout', () => {
                if (historicalPrices.length > 0 && bestOptimumPerformance) {
                    const shortMAValues = calculateSMA(historicalPrices, bestOptimumShortMA);
                    const longMAValues = calculateSMA(historicalPrices, bestOptimumLongMA);
                    
                    drawChart(optimumCtx, historicalPrices, shortMAValues, longMAValues, bestOptimumPerformance.signals, optimumChartCanvas.width, optimumChartCanvas.height, -1, -1, false, optimumHoverInfoBox);
                }
                optimumHoverInfoBox.style.display = 'none';
            });


            // Initial run on load only if data was loaded successfully.
            if (historicalPrices.length > 0) {
                runSimulation();
            }
        });
    </script>
</body>
</html>
