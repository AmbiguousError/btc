<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 6.0 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USD Trading Opportunity Identifier with Risk Management</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%;
            height: auto;
        }
        #currentChartCanvas, #optimumChartCanvas, #comprehensiveOptimumChartCanvas, #rsiFilteredChartCanvas {
            aspect-ratio: 16 / 9;
             max-height: 450px;
        }
        #rsiChartCanvas, #rsiFilteredRsiChartCanvas, #volumeChartCanvas, #filteredVolumeChartCanvas {
            aspect-ratio: 16 / 5;
            max-height: 150px;
        }
        .input-group { display: flex; flex-direction: column; gap: 8px; }
        .input-group label, .checkbox-group label { font-weight: 600; color: #4a5568; }
        .input-group input[type="number"], .input-group input[type="date"] {
            padding: 10px; border: 1px solid #cbd5e0; border-radius: 8px; font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus { outline: none; border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .btn-primary {
            background-color: #6366f1; color: white; padding: 12px 20px; border-radius: 8px; font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out; cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover { background-color: #4f46e5; transform: translateY(-1px); }
        .results-box { background-color: #edf2f7; border-radius: 10px; padding: 20px; border: 1px solid #d1d5db; }
        .explanation-box { background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; }
        .explanation-box h3, .results-box h3, .optimization-results h3 { font-size: 1.15rem; font-weight: 700; margin-bottom: 10px; color: #2d3748; }
        .explanation-box p, .results-box p, .optimization-results p { font-size: 0.95rem; line-height: 1.6; color: #4a5568; }
        .message-box { background-color: #fefcbf; border: 1px solid #fbd38d; color: #92400e; padding: 15px; border-radius: 8px; margin-top: 15px; font-weight: 500; text-align: center; }
        .error-message { background-color: #fed7d7; border-color: #fc8181; color: #c53030; }
        .warning-message { background-color: #ffe8d1; border: 1px solid #ffcc80; color: #a0522d; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid #6366f1; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 0 auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hover-info-box { background-color: #1a202c; color: #fff; padding: 8px 12px; border-radius: 5px; font-size: 0.875rem; position: absolute; z-index: 10; pointer-events: none; white-space: nowrap; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none; }
        .chart-section { border: 1px solid #e2e8f0; border-radius: 15px; padding: 20px; background-color: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .optimization-results { background-color: #e0f2fe; border-radius: 10px; padding: 20px; border: 1px solid #90cdf4; margin-top: 20px; }
        .data-preview-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.85rem; text-align: left; }
        .data-preview-table th, .data-preview-table td { border: 1px solid #e2e8f0; padding: 8px 12px; }
        .data-preview-table th { background-color: #e9eef4; font-weight: 600; color: #4a5568; }
        .data-preview-table tfoot td { font-weight: bold; background-color: #e0f2fe; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">BTC/USD Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses historical BTC/USD data, a Moving Average Crossover strategy, and an optional RSI filter to find and optimize trading signals.
        </p>

        <div class="explanation-box">
            <h3>How Signals Are Calculated</h3>
            <p>This model combines multiple technical indicators and risk management rules to generate buy and sell signals.</p>
            <ul>
                <li class="mt-2"><strong>1. Moving Average (MA) Crossover:</strong> The core signal. A "Golden Cross" (short MA over long MA) is a buy signal, while a "Death Cross" is a sell signal.</li>
                <li class="mt-2"><strong>2. Stop-Loss & Take-Profit:</strong> If enabled, a position will be automatically sold if the price drops by the Stop-Loss % or rises by the Take-Profit % from the entry price. This overrides all other signals.</li>
                <li class="mt-2"><strong>3. Optional Confirmation Filters:</strong> If enabled, these add extra conditions to the MA crossover signals:
                    <ul class="list-disc pl-6 mt-1">
                        <li><strong>RSI Filter:</strong> A buy requires RSI to be below the overbought level; a sell requires it to be above the oversold level.</li>
                        <li><strong>Bollinger Bands (BB) Filter:</strong> A buy requires the price to be below the middle BB line; a sell requires it to be above.</li>
                        <li><strong>Volume Filter:</strong> A signal requires the volume to be above its recent moving average.</li>
                    </ul>
                </li>
            </ul>
        </div>
        
        <div class="date-range-section grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div class="input-group"><label for="startDate">Start Date:</label><input type="date" id="startDate"></div>
            <div class="input-group"><label for="endDate">End Date:</label><input type="date" id="endDate"></div>
        </div>

        <div class="border-t border-gray-200 pt-6">
             <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Strategy Parameters</h2>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="input-group"><label for="initialInvestment">Initial Investment ($):</label><input type="number" id="initialInvestment" value="100" min="1"></div>
                <div class="input-group"><label for="taxRate">Tax Rate (%):</label><input type="number" id="taxRate" value="28" min="0" max="100"></div>
                <div class="input-group"><label for="serviceFee">Service Fee (%):</label><input type="number" id="serviceFee" value="0.1" min="0" max="10" step="0.1"></div>
                <div class="input-group"><label for="shortMA">Short MA Period:</label><input type="number" id="shortMA" value="2" min="2"></div>
                <div class="input-group"><label for="longMA">Long MA Period:</label><input type="number" id="longMA" value="5" min="3"></div>
                <div class="input-group"><label for="rsiPeriod">RSI Period:</label><input type="number" id="rsiPeriod" value="14" min="2"></div>
                <div class="input-group"><label for="rsiOverbought">RSI Overbought:</label><input type="number" id="rsiOverbought" value="70" min="51"></div>
                <div class="input-group"><label for="rsiOversold">RSI Oversold:</label><input type="number" id="rsiOversold" value="30" max="49"></div>
                <div class="input-group"><label for="bbPeriod">BB Period:</label><input type="number" id="bbPeriod" value="20" min="2"></div>
                <div class="input-group"><label for="bbStdDev">BB Std Dev:</label><input type="number" id="bbStdDev" value="2" min="1" step="0.1"></div>
                <div class="input-group"><label for="volumeMAPeriod">Volume MA Period:</label><input type="number" id="volumeMAPeriod" value="20" min="2"></div>
                <div class="input-group"><label for="stopLoss">Stop-Loss (%):</label><input type="number" id="stopLoss" value="5" min="0.1" step="0.1"></div>
                <div class="input-group"><label for="takeProfit">Take-Profit (%):</label><input type="number" id="takeProfit" value="15" min="0.1" step="0.1"></div>

                <div class="checkbox-group mt-4 col-span-2 md:col-span-4 flex-wrap">
                    <input type="checkbox" id="useSLTP" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useSLTP" class="mr-4">Use SL/TP</label>
                    <input type="checkbox" id="useRsiFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useRsiFilter" class="mr-4">Use RSI Filter</label>
                     <input type="checkbox" id="useBBFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useBBFilter" class="mr-4">Use BB Filter</label>
                    <input type="checkbox" id="useVolumeFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useVolumeFilter">Use Volume Filter</label>
                </div>
            </div>
            <button id="runSimulationBtn" class="btn-primary w-full mt-6">Run Simulation</button>
        </div>

        <div id="dataPreviewSection" class="results-box hidden">
            <h3>Data Preview for Selected Range:</h3>
            <table class="data-preview-table"><tbody id="dataPreviewTableBody"></tbody></table>
        </div>
        
        <div id="currentSimulationSection" class="chart-section mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Current Strategy Simulation</h2>
            <div id="loadingSpinner" class="loading-spinner"></div>
            <canvas id="currentChartCanvas"></canvas>
            <canvas id="rsiChartCanvas" class="mt-4"></canvas>
            <canvas id="volumeChartCanvas" class="mt-4"></canvas>
            <div id="hoverInfoBox" class="hover-info-box"></div>
            <div id="currentSimulationResults" class="results-box hidden mt-4"></div>
        </div>

        <div id="rsiFilteredSimulationSection" class="chart-section mt-6 border-t-4 border-indigo-300 pt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Fully-Filtered Strategy Simulation</h2>
             <p class="text-gray-600 text-center mb-6">This is a copy of the simulation above, but with all filters forcibly enabled.</p>
            <canvas id="rsiFilteredChartCanvas"></canvas>
            <canvas id="rsiFilteredRsiChartCanvas" class="mt-4"></canvas>
            <canvas id="filteredVolumeChartCanvas" class="mt-4"></canvas>
            <div id="rsiFilteredHoverInfoBox" class="hover-info-box"></div>
            <div id="rsiFilteredSimulationResults" class="results-box hidden mt-4"></div>
        </div>

        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Manual Strategy Optimization</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="input-group"><label for="minShortMA">Min Short MA:</label><input type="number" id="minShortMA" value="2"></div>
                <div class="input-group"><label for="maxShortMA">Max Short MA:</label><input type="number" id="maxShortMA" value="10"></div>
                <div class="input-group"><label for="minLongMA">Min Long MA:</label><input type="number" id="minLongMA" value="11"></div>
                <div class="input-group"><label for="maxLongMA">Max Long MA:</label><input type="number" id="maxLongMA" value="30"></div>
            </div>
            <button id="findOptimumBtn" class="btn-primary w-full mt-6">Find Optimum Strategy</button>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden mt-4"></div>
            <div id="optimumStrategyChartSection" class="chart-section mt-4 hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-2 text-center">Optimum Strategy Chart</h3>
                <canvas id="optimumChartCanvas"></canvas>
                <div id="optimumHoverInfoBox" class="hover-info-box"></div>
            </div>
        </div>

        <div class="comprehensive-optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Comprehensive Strategy Optimization</h2>
            <p class="text-gray-600 text-center mb-6">Tests all Short MA periods from 2-30 against all longer MA periods up to 100.</p>
            <button id="findComprehensiveOptimumBtn" class="btn-primary w-full">Find Comprehensive Optimum Strategy</button>
            <div id="comprehensiveOptimizationSpinner" class="loading-spinner"></div>
            <div id="comprehensiveOptimizationResults" class="optimization-results hidden mt-4"></div>
            <div id="comprehensiveOptimumStrategyChartSection" class="chart-section mt-4 hidden">
                 <h3 class="text-xl font-bold text-gray-800 mb-2 text-center">Comprehensive Optimum Strategy Chart</h3>
                <canvas id="comprehensiveOptimumChartCanvas"></canvas>
                <div id="comprehensiveOptimumHoverInfoBox" class="hover-info-box"></div>
                <div id="comprehensiveTradesTableContainer" class="mt-4 hidden">
                    <h4 class="text-lg font-bold text-gray-700 mb-2">Trade Log:</h4>
                    <div class="overflow-x-auto">
                        <table class="data-preview-table w-full">
                            <thead>
                                <tr>
                                    <th>Buy Date</th><th>BTC Bought</th><th>Sell Date</th><th>Gross P/L</th>
                                </tr>
                            </thead>
                            <tbody id="comprehensiveTradesTableBody">
                            </tbody>
                             <tfoot id="comprehensiveTradesTableFooter">
                            </tfoot>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    // --- Global Variables ---
    let historicalPrices = [];
    let filteredPrices = [];
    let currentStrategyData = null;
    let rsiFilteredStrategyData = null;
    let optimumStrategyData = null;
    let comprehensiveStrategyData = null;

    // --- DOM Element Cache ---
    const elements = {
        // Canvases
        currentChartCanvas: document.getElementById('currentChartCanvas'),
        rsiChartCanvas: document.getElementById('rsiChartCanvas'),
        volumeChartCanvas: document.getElementById('volumeChartCanvas'),
        rsiFilteredChartCanvas: document.getElementById('rsiFilteredChartCanvas'),
        rsiFilteredRsiChartCanvas: document.getElementById('rsiFilteredRsiChartCanvas'),
        filteredVolumeChartCanvas: document.getElementById('filteredVolumeChartCanvas'),
        optimumChartCanvas: document.getElementById('optimumChartCanvas'),
        comprehensiveOptimumChartCanvas: document.getElementById('comprehensiveOptimumChartCanvas'),
        // Inputs
        startDate: document.getElementById('startDate'),
        endDate: document.getElementById('endDate'),
        initialInvestment: document.getElementById('initialInvestment'),
        taxRate: document.getElementById('taxRate'),
        serviceFee: document.getElementById('serviceFee'),
        shortMA: document.getElementById('shortMA'),
        longMA: document.getElementById('longMA'),
        rsiPeriod: document.getElementById('rsiPeriod'),
        rsiOverbought: document.getElementById('rsiOverbought'),
        rsiOversold: document.getElementById('rsiOversold'),
        useRsiFilter: document.getElementById('useRsiFilter'),
        bbPeriod: document.getElementById('bbPeriod'),
        bbStdDev: document.getElementById('bbStdDev'),
        useBBFilter: document.getElementById('useBBFilter'),
        volumeMAPeriod: document.getElementById('volumeMAPeriod'),
        useVolumeFilter: document.getElementById('useVolumeFilter'),
        stopLoss: document.getElementById('stopLoss'),
        takeProfit: document.getElementById('takeProfit'),
        useSLTP: document.getElementById('useSLTP'),
        minShortMA: document.getElementById('minShortMA'),
        maxShortMA: document.getElementById('maxShortMA'),
        minLongMA: document.getElementById('minLongMA'),
        maxLongMA: document.getElementById('maxLongMA'),
        // Buttons
        runSimulationBtn: document.getElementById('runSimulationBtn'),
        findOptimumBtn: document.getElementById('findOptimumBtn'),
        findComprehensiveOptimumBtn: document.getElementById('findComprehensiveOptimumBtn'),
        // Spinners
        loadingSpinner: document.getElementById('loadingSpinner'),
        optimizationSpinner: document.getElementById('optimizationSpinner'),
        comprehensiveOptimizationSpinner: document.getElementById('comprehensiveOptimizationSpinner'),
        // Results & Info
        dataPreviewSection: document.getElementById('dataPreviewSection'),
        dataPreviewTableBody: document.getElementById('dataPreviewTableBody'),
        currentSimulationResults: document.getElementById('currentSimulationResults'),
        rsiFilteredSimulationResults: document.getElementById('rsiFilteredSimulationResults'),
        optimizationResults: document.getElementById('optimizationResults'),
        comprehensiveOptimizationResults: document.getElementById('comprehensiveOptimizationResults'),
        currentSimulationSection: document.getElementById('currentSimulationSection'),
        rsiFilteredSimulationSection: document.getElementById('rsiFilteredSimulationSection'),
        optimumStrategyChartSection: document.getElementById('optimumStrategyChartSection'),
        comprehensiveOptimumStrategyChartSection: document.getElementById('comprehensiveOptimumStrategyChartSection'),
        comprehensiveTradesTableContainer: document.getElementById('comprehensiveTradesTableContainer'),
        comprehensiveTradesTableBody: document.getElementById('comprehensiveTradesTableBody'),
        comprehensiveTradesTableFooter: document.getElementById('comprehensiveTradesTableFooter'),
        // Hover Boxes
        hoverInfoBox: document.getElementById('hoverInfoBox'),
        rsiFilteredHoverInfoBox: document.getElementById('rsiFilteredHoverInfoBox'),
        optimumHoverInfoBox: document.getElementById('optimumHoverInfoBox'),
        comprehensiveHoverInfoBox: document.getElementById('comprehensiveOptimumHoverInfoBox')
    };

    // --- Message/UI Helpers ---
    const showSpinner = spinner => spinner.style.display = 'block';
    const hideSpinner = spinner => spinner.style.display = 'none';
    
    function showResults(container, content) {
        container.innerHTML = content;
        container.classList.remove('hidden');
    }
    
    // --- Data Handling ---
    async function fetchCSV(filePath) {
        showSpinner(elements.loadingSpinner);
        try {
            const response = await fetch(filePath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const csvText = await response.text();
            return parseCSV(csvText);
        } catch (error) {
            showResults(elements.currentSimulationResults, `<div class="error-message">Failed to load data: ${error.message}.</div>`);
            return [];
        } finally {
            hideSpinner(elements.loadingSpinner);
        }
    }

    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        const closePriceIndex = headers.indexOf('price');
        const dateIndex = headers.indexOf('snapped_at');
        const volumeIndex = headers.indexOf('total_volume');
        if (closePriceIndex === -1 || dateIndex === -1) throw new Error('CSV missing "price" or "snapped_at" column.');
        if(volumeIndex === -1) console.warn("Volume data not found in CSV. Volume filter will be disabled.");

        return lines.slice(1).map(line => {
            const cols = line.split(',');
            const price = parseFloat(cols[closePriceIndex]);
            const date = cols[dateIndex]?.replace(/"/g, '').replace(' UTC', '');
            const volume = volumeIndex > -1 ? parseFloat(cols[volumeIndex]) : 0;
            return !isNaN(price) && date ? { price, date, volume } : null;
        }).filter(Boolean);
    }
    
    function filterDataByDateRange(data, startDate, endDate) {
        const start = startDate ? new Date(startDate).getTime() : -Infinity;
        const end = endDate ? new Date(endDate).getTime() : Infinity;
        return data.filter(p => {
            const pointDate = new Date(p.date).getTime();
            return pointDate >= start && pointDate <= end;
        });
    }

    function updateDataPreviewTable(data) {
        elements.dataPreviewTableBody.innerHTML = '';
        if (data.length === 0) {
            elements.dataPreviewSection.classList.add('hidden');
            return;
        }
        const previewData = [...data.slice(0, 5)];
        if (data.length > 10) {
            previewData.push(null);
            previewData.push(...data.slice(data.length - 5));
        } else if (data.length > 5) {
            previewData.push(...data.slice(5));
        }

        previewData.forEach(rowData => {
            const row = elements.dataPreviewTableBody.insertRow();
            if (rowData === null) {
                const cell = row.insertCell();
                cell.colSpan = 2;
                cell.textContent = '...';
                cell.style.textAlign = 'center';
            } else {
                row.insertCell().textContent = new Date(rowData.date).toLocaleDateString();
                row.insertCell().textContent = `$${rowData.price.toFixed(2)}`;
            }
        });
        elements.dataPreviewSection.classList.remove('hidden');
    }

    // --- Technical Analysis Calculations ---
    const calculateSMA = (data, period, key = 'price') => {
        const sma = Array(data.length).fill(null);
        for (let i = period - 1; i < data.length; i++) {
            sma[i] = data.slice(i - period + 1, i + 1).reduce((sum, d) => sum + d[key], 0) / period;
        }
        return sma;
    };
    
    const calculateRSI = (data, period) => {
        const rsi = Array(data.length).fill(null);
        if (period >= data.length) return rsi;
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const change = data[i].price - data[i - 1].price;
            change > 0 ? gains += change : losses -= change;
        }
        let avgGain = gains / period, avgLoss = losses / period;
        rsi[period] = 100 - (100 / (1 + (avgGain / avgLoss)));

        for (let i = period + 1; i < data.length; i++) {
            const change = data[i].price - data[i - 1].price;
            avgGain = (avgGain * (period - 1) + (change > 0 ? change : 0)) / period;
            avgLoss = (avgLoss * (period - 1) + (change < 0 ? -change : 0)) / period;
            rsi[i] = 100 - (100 / (1 + (avgLoss === 0 ? Infinity : avgGain / avgLoss)));
        }
        return rsi;
    };

    function calculateBollingerBands(data, period, stdDevMultiplier) {
        const middle = Array(data.length).fill(null);
        const upper = Array(data.length).fill(null);
        const lower = Array(data.length).fill(null);

        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1).map(d => d.price);
            const sma = slice.reduce((sum, val) => sum + val, 0) / period;
            const stdDev = Math.sqrt(slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period);
            
            middle[i] = sma;
            upper[i] = sma + (stdDev * stdDevMultiplier);
            lower[i] = sma - (stdDev * stdDevMultiplier);
        }
        return { middle, upper, lower };
    }

    function calculateStrategyPerformance(prices, shortMA, longMA, rsi, bb, volumeSMA, settings) {
        let cash = settings.initialInvestment;
        let btc = 0;
        let signals = [];
        let entryPrice = 0;

        for (let i = 1; i < prices.length; i++) {
            const price = prices[i].price;
            const volume = prices[i].volume;
            
            if (btc > 0) { // In a position, check for sell conditions
                let sellReason = null;
                const stopLossPrice = entryPrice * (1 - settings.stopLoss / 100);
                const takeProfitPrice = entryPrice * (1 + settings.takeProfit / 100);

                if (settings.useSLTP) {
                    if (price <= stopLossPrice) sellReason = 'stop_loss';
                    else if (price >= takeProfitPrice) sellReason = 'take_profit';
                }

                if (!sellReason) { // If not triggered by SL/TP, check indicator signals
                    const deathCross = shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i];
                    const bbConditionSell = !settings.useBBFilter || price > bb.middle[i];
                    const volumeCondition = !settings.useVolumeFilter || volume > volumeSMA[i];
                    if(deathCross && bbConditionSell && volumeCondition) {
                        sellReason = 'death_cross';
                    }
                }

                if(sellReason){
                    cash = btc * price;
                    btc = 0;
                    const grossProfit = cash - entryPrice * (signals.filter(s => s.type === 'buy').pop().btc);
                    signals.push({ index: i, type: 'sell', price, grossProfit, reason: sellReason });
                }

            } else { // Not in a position, check for buy conditions
                const goldenCross = shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i];
                const rsiCondition = !settings.useRsiFilter || rsi[i] < settings.rsiOverbought;
                const bbConditionBuy = !settings.useBBFilter || price < bb.middle[i];
                const volumeCondition = !settings.useVolumeFilter || volume > volumeSMA[i];
                
                if (goldenCross && cash > 0 && rsiCondition && bbConditionBuy && volumeCondition) {
                    btc = cash / price;
                    entryPrice = price;
                    signals.push({ index: i, type: 'buy', price, btc });
                    cash = 0;
                }
            }
        }
        
        let finalValue = btc > 0 ? btc * prices[prices.length - 1].price : cash;
        
        const totalProfit = finalValue - settings.initialInvestment;
        let finalNetValue = finalValue;

        if (totalProfit > 0) {
            const fee = totalProfit * (settings.serviceFee / 100);
            const taxableProfit = totalProfit - fee;
            const tax = taxableProfit > 0 ? taxableProfit * (settings.taxRate / 100) : 0;
            finalNetValue = finalValue - fee - tax;
        }
        
        return { signals, finalValue: finalNetValue, preTaxFinalValue: finalValue };
    }


    // --- Charting ---
    function setupCanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        return { ctx, width: rect.width, height: rect.height };
    }

    function drawChart(canvas, pricesData, shortMA, longMA, bb, signals, hoverInfo) {
        const { ctx, width, height } = setupCanvas(canvas);
        ctx.clearRect(0, 0, width, height);

        const prices = pricesData.map(d => d.price);
        const allValues = [...prices, ...shortMA, ...longMA, ...bb.upper, ...bb.lower].filter(v => v !== null);
        if (allValues.length === 0) return;
        
        let min = Math.min(...allValues), max = Math.max(...allValues);
        const padding = (max - min) * 0.1;
        min -= padding; max += padding;

        const xScale = width / (prices.length -1 || 1);
        const yScale = height / (max - min || 1);
        const getX = i => i * xScale;
        const getY = price => height - ((price - min) * yScale);
        
        // Bollinger Bands Area
        ctx.fillStyle = 'rgba(165, 180, 252, 0.1)'; 
        const upperPoints = bb.upper.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}).filter(Boolean);
        const lowerPoints = bb.lower.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}).filter(Boolean).reverse();
        
        if (upperPoints.length > 0 && lowerPoints.length > 0) {
            ctx.beginPath();
            ctx.moveTo(upperPoints[0].x, upperPoints[0].y);
            upperPoints.forEach(p => ctx.lineTo(p.x, p.y));
            lowerPoints.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();
        }

        drawChartDetails(ctx, width, height, min, max, getX, pricesData);

        const createPoints = (data, yFunc) => data.map((d, i) => d === null ? null : {x: getX(i), y: yFunc(d)});
        drawDataLine(ctx, createPoints(prices, getY), '#3b82f6', 2);
        drawDataLine(ctx, createPoints(shortMA, getY), '#ef4444', 1.5);
        drawDataLine(ctx, createPoints(longMA, getY), '#10b981', 1.5);
        
        // Bollinger Bands Lines
        drawDataLine(ctx, createPoints(bb.upper, getY), 'rgba(129, 140, 248, 0.5)', 1, true); 
        drawDataLine(ctx, createPoints(bb.lower, getY), 'rgba(129, 140, 248, 0.5)', 1, true); 
        
        signals.forEach(s => {
            const x = getX(s.index), y = getY(s.price);
            ctx.beginPath();
            
            if (s.type === 'buy') {
                ctx.fillStyle = '#22c55e'; // Green circle for buy
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
            } else { // Sell signals
                 if (s.reason === 'stop_loss') {
                    ctx.fillStyle = '#ef4444'; // Red
                    ctx.moveTo(x, y + 6); ctx.lineTo(x-6, y-3); ctx.lineTo(x+6, y-3); ctx.closePath(); // Down triangle
                } else if (s.reason === 'take_profit') {
                    ctx.fillStyle = '#22c55e'; // Green
                    ctx.moveTo(x, y - 6); ctx.lineTo(x-6, y+3); ctx.lineTo(x+6, y+3); ctx.closePath(); // Up triangle
                } else { // death_cross
                    ctx.fillStyle = '#ef4444'; // Red
                    ctx.rect(x-4, y-4, 8, 8); // Square
                }
            }
            ctx.fill();
        });

        if (hoverInfo && hoverInfo.x !== -1) {
            drawCrosshair(ctx, hoverInfo.x, hoverInfo.y, width, height);
            const i = Math.round(hoverInfo.x / xScale);
            if (pricesData[i]) {
                const infoHtml = `<strong>Date:</strong> ${new Date(pricesData[i].date).toLocaleDateString()}<br>
                                  <strong>Price:</strong> $${prices[i].toFixed(2)}<br>
                                  <strong>Short MA:</strong> ${shortMA[i]?.toFixed(2) || 'N/A'}<br>
                                  <strong>Long MA:</strong> ${longMA[i]?.toFixed(2) || 'N/A'}<br>
                                  <strong>BB Upper:</strong> ${bb.upper[i]?.toFixed(2) || 'N/A'}<br>
                                  <strong>BB Lower:</strong> ${bb.lower[i]?.toFixed(2) || 'N/A'}`;
                showHoverBox(hoverInfo.box, infoHtml, hoverInfo.x, hoverInfo.y, canvas);
            }
        } else if (hoverInfo) {
            hideHoverBox(hoverInfo.box);
        }
    }

    function drawChartDetails(ctx, width, height, min, max, getX, pricesData) {
        ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 0.5;
        ctx.font = '10px Inter'; ctx.fillStyle = '#6b7280';

        const numYLabels = 5;
        for (let i = 0; i <= numYLabels; i++) {
            const y = (height / numYLabels) * i;
            const price = max - (i * (height / numYLabels) / height * (max - min));
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            ctx.textAlign = 'right'; ctx.fillText(price.toFixed(2), width - 5, y - 5);
        }
        
        const numXLabels = Math.min(Math.floor(width / 100), pricesData.length);
        if (pricesData.length > 1 && numXLabels > 1) {
            for (let i = 0; i < numXLabels; i++) {
                const index = Math.floor(i * (pricesData.length - 1) / (numXLabels - 1));
                const x = getX(index);
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                ctx.textAlign = 'center'; ctx.fillText(new Date(pricesData[index].date).toLocaleDateString(), x, height - 5);
            }
        }

        const legend = [{c: '#3b82f6', t: 'Price'}, {c: '#ef4444', t: 'Short MA'}, {c: '#10b981', t: 'Long MA'}];
        ctx.textAlign = 'left';
        legend.forEach((item, i) => {
            ctx.fillStyle = item.c;
            ctx.fillRect(10 + i * 90, 10, 15, 2);
            ctx.fillStyle = '#6b7280';
            ctx.fillText(item.t, 30 + i * 90, 12);
        });
    }
    
    function drawRSIChart(ctx, width, height, rsiData, settings, hoverInfo) {
        ctx.clearRect(0, 0, width, height);
        if (rsiData.length === 0) return;

        const xScale = width / (rsiData.length - 1 || 1);
        const yScale = height / 100;
        const getX = i => i * xScale;
        const getY = val => height - (val * yScale);

        ctx.fillStyle = 'rgba(239, 68, 68, 0.05)';
        ctx.fillRect(0, 0, width, getY(settings.rsiOverbought));
        ctx.fillStyle = 'rgba(34, 197, 94, 0.05)';
        ctx.fillRect(0, getY(settings.rsiOversold), width, height);
        
        ctx.font = '10px Inter'; ctx.fillStyle = '#6b7280'; ctx.textAlign = 'right';
        ctx.fillText(settings.rsiOverbought, width - 5, getY(settings.rsiOverbought) + 10);
        ctx.fillText(settings.rsiOversold, width - 5, getY(settings.rsiOversold) - 2);

        drawDataLine(ctx, rsiData.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}), '#4f46e5', 1.5);
        
        if (hoverInfo && hoverInfo.x !== -1) {
            drawCrosshair(ctx, hoverInfo.x, hoverInfo.y, width, height);
            const i = Math.round(hoverInfo.x / xScale);
            if (rsiData[i] !== null) {
                const currentHoverText = hoverInfo.box.innerHTML;
                const rsiText = `<br><strong>RSI:</strong> ${rsiData[i].toFixed(2)}`;
                if (hoverInfo.box && !currentHoverText.includes(rsiText)) {
                     hoverInfo.box.innerHTML += rsiText;
                }
            }
        }
    }

    function drawVolumeChart(canvas, pricesData, volumeSMA, hoverInfo) {
        const { ctx, width, height } = setupCanvas(canvas);
        ctx.clearRect(0, 0, width, height);

        const volume = pricesData.map(d => d.volume);
        if(volume.length === 0 || volume.every(v => v === 0)) return;

        const maxVolume = Math.max(...volume);
        const xScale = width / (volume.length - 1 || 1);
        const yScale = height / maxVolume;

        const getX = i => i * xScale;
        const getY = v => height - (v * yScale);

        // Draw Volume Bars
        const barWidth = width / volume.length * 0.8;
        volume.forEach((v, i) => {
            ctx.fillStyle = i > 0 && pricesData[i].price < pricesData[i-1].price ? 'rgba(239, 68, 68, 0.6)' : 'rgba(34, 197, 94, 0.6)';
            ctx.fillRect(getX(i) - barWidth / 2, getY(v), barWidth, v * yScale);
        });

        // Draw Volume SMA
        const createPoints = (data, yFunc) => data.map((d, i) => d === null ? null : {x: getX(i), y: yFunc(d)});
        drawDataLine(ctx, createPoints(volumeSMA, getY), 'rgba(55, 65, 81, 0.8)', 1.5);

         if (hoverInfo && hoverInfo.x !== -1) {
            const i = Math.round(hoverInfo.x / xScale);
            if (pricesData[i]) {
                const currentHoverText = hoverInfo.box.innerHTML;
                const volumeText = `<br><strong>Volume:</strong> ${pricesData[i].volume.toLocaleString()}`;
                if (hoverInfo.box && !currentHoverText.includes(volumeText)) {
                     hoverInfo.box.innerHTML += volumeText;
                }
            }
        }
    }
    
    function drawDataLine(ctx, points, color, width, isDashed = false) {
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = width;
        if(isDashed) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
        let first = true;
        points.forEach(p => {
            if (p !== null) {
                first ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
                first = false;
            } else {
                first = true;
            }
        });
        ctx.stroke();
    }
    
    function drawCrosshair(ctx, x, y, width, height) {
        ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
    }

    function showHoverBox(box, html, x, y, canvas) {
        if(!box) return;
        box.innerHTML = html;
        box.style.display = 'block';
        const rect = canvas.getBoundingClientRect();
        let left = rect.left + window.scrollX + x + 15;
        let top = rect.top + window.scrollY + y - box.offsetHeight / 2;
        if (left + box.offsetWidth > window.innerWidth) left = rect.left + window.scrollX + x - box.offsetWidth - 15;
        box.style.left = `${left}px`;
        box.style.top = `${top}px`;
    }
    const hideHoverBox = box => { if(box) box.style.display = 'none'; };

    // --- Simulation & Optimization Logic ---
    function getSettings() {
        return {
            initialInvestment: parseFloat(elements.initialInvestment.value),
            taxRate: parseFloat(elements.taxRate.value),
            serviceFee: parseFloat(elements.serviceFee.value),
            shortPeriod: parseInt(elements.shortMA.value),
            longPeriod: parseInt(elements.longMA.value),
            rsiPeriod: parseInt(elements.rsiPeriod.value),
            rsiOverbought: parseInt(elements.rsiOverbought.value),
            rsiOversold: parseInt(elements.rsiOversold.value),
            useRsiFilter: elements.useRsiFilter.checked,
            bbPeriod: parseInt(elements.bbPeriod.value),
            bbStdDev: parseFloat(elements.bbStdDev.value),
            useBBFilter: elements.useBBFilter.checked,
            volumeMAPeriod: parseInt(elements.volumeMAPeriod.value),
            useVolumeFilter: elements.useVolumeFilter.checked,
            stopLoss: parseFloat(elements.stopLoss.value),
            takeProfit: parseFloat(elements.takeProfit.value),
            useSLTP: elements.useSLTP.checked,
            startDate: elements.startDate.value,
            endDate: elements.endDate.value,
        };
    }

    function renderPerformanceResults(container, perf, settings) {
        const netProfit = perf.finalValue - settings.initialInvestment;
        const profitColor = netProfit >= 0 ? 'text-green-600' : 'text-red-600';
        const trades = perf.signals.filter(s => s.type === 'sell');
        const totalProfit = perf.preTaxFinalValue - settings.initialInvestment;
        const fee = totalProfit > 0 ? totalProfit * (settings.serviceFee / 100) : 0;
        const taxableProfit = totalProfit > 0 ? totalProfit - fee : 0;
        const tax = taxableProfit > 0 ? taxableProfit * (settings.taxRate / 100) : 0;

        showResults(container, `
            <h3>Results:</h3>
            <p>Final Portfolio Value (Pre-Tax/Fee): <span class="font-bold">$${perf.preTaxFinalValue.toFixed(2)}</span></p>
            <p>Tax on Gains: <span class="font-bold text-red-600">-$${tax.toFixed(2)}</span></p>
             <p>Service Fees: <span class="font-bold text-red-600">-$${fee.toFixed(2)}</span></p>
            <p>Final Net Value (Post-Tax/Fee): <span class="font-bold">$${perf.finalValue.toFixed(2)}</span></p>
            <p>Net Profit/Loss: <span class="font-bold ${profitColor}">$${netProfit.toFixed(2)}</span></p>
            <p>Total completed trades: ${trades.length}</p>
        `);
    }
    
    // --- Main Drawing Functions ---
    function drawCurrentCharts(hoverInfo) {
        if (!currentStrategyData) return;
        const { prices, shortMA, longMA, rsi, bb, volumeSMA, signals, settings } = currentStrategyData;
        drawChart(elements.currentChartCanvas, prices, shortMA, longMA, bb, signals, hoverInfo);
        
        const { ctx, width, height } = setupCanvas(elements.rsiChartCanvas);
        drawRSIChart(ctx, width, height, rsi, settings, hoverInfo);
        
        drawVolumeChart(elements.volumeChartCanvas, prices, volumeSMA, hoverInfo);
    }

    function drawRsiFilteredCharts(hoverInfo) {
        if (!rsiFilteredStrategyData) return;
        const { prices, shortMA, longMA, rsi, bb, volumeSMA, signals, settings } = rsiFilteredStrategyData;
        drawChart(elements.rsiFilteredChartCanvas, prices, shortMA, longMA, bb, signals, hoverInfo);
        
        const { ctx, width, height } = setupCanvas(elements.rsiFilteredRsiChartCanvas);
        drawRSIChart(ctx, width, height, rsi, settings, hoverInfo);

        drawVolumeChart(elements.filteredVolumeChartCanvas, prices, volumeSMA, hoverInfo);
    }
    
    function runSimulation() {
        const settings = getSettings();
        filteredPrices = filterDataByDateRange(historicalPrices, settings.startDate, settings.endDate);
        updateDataPreviewTable(filteredPrices);
        
        const maxPeriod = Math.max(settings.longPeriod, settings.rsiPeriod, settings.bbPeriod, settings.volumeMAPeriod);
        if (filteredPrices.length < maxPeriod) {
            showResults(elements.currentSimulationResults, `<div class="warning-message">Not enough data. Need ${maxPeriod}, have ${filteredPrices.length}.</div>`);
            return;
        }

        const shortMA = calculateSMA(filteredPrices, settings.shortPeriod, 'price');
        const longMA = calculateSMA(filteredPrices, settings.longPeriod, 'price');
        const rsi = calculateRSI(filteredPrices, settings.rsiPeriod);
        const bb = calculateBollingerBands(filteredPrices, settings.bbPeriod, settings.bbStdDev);
        const volumeSMA = calculateSMA(filteredPrices, settings.volumeMAPeriod, 'volume');
        
        // Normal simulation data
        const performance = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, settings);
        currentStrategyData = { prices: filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, signals: performance.signals, settings };
        renderPerformanceResults(elements.currentSimulationResults, performance, settings);

        // RSI-Filtered simulation data
        const fullyFilteredSettings = {...settings, useRsiFilter: true, useBBFilter: true, useVolumeFilter: true};
        const fullyFilteredPerformance = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, fullyFilteredSettings);
        rsiFilteredStrategyData = { prices: filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, signals: fullyFilteredPerformance.signals, settings: fullyFilteredSettings };
        renderPerformanceResults(elements.rsiFilteredSimulationResults, fullyFilteredPerformance, settings);

        // Initial draw without hover
        drawCurrentCharts(null);
        drawRsiFilteredCharts(null);
    }
    
    function findOptimum(isComprehensive = false) {
        const settings = getSettings();
        filteredPrices = filterDataByDateRange(historicalPrices, settings.startDate, settings.endDate);
        const container = isComprehensive ? elements.comprehensiveOptimizationResults : elements.optimizationResults;
        const spinner = isComprehensive ? elements.comprehensiveOptimizationSpinner : elements.optimizationSpinner;
        
        showSpinner(spinner);
        showResults(container, "<h3>Optimizing...</h3><p>This may take a moment.</p>");

        setTimeout(() => {
            let bestPerf = { finalValue: -Infinity }, bestShort = 0, bestLong = 0;
            const rsi = calculateRSI(filteredPrices, settings.rsiPeriod);
            const bb = calculateBollingerBands(filteredPrices, settings.bbPeriod, settings.bbStdDev);
            const volumeSMA = calculateSMA(filteredPrices, settings.volumeMAPeriod, 'volume');

            const loopRunner = () => {
                if (isComprehensive) {
                    const maxShortComprehensive = 30;
                    const maxLongComprehensive = 100;
                     if (maxLongComprehensive > filteredPrices.length) {
                        showResults(container, `<div class="warning-message">Not enough data. Need ${maxLongComprehensive}, have ${filteredPrices.length}.</div>`);
                        hideSpinner(spinner);
                        return;
                    }
                    for (let short = 2; short <= maxShortComprehensive; short++) {
                        for (let long = short + 1; long <= maxLongComprehensive; long++) {
                            runTest(short, long);
                        }
                    }
                } else {
                    const minShort = parseInt(elements.minShortMA.value);
                    const maxShort = parseInt(elements.maxShortMA.value);
                    const minLong = parseInt(elements.minLongMA.value);
                    const maxLong = parseInt(elements.maxLongMA.value);
                    if (maxLong > filteredPrices.length) {
                        showResults(container, `<div class="warning-message">Not enough data. Need ${maxLong}, have ${filteredPrices.length}.</div>`);
                        hideSpinner(spinner);
                        return;
                    }
                    for (let short = minShort; short <= maxShort; short++) {
                        for (let long = minLong; long <= maxLong; long++) {
                            if (short >= long) continue;
                            runTest(short, long);
                        }
                    }
                }
            }

            const runTest = (short, long) => {
                const shortMA = calculateSMA(filteredPrices, short, 'price');
                const longMA = calculateSMA(filteredPrices, long, 'price');
                const perf = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, {...settings, shortPeriod: short, longPeriod: long});
                if (perf.finalValue > bestPerf.finalValue) {
                    bestPerf = perf; bestShort = short; bestLong = long;
                }
            };
            
            loopRunner();

            hideSpinner(spinner);
            const netProfit = bestPerf.finalValue - settings.initialInvestment;
            const profitColor = netProfit >= 0 ? 'text-green-600' : 'text-red-600';
            showResults(container, `
                <h3>Optimum Strategy Found:</h3>
                <p>Short MA: ${bestShort}, Long MA: ${bestLong}</p>
                <p>Final Value: <span class="font-bold">$${bestPerf.finalValue.toFixed(2)}</span></p>
                <p>Net Profit: <span class="font-bold ${profitColor}">$${netProfit.toFixed(2)}</span></p>
            `);

            const chartSection = isComprehensive ? elements.comprehensiveOptimumStrategyChartSection : elements.optimizationResults;
            const chartCanvas = isComprehensive ? elements.comprehensiveOptimumChartCanvas : elements.optimumChartCanvas;
            chartSection.classList.remove('hidden');
            const bestShortMA = calculateSMA(filteredPrices, bestShort, 'price');
            const bestLongMA = calculateSMA(filteredPrices, bestLong, 'price');

            if(isComprehensive){
                comprehensiveStrategyData = {prices: filteredPrices, shortMA: bestShortMA, longMA: bestLongMA, bb, signals: bestPerf.signals, rsi, volumeSMA, settings: {...settings, shortPeriod: bestShort, longPeriod: bestLong}};
                drawChart(chartCanvas, comprehensiveStrategyData.prices, comprehensiveStrategyData.shortMA, comprehensiveStrategyData.longMA, comprehensiveStrategyData.bb, comprehensiveStrategyData.signals);
                renderTradesTable(bestPerf, settings);
            } else {
                optimumStrategyData = {prices: filteredPrices, shortMA: bestShortMA, longMA: bestLongMA, bb, signals: bestPerf.signals, rsi, volumeSMA, settings: {...settings, shortPeriod: bestShort, longPeriod: bestLong}};
                drawChart(chartCanvas, optimumStrategyData.prices, optimumStrategyData.shortMA, optimumStrategyData.longMA, optimumStrategyData.bb, optimumStrategyData.signals);
            }

            elements.shortMA.value = bestShort;
            elements.longMA.value = bestLong;
            runSimulation();
        }, 10);
    }
    
    function renderTradesTable(perf, settings) {
        const signals = perf.signals;
        const pricesData = filteredPrices;
        elements.comprehensiveTradesTableBody.innerHTML = '';
        elements.comprehensiveTradesTableFooter.innerHTML = '';
        const trades = [];
        let buySignal = null;
        for (const signal of signals) {
            if (signal.type === 'buy') {
                buySignal = signal;
            } else if (signal.type === 'sell' && buySignal) {
                trades.push({ buy: buySignal, sell: signal });
                buySignal = null;
            }
        }

        if(trades.length > 0){
            let totalGrossProfit = 0;
            trades.forEach(trade => {
                totalGrossProfit += trade.sell.grossProfit;
                const row = elements.comprehensiveTradesTableBody.insertRow();
                row.insertCell().textContent = new Date(pricesData[trade.buy.index].date).toLocaleDateString();
                row.insertCell().textContent = `${trade.buy.btc.toFixed(6)}`;
                row.insertCell().textContent = new Date(pricesData[trade.sell.index].date).toLocaleDateString();
                const grossCell = row.insertCell();
                grossCell.textContent = `$${trade.sell.grossProfit.toFixed(2)}`;
                grossCell.className = trade.sell.grossProfit >= 0 ? 'text-green-600' : 'text-red-600';
            });
            
            const fee = totalGrossProfit > 0 ? totalGrossProfit * (settings.serviceFee / 100) : 0;
            const taxableProfit = totalGrossProfit > 0 ? totalGrossProfit - fee : 0;
            const tax = taxableProfit > 0 ? taxableProfit * (settings.taxRate / 100) : 0;
            const netProfit = totalGrossProfit - fee - tax;

            const footerRow = elements.comprehensiveTradesTableFooter.insertRow();
            footerRow.insertCell().colSpan = 3;
            footerRow.insertCell().innerHTML = `
                <div class="text-right">
                    <p>Total Gross Profit: <span class="${totalGrossProfit >= 0 ? 'text-green-600' : 'text-red-600'}">$${totalGrossProfit.toFixed(2)}</span></p>
                    <p>Service Fees: <span class="text-red-600">-$${fee.toFixed(2)}</span></p>
                    <p>Tax on Gains: <span class="text-red-600">-$${tax.toFixed(2)}</span></p>
                    <p class="font-bold border-t border-gray-300 mt-1 pt-1">Net Profit: <span class="${netProfit >= 0 ? 'text-green-600' : 'text-red-600'}">$${netProfit.toFixed(2)}</span></p>
                </div>
            `;
            
            elements.comprehensiveTradesTableContainer.classList.remove('hidden');
        } else {
            elements.comprehensiveTradesTableContainer.classList.add('hidden');
        }
    }

    function setupEventListeners() {
        elements.runSimulationBtn.addEventListener('click', runSimulation);
        elements.findOptimumBtn.addEventListener('click', () => findOptimum(false));
        elements.findComprehensiveOptimumBtn.addEventListener('click', () => findOptimum(true));
        
        const createHoverListener = (container, redrawFn, getHoverBox) => {
             if (!container) return;
             container.addEventListener('mousemove', e => {
                const rect = container.querySelector('canvas').getBoundingClientRect();
                redrawFn({x: e.clientX - rect.left, y: e.clientY - rect.top, box: getHoverBox()});
            });
            container.addEventListener('mouseout', () => {
                redrawFn(null);
                const hoverBox = getHoverBox();
                if(hoverBox) hideHoverBox(hoverBox);
            });
        };

        createHoverListener(elements.currentSimulationSection, drawCurrentCharts, () => elements.hoverInfoBox);
        createHoverListener(elements.rsiFilteredSimulationSection, drawRsiFilteredCharts, () => elements.rsiFilteredHoverInfoBox);

        createHoverListener(elements.optimumStrategyChartSection, (hover) => {
            if(!optimumStrategyData) return;
            drawChart(elements.optimumChartCanvas, optimumStrategyData.prices, optimumStrategyData.shortMA, optimumStrategyData.longMA, optimumStrategyData.bb, optimumStrategyData.signals, hover);
        }, () => elements.optimumHoverInfoBox);

        createHoverListener(elements.comprehensiveOptimumStrategyChartSection, (hover) => {
             if(!comprehensiveStrategyData) return;
            drawChart(elements.comprehensiveOptimumChartCanvas, comprehensiveStrategyData.prices, comprehensiveStrategyData.shortMA, comprehensiveStrategyData.longMA, comprehensiveStrategyData.bb, comprehensiveStrategyData.signals, hover);
        }, () => elements.comprehensiveHoverInfoBox);
    }

    async function initialize() {
        historicalPrices = await fetchCSV('./btc-usd-max.csv');
        if (historicalPrices.length > 0) {
            const lastDate = new Date(historicalPrices[historicalPrices.length - 1].date);
            elements.endDate.value = lastDate.toISOString().split('T')[0];
            const oneYearAgo = new Date(lastDate);
            oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
            elements.startDate.value = oneYearAgo.toISOString().split('T')[0];
            runSimulation();
        }
        setupEventListeners();
        window.addEventListener('resize', runSimulation);
    }

    initialize();
});
</script>
</body>
</html>
