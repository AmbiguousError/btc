<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 13.9 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USD Trading Opportunity Identifier with Risk Management</title>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%;
            height: auto;
        }
        #currentChartCanvas, #optimumChartCanvas, #comprehensiveOptimumChartCanvas, #rsiFilteredChartCanvas {
            aspect-ratio: 16 / 9;
             max-height: 450px;
        }
        #rsiChartCanvas, #rsiFilteredRsiChartCanvas, #volumeChartCanvas, #filteredVolumeChartCanvas {
            aspect-ratio: 16 / 5;
            max-height: 150px;
        }
        #patternChartCanvas {
            aspect-ratio: 16 / 9;
            max-height: 250px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
        }
        .input-group { display: flex; flex-direction: column; gap: 8px; }
        .input-group label, .checkbox-group label { font-weight: 600; color: #4a5568; }
        .input-group input[type="number"], .input-group input[type="date"], .input-group input[type="range"] {
            padding: 10px; border: 1px solid #cbd5e0; border-radius: 8px; font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input[type="range"] { padding: 0; }
        .input-group input:focus { outline: none; border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .btn-primary {
            background-color: #6366f1; color: white; padding: 12px 20px; border-radius: 8px; font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out; cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover { background-color: #4f46e5; transform: translateY(-1px); }
        .btn-secondary {
            background-color: #64748b;
        }
        .btn-secondary:hover {
             background-color: #475569;
        }
        .btn-ai {
            background-color: #8b5cf6; /* A nice purple */
        }
        .btn-ai:hover {
            background-color: #7c3aed;
        }
        .results-box { background-color: #edf2f7; border-radius: 10px; padding: 20px; border: 1px solid #d1d5db; }
        .explanation-box { background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; }
        .explanation-box h3, .results-box h3, .optimization-results h3 { font-size: 1.15rem; font-weight: 700; margin-bottom: 10px; color: #2d3748; }
        .explanation-box p, .results-box p, .optimization-results p { font-size: 0.95rem; line-height: 1.6; color: #4a5568; }
        .message-box { background-color: #fefcbf; border: 1px solid #fbd38d; color: #92400e; padding: 15px; border-radius: 8px; margin-top: 15px; font-weight: 500; text-align: center; }
        .error-message { background-color: #fed7d7; border-color: #fc8181; color: #c53030; }
        .warning-message { background-color: #ffe8d1; border: 1px solid #ffcc80; color: #a0522d; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid #6366f1; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 0 auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hover-info-box { background-color: #1a202c; color: #fff; padding: 8px 12px; border-radius: 5px; font-size: 0.875rem; position: absolute; z-index: 10; pointer-events: none; white-space: nowrap; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none; }
        .chart-section { border: 1px solid #e2e8f0; border-radius: 15px; padding: 20px; background-color: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .optimization-results { background-color: #e0f2fe; border-radius: 10px; padding: 20px; border: 1px solid #90cdf4; margin-top: 20px; }
        .data-preview-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.85rem; text-align: left; }
        .data-preview-table th, .data-preview-table td { border: 1px solid #e2e8f0; padding: 8px 12px; }
        .data-preview-table th { background-color: #e9eef4; font-weight: 600; color: #4a5568; }
        .ai-analysis-box {
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        .ai-analysis-box h4 {
            font-size: 1.1rem;
            font-weight: 700;
            color: #0c4a6e;
            margin-bottom: 10px;
        }
         .ai-analysis-box p {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #374151;
        }
        .description-box {
            background-color: #f7fafc;
            border-left: 4px solid #6366f1;
            padding: 12px 16px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #4a5568;
        }
        .pattern-chart-container {
            padding: 16px;
            margin-top: 1rem;
            background-color: #fdfdff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">BTC/USD Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses historical BTC/USD data, a Moving Average Crossover strategy, and an optional RSI filter to find and optimize trading signals.
        </p>

        <div class="explanation-box">
            <h3>How Signals Are Calculated</h3>
            <p>This model combines multiple technical indicators and risk management rules to generate buy and sell signals.</p>
            <ul class="list-disc pl-5 mt-2 space-y-1">
                <li><strong>1. Moving Average (MA) Crossover:</strong> The core signal. A "Golden Cross" (short MA over long MA) is a buy signal, while a "Death Cross" is a sell signal.</li>
                <li><strong>2. Risk Management (Highest Priority):</strong> These rules override all other signals.
                     <ul class="list-disc pl-6 mt-1">
                        <li><strong>Stop-Loss & Take-Profit:</strong> If enabled, a position is sold if the price hits a fixed percentage below (Stop-Loss) or above (Take-Profit) the entry price.</li>
                        <li><strong>Trailing Stop-Loss:</strong> A more dynamic rule. If enabled, the sell price moves up as the price rises. A position is sold if the price drops by the specified percentage from its *highest point* since the trade was opened. This is designed to protect profits.</li>
                    </ul>
                </li>
                <li><strong>3. Optional Confirmation Filters:</strong> If enabled, these add extra conditions to the MA crossover signals. A valid signal only occurs when the MA crossover happens *and* all enabled filter conditions are met simultaneously.
                    <ul class="list-disc pl-6 mt-1">
                        <li><strong>RSI Filter:</strong> A buy requires RSI to be below the overbought level; a sell requires it to be above the oversold level.</li>
                        <li><strong>Bollinger Bands (BB) Filter:</strong> A buy requires the price to be below the middle BB line (the BB's own moving average); a sell requires it to be above. This acts as a 'mean reversion' check.</li>
                        <li><strong>Volume Filter:</strong> A signal requires the volume to be above its recent moving average.</li>
                    </ul>
                </li>
            </ul>
        </div>
        
        <div class="date-range-section grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
             <div>
                <h3 class="text-xl font-semibold mb-2 text-gray-700">Date Range Selection</h3>
                <p class="description-box">Use the slider for quick presets or select dates manually.</p>
                <div class="input-group">
                    <label for="dateRangeSlider">Timeframe: <span id="dateRangeLabel" class="font-normal text-gray-500"></span></label>
                    <input type="range" id="dateRangeSlider" min="0" max="8" value="5" class="w-full">
                </div>
                <div class="input-group mt-2"><label for="startDate">Start Date:</label><input type="date" id="startDate"></div>
            </div>
            <div>
                <h3 class="text-xl font-semibold mb-2 text-gray-700">&nbsp;</h3>
                 <p class="description-box">&nbsp;</p>
                 <div class="input-group mt-2"><label for="endDate">End Date:</label><input type="date" id="endDate"></div>
            </div>
        </div>

        <div class="border-t border-gray-200 pt-6">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Strategy Parameters</h2>
                <button id="resetToDefaultsBtn" class="btn-primary btn-secondary text-sm">Reset</button>
            </div>
             <p class="description-box">
                This is the main control panel for your trading strategy. Adjust these values to define how the simulation should run.
                <br><strong>Initial Investment:</strong> The starting amount in USD.
                <br><strong>Tax/Service Fee:</strong> Percentages deducted from profits.
                <br><strong>MA/RSI/BB/Volume Periods:</strong> The number of data points (days) used to calculate these indicators. Shorter periods are more sensitive to recent price changes.
                <br><strong>Checkboxes:</strong> Enable or disable risk management and various indicator filters to see how they affect performance.
            </p>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="input-group"><label for="initialInvestment">Initial Investment ($):</label><input type="number" id="initialInvestment" value="100" min="1"></div>
                <div class="input-group"><label for="taxRate">Tax Rate (%):</label><input type="number" id="taxRate" value="28" min="0" max="100"></div>
                <div class="input-group"><label for="serviceFee">Service Fee (%):</label><input type="number" id="serviceFee" value="5" min="0" max="10" step="0.1"></div>
                <div class="input-group"><label for="shortMA">Short MA Period:</label><input type="number" id="shortMA" value="2" min="2"></div>
                <div class="input-group"><label for="longMA">Long MA Period:</label><input type="number" id="longMA" value="5" min="3"></div>
                <div class="input-group"><label for="rsiPeriod">RSI Period:</label><input type="number" id="rsiPeriod" value="14" min="2"></div>
                <div class="input-group"><label for="rsiOverbought">RSI Overbought:</label><input type="number" id="rsiOverbought" value="70" min="51"></div>
                <div class="input-group"><label for="rsiOversold">RSI Oversold:</label><input type="number" id="rsiOversold" value="30" max="49"></div>
                <div class="input-group"><label for="bbPeriod">BB Period:</label><input type="number" id="bbPeriod" value="20" min="2"></div>
                <div class="input-group"><label for="bbStdDev">BB Std Dev:</label><input type="number" id="bbStdDev" value="2" min="1" step="0.1"></div>
                <div class="input-group"><label for="volumeMAPeriod">Volume MA Period:</label><input type="number" id="volumeMAPeriod" value="20" min="2"></div>
                <div class="input-group"><label for="stopLoss">Stop-Loss (%):</label><input type="number" id="stopLoss" value="5" min="0.1" step="0.1"></div>
                <div class="input-group"><label for="takeProfit">Take-Profit (%):</label><input type="number" id="takeProfit" value="15" min="0.1" step="0.1"></div>
                <div class="input-group"><label for="trailingStopLoss">Trailing SL (%):</label><input type="number" id="trailingStopLoss" value="10" min="0.1" step="0.1"></div>


                <div class="checkbox-group mt-4 col-span-2 md:col-span-4 flex-wrap">
                    <input type="checkbox" id="useSLTP" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useSLTP" class="mr-4">Use Fixed SL/TP</label>
                    <input type="checkbox" id="useTrailingStopLoss" class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useTrailingStopLoss" class="mr-4">Use Trailing SL</label>
                    <input type="checkbox" id="useRsiFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useRsiFilter" class="mr-4">Use RSI Filter</label>
                     <input type="checkbox" id="useBBFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useBBFilter" class="mr-4">Use BB Filter</label>
                    <input type="checkbox" id="useVolumeFilter" checked class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="useVolumeFilter">Use Volume Filter</label>
                </div>
            </div>
             <p class="description-box mt-4"><strong>Run Simulation Button:</strong> Click this to execute a single simulation using the parameters you've set above. The charts below will update to reflect the results of this specific strategy.</p>
            <button id="runSimulationBtn" class="btn-primary w-full mt-2">Run Simulation</button>
        </div>

        <div id="dataPreviewSection" class="results-box hidden">
            <h3>Data Preview for Selected Range:</h3>
            <table class="data-preview-table"><tbody id="dataPreviewTableBody"></tbody></table>
        </div>
        
        <div id="currentSimulationSection" class="chart-section mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Current Strategy Simulation</h2>
            <p class="description-box">This section visualizes the performance of the strategy defined in the 'Strategy Parameters' section. The main chart shows the BTC price, moving averages, and buy/sell signals. The smaller charts below display the corresponding RSI and Volume data for the same period.</p>
            <div id="loadingSpinner" class="loading-spinner"></div>
            <canvas id="currentChartCanvas"></canvas>
            <canvas id="rsiChartCanvas" class="mt-4"></canvas>
            <canvas id="volumeChartCanvas" class="mt-4"></canvas>
            <div id="hoverInfoBox" class="hover-info-box"></div>
            <div id="currentSimulationResults" class="results-box hidden mt-4"></div>
            <div id="currentTransactionsContainer" class="mt-4"></div>
            <div id="currentNextDayAnalysisContainer" class="results-box mt-4 hidden"></div>
        </div>

        <div id="rsiFilteredSimulationSection" class="chart-section mt-6 border-t-4 border-indigo-300 pt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Fully-Filtered Strategy Simulation</h2>
             <p class="description-box">This chart provides a direct comparison by running the exact same simulation as above, but with <strong>all filters (RSI, Bollinger Bands, Volume) forcibly enabled</strong>. This helps you quickly assess the impact of adding these confirmation layers to your base MA-crossover strategy.</p>
            <canvas id="rsiFilteredChartCanvas"></canvas>
            <canvas id="rsiFilteredRsiChartCanvas" class="mt-4"></canvas>
            <canvas id="filteredVolumeChartCanvas" class="mt-4"></canvas>
            <div id="rsiFilteredHoverInfoBox" class="hover-info-box"></div>
            <div id="rsiFilteredSimulationResults" class="results-box hidden mt-4"></div>
            <div id="rsiFilteredTransactionsContainer" class="mt-4"></div>
            <div id="filteredNextDayAnalysisContainer" class="results-box mt-4 hidden"></div>
        </div>

        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Manual Strategy Optimization</h2>
            <p class="description-box">Instead of testing one strategy at a time, this tool lets you find the best performing Moving Average combination within a range you define. It will test every short MA period against every long MA period in the ranges below. The filters used for this optimization are based on what is currently selected in the 'Strategy Parameters' section above.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="input-group"><label for="minShortMA">Min Short MA:</label><input type="number" id="minShortMA" value="2"></div>
                <div class="input-group"><label for="maxShortMA">Max Short MA:</label><input type="number" id="maxShortMA" value="10"></div>
                <div class="input-group"><label for="minLongMA">Min Long MA:</label><input type="number" id="minLongMA" value="11"></div>
                <div class="input-group"><label for="maxLongMA">Max Long MA:</label><input type="number" id="maxLongMA" value="30"></div>
            </div>
             <p class="description-box mt-4"><strong>Find Optimum Strategy Button:</strong> Click this to start the optimization process based on the MA ranges you entered. The system will find the most profitable combination and display the results.</p>
            <button id="findOptimumBtn" class="btn-primary w-full mt-2">Find Optimum Strategy</button>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden mt-4"></div>
            <div id="optimumStrategyChartSection" class="chart-section mt-4 hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-2 text-center">Optimum Strategy Chart</h3>
                <p class="description-box">This chart visualizes the performance of the best strategy found during the manual optimization process.</p>
                <canvas id="optimumChartCanvas"></canvas>
                <div id="optimumHoverInfoBox" class="hover-info-box"></div>
                <div id="optimumTransactionsContainer" class="mt-4"></div>
            </div>
        </div>

        <div class="comprehensive-optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Comprehensive Strategy Optimization</h2>
            <p class="description-box">This is the most powerful tool. It performs an exhaustive search (a "grid search") by testing every possible combination of the parameters below to find the absolute best-performing strategy.
                <br>• <b>MA Periods:</b> Short (2-60) vs. Long (up to 120).
                <br>• <b>Filter Combinations:</b> All 32 on/off combinations of the 5 filters.
                <br>• <b>Trailing SL %:</b> A range of values (1%, 3%, 5%, 10%, 15%, 20%) are tested if Trailing SL is active.
                <br><b>Note:</b> For other filters (Fixed SL/TP, RSI, etc.), the optimization tests their on/off state but uses the single value set in the main "Strategy Parameters" panel. Optimizing their values is a potential future enhancement.
            </p>
            <p class="description-box mt-4"><strong>Find Comprehensive Optimum Strategy Button:</strong> Click to begin the intensive search. This may take a few moments. The results will include the best parameters, filter settings, performance metrics, and a detailed trade log.</p>
            <button id="findComprehensiveOptimumBtn" class="btn-primary w-full mt-2">Find Comprehensive Optimum Strategy</button>
            <div id="comprehensiveOptimizationSpinner" class="loading-spinner"></div>
            <div id="comprehensiveOptimizationProgress" class="text-sm text-gray-600 text-center mt-2"></div>
            <div id="comprehensiveOptimizationResults" class="optimization-results hidden mt-4"></div>
            <div id="comprehensiveOptimumStrategyChartSection" class="chart-section mt-4 hidden">
                 <h3 class="text-xl font-bold text-gray-800 mb-2 text-center">Comprehensive Optimum Strategy Chart</h3>
                <p class="description-box">This chart visualizes the single best strategy found by the comprehensive optimization. Below, you can get an AI analysis of this strategy and see a detailed log of every trade it made.</p>
                <canvas id="comprehensiveOptimumChartCanvas"></canvas>
                <div id="comprehensiveOptimumHoverInfoBox" class="hover-info-box"></div>
                 <div id="aiAnalysisContainer" class="mt-4 hidden">
                     <p class="description-box"><strong>Analyze Optimum Strategy with AI Button:</strong> After finding the comprehensive optimum strategy, click this button to send the results to a generative AI. It will provide a qualitative analysis of the strategy's characteristics, potential strengths, and weaknesses based on its performance.</p>
                    <button id="analyzeStrategyBtn" class="btn-primary btn-ai w-full mt-2">✨ Analyze Optimum Strategy with AI</button>
                    <div id="aiAnalysisResultBox" class="ai-analysis-box hidden mt-4"></div>
                </div>
                <div id="comprehensiveTradesTableContainer" class="mt-4"></div>
                 <div id="comprehensiveTradesSummaryContainer" class="results-box mt-4 hidden"></div>
                 <div id="comprehensiveNextDayAnalysisContainer" class="results-box mt-4 hidden"></div>
                 <div id="comprehensivePracticalExamples" class="explanation-box mt-4 hidden"></div>
            </div>
        </div>

        <div class="explanation-box mt-6">
            <h3>Advanced Analysis: Combining Patterns with Quantitative Signals</h3>
            <p>While this tool focuses on quantitative signals (mathematical calculations like moving averages), many traders combine this with qualitative analysis, such as identifying chart patterns. The theory is that since markets are driven by human psychology, emotional buying and selling can create recognizable, repeating shapes in the price chart.</p>
            
            <h4 class="text-lg font-semibold mt-4 mb-2">Classic Chart Patterns (Fractal Analysis)</h4>
            <p>These are examples of recurring shapes that traders watch for. Use the dropdown below to see an idealized visualization of each pattern.</p>
             <div class="pattern-chart-container">
                <label for="patternSelector" class="font-semibold text-gray-700">Visualize a Pattern:</label>
                <select id="patternSelector" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option value="headAndShoulders">Head and Shoulders</option>
                    <option value="inverseHeadAndShoulders">Inverse Head and Shoulders</option>
                    <option value="cupAndHandle">Cup and Handle</option>
                    <option value="doubleTop">Double Top</option>
                    <option value="doubleBottom">Double Bottom</option>
                    <option value="ascendingTriangle">Ascending Triangle</option>
                    <option value="descendingTriangle">Descending Triangle</option>
                </select>
                <canvas id="patternChartCanvas" class="mt-4"></canvas>
            </div>
            <ul class="list-disc pl-6 mt-4">
                <li><strong>Head and Shoulders:</strong> A bearish pattern that can signal a trend reversal from up to down.</li>
                <li><strong>Inverse Head and Shoulders:</strong> A bullish pattern suggesting a reversal from down to up.</li>
                <li><strong>Cup and Handle:</strong> A bullish continuation pattern that often signals a consolidation period followed by an upward breakout.</li>
                <li><strong>Double Top / Double Bottom:</strong> Reversal patterns that suggest a trend is losing momentum and may reverse.</li>
                <li><strong>Triangles (Ascending, Descending, Symmetrical):</strong> These often signal a period of indecision before the price breaks out, typically in the direction of the preceding trend.</li>
            </ul>

            <h4 class="text-lg font-semibold mt-4 mb-2">A Powerful Combined Workflow</h4>
            <p>You can use this tool to add data-driven evidence to your visual pattern analysis:</p>
            <ol class="list-decimal pl-6 mt-1 space-y-2">
                <li><strong>Visual Identification:</strong> First, you visually identify a potential pattern (e.g., a "Cup and Handle") forming on a live chart. This forms your trading hypothesis.</li>
                <li><strong>Historical Validation:</strong> Find a past instance where a similar pattern occurred. Use the <strong>Date Range Selection</strong> in this tool to isolate that historical period.</li>
                <li><strong>Quantitative Analysis:</strong> Run the <strong>"Comprehensive Strategy Optimization"</strong> for that specific historical timeframe. The tool will find the most profitable quantitative signals (MA periods, filters, etc.) that worked *during that specific pattern*.</li>
                <li><strong>Apply to the Present:</strong> You now have a concrete, data-backed strategy (e.g., "a 12/26 day MA crossover with a volume filter"). You can watch the current, live pattern and use the exact signals found by the tool as your confirmation to enter or exit a trade. This combines the "what" (the visual pattern) with the "when" (the data-driven signal).</li>
            </ol>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    // --- Global Variables ---
    let historicalPrices = [];
    let filteredPrices = [];
    let currentStrategyData = null;
    let rsiFilteredStrategyData = null;
    let optimumStrategyData = null;
    let comprehensiveStrategyData = null;
    let defaultSettings = {};
    const patternData = {
        headAndShoulders: {
            name: 'Head & Shoulders (Bearish Reversal)',
            data: [20, 25, 30, 25, 40, 25, 30, 25, 20, 15, 10]
        },
        inverseHeadAndShoulders: {
            name: 'Inverse Head & Shoulders (Bullish Reversal)',
            data: [30, 25, 20, 25, 10, 25, 20, 25, 30, 35, 40]
        },
        cupAndHandle: {
            name: 'Cup & Handle (Bullish Continuation)',
            data: [40, 30, 20, 15, 13, 15, 20, 30, 40, 35, 37, 36, 45, 50]
        },
        doubleTop: {
            name: 'Double Top (Bearish Reversal)',
            data: [10, 20, 40, 20, 40, 20, 10]
        },
        doubleBottom: {
            name: 'Double Bottom (Bullish Reversal)',
            data: [40, 20, 10, 20, 10, 20, 40]
        },
        ascendingTriangle: {
            name: 'Ascending Triangle (Bullish)',
            data: [10, 30, 15, 30, 20, 30, 25, 30, 35, 40]
        },
        descendingTriangle: {
            name: 'Descending Triangle (Bearish)',
            data: [40, 10, 35, 10, 30, 10, 25, 10, 5, 0]
        }
    };
    const dateRanges = [
        { label: 'Last Week', days: 7 },
        { label: 'Last Month', days: 30 },
        { label: 'Last 3 Months', days: 90 },
        { label: 'Last 6 Months', days: 180 },
        { label: 'Last 9 Months', days: 270 },
        { label: 'Last Year', days: 365 },
        { label: 'Last 3 Years', days: 365 * 3 },
        { label: 'Last 5 Years', days: 365 * 5 },
        { label: 'Max', days: Infinity },
        { label: 'Custom', days: null },
    ];

    // --- DOM Element Cache ---
    const elements = {
        // Canvases
        currentChartCanvas: document.getElementById('currentChartCanvas'),
        rsiChartCanvas: document.getElementById('rsiChartCanvas'),
        volumeChartCanvas: document.getElementById('volumeChartCanvas'),
        rsiFilteredChartCanvas: document.getElementById('rsiFilteredChartCanvas'),
        rsiFilteredRsiChartCanvas: document.getElementById('rsiFilteredRsiChartCanvas'),
        filteredVolumeChartCanvas: document.getElementById('filteredVolumeChartCanvas'),
        optimumChartCanvas: document.getElementById('optimumChartCanvas'),
        comprehensiveOptimumChartCanvas: document.getElementById('comprehensiveOptimumChartCanvas'),
        patternChartCanvas: document.getElementById('patternChartCanvas'),
        // Inputs & Selectors
        startDate: document.getElementById('startDate'),
        endDate: document.getElementById('endDate'),
        dateRangeSlider: document.getElementById('dateRangeSlider'),
        dateRangeLabel: document.getElementById('dateRangeLabel'),
        initialInvestment: document.getElementById('initialInvestment'),
        taxRate: document.getElementById('taxRate'),
        serviceFee: document.getElementById('serviceFee'),
        shortMA: document.getElementById('shortMA'),
        longMA: document.getElementById('longMA'),
        rsiPeriod: document.getElementById('rsiPeriod'),
        rsiOverbought: document.getElementById('rsiOverbought'),
        rsiOversold: document.getElementById('rsiOversold'),
        useRsiFilter: document.getElementById('useRsiFilter'),
        bbPeriod: document.getElementById('bbPeriod'),
        bbStdDev: document.getElementById('bbStdDev'),
        useBBFilter: document.getElementById('useBBFilter'),
        volumeMAPeriod: document.getElementById('volumeMAPeriod'),
        useVolumeFilter: document.getElementById('useVolumeFilter'),
        stopLoss: document.getElementById('stopLoss'),
        takeProfit: document.getElementById('takeProfit'),
        useSLTP: document.getElementById('useSLTP'),
        trailingStopLoss: document.getElementById('trailingStopLoss'),
        useTrailingStopLoss: document.getElementById('useTrailingStopLoss'),
        minShortMA: document.getElementById('minShortMA'),
        maxShortMA: document.getElementById('maxShortMA'),
        minLongMA: document.getElementById('minLongMA'),
        maxLongMA: document.getElementById('maxLongMA'),
        patternSelector: document.getElementById('patternSelector'),
        // Buttons
        runSimulationBtn: document.getElementById('runSimulationBtn'),
        resetToDefaultsBtn: document.getElementById('resetToDefaultsBtn'),
        findOptimumBtn: document.getElementById('findOptimumBtn'),
        findComprehensiveOptimumBtn: document.getElementById('findComprehensiveOptimumBtn'),
        // Spinners
        loadingSpinner: document.getElementById('loadingSpinner'),
        optimizationSpinner: document.getElementById('optimizationSpinner'),
        comprehensiveOptimizationSpinner: document.getElementById('comprehensiveOptimizationSpinner'),
        // Results & Info
        dataPreviewSection: document.getElementById('dataPreviewSection'),
        dataPreviewTableBody: document.getElementById('dataPreviewTableBody'),
        currentSimulationResults: document.getElementById('currentSimulationResults'),
        rsiFilteredSimulationResults: document.getElementById('rsiFilteredSimulationResults'),
        optimizationResults: document.getElementById('optimizationResults'),
        comprehensiveOptimizationResults: document.getElementById('comprehensiveOptimizationResults'),
        comprehensiveOptimizationProgress: document.getElementById('comprehensiveOptimizationProgress'),
        currentSimulationSection: document.getElementById('currentSimulationSection'),
        rsiFilteredSimulationSection: document.getElementById('rsiFilteredSimulationSection'),
        optimumStrategyChartSection: document.getElementById('optimumStrategyChartSection'),
        comprehensiveOptimumStrategyChartSection: document.getElementById('comprehensiveOptimumStrategyChartSection'),
        // Transaction Table Containers
        currentTransactionsContainer: document.getElementById('currentTransactionsContainer'),
        rsiFilteredTransactionsContainer: document.getElementById('rsiFilteredTransactionsContainer'),
        optimumTransactionsContainer: document.getElementById('optimumTransactionsContainer'),
        comprehensiveTradesTableContainer: document.getElementById('comprehensiveTradesTableContainer'),
        comprehensiveTradesSummaryContainer: document.getElementById('comprehensiveTradesSummaryContainer'),
        // Next Day Analysis Containers
        comprehensiveNextDayAnalysisContainer: document.getElementById('comprehensiveNextDayAnalysisContainer'),
        currentNextDayAnalysisContainer: document.getElementById('currentNextDayAnalysisContainer'),
        filteredNextDayAnalysisContainer: document.getElementById('filteredNextDayAnalysisContainer'),
        comprehensivePracticalExamples: document.getElementById('comprehensivePracticalExamples'),
        // Hover Boxes
        hoverInfoBox: document.getElementById('hoverInfoBox'),
        rsiFilteredHoverInfoBox: document.getElementById('rsiFilteredHoverInfoBox'),
        optimumHoverInfoBox: document.getElementById('optimumHoverInfoBox'),
        comprehensiveOptimumHoverInfoBox: document.getElementById('comprehensiveOptimumHoverInfoBox'),
        // AI elements
        aiAnalysisContainer: document.getElementById('aiAnalysisContainer'),
        analyzeStrategyBtn: document.getElementById('analyzeStrategyBtn'),
        aiAnalysisResultBox: document.getElementById('aiAnalysisResultBox'),
    };

    // --- Helper Functions ---
    const showSpinner = spinner => spinner.style.display = 'block';
    const hideSpinner = spinner => spinner.style.display = 'none';

    function formatNumber(num, decimals = 2) {
        if (typeof num !== 'number' || isNaN(num)) return 'N/A';
        return num.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }
    
    function showResults(container, content) {
        container.innerHTML = content;
        container.classList.remove('hidden');
    }
    
    // --- Data Handling ---
    async function fetchCSV(filePath) {
        showSpinner(elements.loadingSpinner);
        try {
            const response = await fetch(filePath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const csvText = await response.text();
            return parseCSV(csvText);
        } catch (error) {
            showResults(elements.currentSimulationResults, `<div class="error-message">Failed to load data: ${error.message}.</div>`);
            return [];
        } finally {
            hideSpinner(elements.loadingSpinner);
        }
    }

    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        const closePriceIndex = headers.indexOf('price');
        const dateIndex = headers.indexOf('snapped_at');
        const volumeIndex = headers.indexOf('total_volume');
        if (closePriceIndex === -1 || dateIndex === -1) throw new Error('CSV missing "price" or "snapped_at" column.');
        if(volumeIndex === -1) console.warn("Volume data not found in CSV. Volume filter will be disabled.");

        return lines.slice(1).map(line => {
            const cols = line.split(',');
            const price = parseFloat(cols[closePriceIndex]);
            const date = cols[dateIndex]?.replace(/"/g, '').replace(' UTC', '');
            const volume = volumeIndex > -1 ? parseFloat(cols[volumeIndex]) : 0;
            return !isNaN(price) && date ? { price, date, volume } : null;
        }).filter(Boolean);
    }
    
    function filterDataByDateRange(data, startDate, endDate) {
        const start = startDate ? new Date(startDate).getTime() : -Infinity;
        const end = endDate ? new Date(endDate).getTime() : Infinity;
        return data.filter(p => {
            const pointDate = new Date(p.date).getTime();
            return pointDate >= start && pointDate <= end;
        });
    }

    function updateDataPreviewTable(data) {
        elements.dataPreviewTableBody.innerHTML = '';
        if (data.length === 0) {
            elements.dataPreviewSection.classList.add('hidden');
            return;
        }
        const previewData = [...data.slice(0, 5)];
        if (data.length > 10) {
            previewData.push(null);
            previewData.push(...data.slice(data.length - 5));
        } else if (data.length > 5) {
            previewData.push(...data.slice(5));
        }

        previewData.forEach(rowData => {
            const row = elements.dataPreviewTableBody.insertRow();
            if (rowData === null) {
                const cell = row.insertCell();
                cell.colSpan = 2;
                cell.textContent = '...';
                cell.style.textAlign = 'center';
            } else {
                row.insertCell().textContent = new Date(rowData.date).toLocaleDateString();
                row.insertCell().textContent = `$${formatNumber(rowData.price)}`;
            }
        });
        elements.dataPreviewSection.classList.remove('hidden');
    }

    // --- Technical Analysis Calculations ---
    const calculateSMA = (data, period, key = 'price') => {
        const sma = Array(data.length).fill(null);
        for (let i = period - 1; i < data.length; i++) {
            sma[i] = data.slice(i - period + 1, i + 1).reduce((sum, d) => sum + d[key], 0) / period;
        }
        return sma;
    };
    
    const calculateRSI = (data, period) => {
        const rsi = Array(data.length).fill(null);
        if (period >= data.length) return rsi;
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const change = data[i].price - data[i - 1].price;
            change > 0 ? gains += change : losses -= change;
        }
        let avgGain = gains / period, avgLoss = losses / period;
        rsi[period] = 100 - (100 / (1 + (avgGain / avgLoss)));

        for (let i = period + 1; i < data.length; i++) {
            const change = data[i].price - data[i - 1].price;
            avgGain = (avgGain * (period - 1) + (change > 0 ? change : 0)) / period;
            avgLoss = (avgLoss * (period - 1) + (change < 0 ? -change : 0)) / period;
            rsi[i] = 100 - (100 / (1 + (avgLoss === 0 ? Infinity : avgGain / avgLoss)));
        }
        return rsi;
    };

    function calculateBollingerBands(data, period, stdDevMultiplier) {
        const middle = Array(data.length).fill(null);
        const upper = Array(data.length).fill(null);
        const lower = Array(data.length).fill(null);

        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1).map(d => d.price);
            const sma = slice.reduce((sum, val) => sum + val, 0) / period;
            const stdDev = Math.sqrt(slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period);
            
            middle[i] = sma;
            upper[i] = sma + (stdDev * stdDevMultiplier);
            lower[i] = sma - (stdDev * stdDevMultiplier);
        }
        return { middle, upper, lower };
    }

    function calculateStrategyPerformance(prices, shortMA, longMA, rsi, bb, volumeSMA, settings) {
        let cash = settings.initialInvestment;
        let btc = 0;
        let signals = [];
        let entryPrice = 0;
        let highWaterMark = 0;

        for (let i = 1; i < prices.length; i++) {
            const price = prices[i].price;
            const volume = prices[i].volume;
            
            if (btc > 0) { // In a position, check for sell conditions
                highWaterMark = Math.max(highWaterMark, price);
                let sellReason = null;
                
                // Risk management rules take priority
                if (settings.useSLTP) {
                    const stopLossPrice = entryPrice * (1 - settings.stopLoss / 100);
                    if (price <= stopLossPrice) sellReason = 'stop_loss';
                    const takeProfitPrice = entryPrice * (1 + settings.takeProfit / 100);
                    if (price >= takeProfitPrice) sellReason = 'take_profit';
                }
                if (!sellReason && settings.useTrailingStopLoss) {
                    const trailingStopPrice = highWaterMark * (1 - settings.trailingStopLoss / 100);
                    if (price <= trailingStopPrice) sellReason = 'trailing_stop_loss';
                }

                // If not triggered by risk management, check indicator signals
                if (!sellReason) { 
                    const deathCross = shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i];
                    const bbConditionSell = !settings.useBBFilter || price > bb.middle[i];
                    const volumeCondition = !settings.useVolumeFilter || volume > volumeSMA[i];
                    if(deathCross && bbConditionSell && volumeCondition) {
                        sellReason = 'death_cross';
                    }
                }

                if(sellReason){
                    cash = btc * price;
                    const buySignal = signals.filter(s => s.type === 'buy').pop();
                    const grossProfit = cash - (buySignal.btc * buySignal.price);
                    signals.push({ index: i, type: 'sell', price, grossProfit, reason: sellReason, btc });
                    btc = 0;
                }

            } else { // Not in a position, check for buy conditions
                const goldenCross = shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i];
                const rsiCondition = !settings.useRsiFilter || rsi[i] < settings.rsiOverbought;
                const bbConditionBuy = !settings.useBBFilter || price < bb.middle[i];
                const volumeCondition = !settings.useVolumeFilter || volume > volumeSMA[i];
                
                if (goldenCross && cash > 0 && rsiCondition && bbConditionBuy && volumeCondition) {
                    btc = cash / price;
                    entryPrice = price;
                    highWaterMark = price; // Reset high water mark on new buy
                    signals.push({ index: i, type: 'buy', price, btc });
                    cash = 0;
                }
            }
        }
        
        const inPositionAtEnd = btc > 0;
        let finalValue = inPositionAtEnd ? btc * prices[prices.length - 1].price : cash;
        
        const totalProfit = finalValue - settings.initialInvestment;
        let finalNetValue = finalValue;

        if (totalProfit > 0) {
            const fee = totalProfit * (settings.serviceFee / 100);
            const taxableProfit = totalProfit - fee;
            const tax = taxableProfit > 0 ? taxableProfit * (settings.taxRate / 100) : 0;
            finalNetValue = finalValue - fee - tax;
        }
        
        return { signals, finalValue: finalNetValue, preTaxFinalValue: finalValue, inPositionAtEnd: inPositionAtEnd };
    }


    // --- Charting ---
    function setupCanvas(canvas) {
        if (!canvas) return { ctx: null, width: 0, height: 0 };
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        return { ctx, width: rect.width, height: rect.height };
    }

    function drawPatternChart(data, title) {
        const canvas = elements.patternChartCanvas;
        const { ctx, width, height } = setupCanvas(canvas);
        ctx.clearRect(0, 0, width, height);
        
        if (!data || data.length === 0) return;

        let min = Math.min(...data), max = Math.max(...data);
        const padding = (max - min) * 0.2; // More padding for visual clarity
        min -= padding;
        max += padding;

        const xScale = width / (data.length -1 || 1);
        const yScale = height / (max - min || 1);
        const getX = i => i * xScale;
        const getY = price => height - ((price - min) * yScale);

        // Draw line
        const points = data.map((d, i) => ({ x: getX(i), y: getY(d) }));
        drawDataLine(ctx, points, '#6366f1', 2);

        // Draw Title
        ctx.font = 'bold 14px Inter';
        ctx.fillStyle = '#374151';
        ctx.textAlign = 'center';
        ctx.fillText(title, width / 2, 20);
    }

    function drawChart(canvas, pricesData, shortMA, longMA, bb, signals, settings, hoverInfo, triggers) {
        const { ctx, width, height } = setupCanvas(canvas);
        ctx.clearRect(0, 0, width, height);

        const prices = pricesData.map(d => d.price);
        const allValues = [...prices, ...shortMA, ...longMA, ...bb.upper, ...bb.lower].filter(v => v !== null);
        if (allValues.length === 0) return;
        
        let min = Math.min(...allValues), max = Math.max(...allValues);
        const padding = (max - min) * 0.1;
        min -= padding; max += padding;

        const xScale = width / (prices.length -1 || 1);
        const yScale = height / (max - min || 1);
        const getX = i => i * xScale;
        const getY = price => height - ((price - min) * yScale);
        
        // Bollinger Bands Area
        ctx.fillStyle = 'rgba(165, 180, 252, 0.1)'; 
        const upperPoints = bb.upper.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}).filter(Boolean);
        const lowerPoints = bb.lower.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}).filter(Boolean).reverse();
        
        if (upperPoints.length > 0 && lowerPoints.length > 0) {
            ctx.beginPath();
            ctx.moveTo(upperPoints[0].x, upperPoints[0].y);
            upperPoints.forEach(p => ctx.lineTo(p.x, p.y));
            lowerPoints.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();
        }

        drawChartDetails(ctx, width, height, min, max, getX, pricesData, settings);

        const createPoints = (data, yFunc) => data.map((d, i) => d === null ? null : {x: getX(i), y: yFunc(d)});
        drawDataLine(ctx, createPoints(prices, getY), '#3b82f6', 2);
        drawDataLine(ctx, createPoints(shortMA, getY), '#ef4444', 1.5);
        drawDataLine(ctx, createPoints(longMA, getY), '#10b981', 1.5);
        drawDataLine(ctx, createPoints(bb.middle, getY), '#a78bfa', 1, true);
        
        // Bollinger Bands Lines
        drawDataLine(ctx, createPoints(bb.upper, getY), 'rgba(129, 140, 248, 0.5)', 1, true); 
        drawDataLine(ctx, createPoints(bb.lower, getY), 'rgba(129, 140, 248, 0.5)', 1, true); 
        
        let lastBuySignal = null;
        signals.forEach(s => {
            const x = getX(s.index);
            const y = getY(s.price);
            
            if (s.type === 'buy') {
                lastBuySignal = s;
                ctx.beginPath();
                ctx.fillStyle = '#22c55e'; // Solid Green circle for buy
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
            } else if (s.type === 'sell') {
                if (lastBuySignal && settings.useSLTP) {
                    const stopLossLevel = getY(lastBuySignal.price * (1 - settings.stopLoss / 100));
                    const takeProfitLevel = getY(lastBuySignal.price * (1 + settings.takeProfit / 100));
                    drawDataLine(ctx, [{x: getX(lastBuySignal.index), y: stopLossLevel}, {x: x, y: stopLossLevel}], '#ef4444', 1, true);
                    drawDataLine(ctx, [{x: getX(lastBuySignal.index), y: takeProfitLevel}, {x: x, y: takeProfitLevel}], '#22c55e', 1, true);
                    lastBuySignal = null;
                }

                ctx.beginPath();
                if (s.reason === 'stop_loss' || s.reason === 'trailing_stop_loss') {
                    ctx.fillStyle = '#ef4444'; // Red triangle
                    ctx.moveTo(x, y + 6); ctx.lineTo(x-6, y-3); ctx.lineTo(x+6, y-3); ctx.closePath();
                } else if (s.reason === 'take_profit') {
                    ctx.fillStyle = '#22c55e'; // Green triangle
                    ctx.moveTo(x, y - 6); ctx.lineTo(x-6, y+3); ctx.lineTo(x+6, y+3); ctx.closePath();
                } else { // death_cross
                    ctx.fillStyle = '#ef4444'; // Red square
                    ctx.rect(x-4, y-4, 8, 8);
                }
                ctx.fill();
            }
        });

        // Draw Trigger Lines
        if (triggers) {
            const lastX = getX(pricesData.length - 1);
            if(triggers.crossoverPrice) {
                const y = getY(triggers.crossoverPrice);
                drawDataLine(ctx, [{x: lastX, y}, {x: width, y}], '#f59e0b', 1, true);
                ctx.fillStyle = '#f59e0b';
                ctx.textAlign = 'right';
                ctx.fillText(`Crossover: $${formatNumber(triggers.crossoverPrice)}`, width - 5, y - 5);
            }
        }

        if (hoverInfo && hoverInfo.x !== -1) {
            drawCrosshair(ctx, hoverInfo.x, hoverInfo.y, width, height);
            const i = Math.round(hoverInfo.x / xScale);
            if (pricesData[i]) {
                const infoHtml = `<strong>Date:</strong> ${new Date(pricesData[i].date).toLocaleDateString()}<br>
                                <strong>Price:</strong> $${formatNumber(prices[i])}<br>
                                <strong>Short MA:</strong> ${shortMA[i] ? '$' + formatNumber(shortMA[i]) : 'N/A'}<br>
                                <strong>Long MA:</strong> ${longMA[i] ? '$' + formatNumber(longMA[i]) : 'N/A'}<br>
                                <strong>BB Middle:</strong> ${bb.middle[i] ? '$' + formatNumber(bb.middle[i]) : 'N/A'}<br>
                                <strong>BB Upper:</strong> ${bb.upper[i] ? '$' + formatNumber(bb.upper[i]) : 'N/A'}<br>
                                <strong>BB Lower:</strong> ${bb.lower[i] ? '$' + formatNumber(bb.lower[i]) : 'N/A'}`;
                showHoverBox(hoverInfo.box, infoHtml, hoverInfo.x, hoverInfo.y, canvas);
            }
        } else if (hoverInfo) {
            hideHoverBox(hoverInfo.box);
        }
    }

    function drawChartDetails(ctx, width, height, min, max, getX, pricesData, settings) {
        ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 0.5;
        ctx.font = '10px Inter'; ctx.fillStyle = '#6b7280';

        const numYLabels = 5;
        for (let i = 0; i <= numYLabels; i++) {
            const y = (height / numYLabels) * i;
            const price = max - (i * (height / numYLabels) / height * (max - min));
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            ctx.textAlign = 'right'; ctx.fillText(`$${formatNumber(price)}`, width - 5, y - 5);
        }
        
        const numXLabels = Math.min(Math.floor(width / 100), pricesData.length);
        if (pricesData.length > 1 && numXLabels > 1) {
            for (let i = 0; i < numXLabels; i++) {
                const index = Math.floor(i * (pricesData.length - 1) / (numXLabels - 1));
                const x = getX(index);
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                ctx.textAlign = 'center'; ctx.fillText(new Date(pricesData[index].date).toLocaleDateString(), x, height - 5);
            }
        }

        let legend = [{c: '#3b82f6', t: 'Price'}, {c: '#ef4444', t: 'Short MA'}, {c: '#10b981', t: 'Long MA'}, {c: '#a78bfa', t: 'BB Middle', dashed: true}];
        if(settings.useSLTP) {
             legend.push({c: '#ef4444', t: 'Stop-Loss', dashed: true}, {c: '#22c55e', t: 'Take-Profit', dashed: true});
        }
        ctx.textAlign = 'left';
        let legendX = 10;
        legend.forEach((item) => {
            ctx.fillStyle = item.c;
            ctx.strokeStyle = item.c;
            
            const textWidth = ctx.measureText(item.t).width;
            
            if(item.dashed) {
                ctx.setLineDash([3,3]);
                ctx.beginPath();
                ctx.moveTo(legendX, 12);
                ctx.lineTo(legendX + 15, 12);
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                ctx.fillRect(legendX, 10, 15, 2);
            }
            ctx.fillStyle = '#6b7280';
            ctx.fillText(item.t, legendX + 20, 12);
            legendX += textWidth + 35;
        });
    }
    
    function drawRSIChart(ctx, width, height, rsiData, settings, hoverInfo) {
        ctx.clearRect(0, 0, width, height);
        if (rsiData.length === 0) return;

        const xScale = width / (rsiData.length - 1 || 1);
        const yScale = height / 100;
        const getX = i => i * xScale;
        const getY = val => height - (val * yScale);

        ctx.fillStyle = 'rgba(239, 68, 68, 0.05)';
        ctx.fillRect(0, 0, width, getY(settings.rsiOverbought));
        ctx.fillStyle = 'rgba(34, 197, 94, 0.05)';
        ctx.fillRect(0, getY(settings.rsiOversold), width, height);
        
        ctx.font = '10px Inter'; ctx.fillStyle = '#6b7280'; ctx.textAlign = 'right';
        ctx.fillText(settings.rsiOverbought, width - 5, getY(settings.rsiOverbought) + 10);
        ctx.fillText(settings.rsiOversold, width - 5, getY(settings.rsiOversold) - 2);

        drawDataLine(ctx, rsiData.map((d, i) => d === null ? null : {x: getX(i), y: getY(d)}), '#4f46e5', 1.5);
        
        if (hoverInfo && hoverInfo.x !== -1) {
            drawCrosshair(ctx, hoverInfo.x, hoverInfo.y, width, height);
            const i = Math.round(hoverInfo.x / xScale);
            if (rsiData[i] !== null) {
                const currentHoverText = hoverInfo.box.innerHTML;
                const rsiText = `<br><strong>RSI:</strong> ${formatNumber(rsiData[i])}`;
                if (hoverInfo.box && !currentHoverText.includes(rsiText)) {
                     hoverInfo.box.innerHTML += rsiText;
                }
            }
        }
    }

    function drawVolumeChart(canvas, pricesData, volumeSMA, hoverInfo) {
        const { ctx, width, height } = setupCanvas(canvas);
        ctx.clearRect(0, 0, width, height);

        const volume = pricesData.map(d => d.volume);
        if(volume.length === 0 || volume.every(v => v === 0)) return;

        const maxVolume = Math.max(...volume);
        const xScale = width / (volume.length - 1 || 1);
        const yScale = height / maxVolume;

        const getX = i => i * xScale;
        const getY = v => height - (v * yScale);

        // Draw Volume Bars
        const barWidth = width / volume.length * 0.8;
        volume.forEach((v, i) => {
            ctx.fillStyle = i > 0 && pricesData[i].price < pricesData[i-1].price ? 'rgba(239, 68, 68, 0.6)' : 'rgba(34, 197, 94, 0.6)';
            ctx.fillRect(getX(i) - barWidth / 2, getY(v), barWidth, v * yScale);
        });

        // Draw Volume SMA
        const createPoints = (data, yFunc) => data.map((d, i) => d === null ? null : {x: getX(i), y: yFunc(d)});
        drawDataLine(ctx, createPoints(volumeSMA, getY), 'rgba(55, 65, 81, 0.8)', 1.5);

         if (hoverInfo && hoverInfo.x !== -1) {
            const i = Math.round(hoverInfo.x / xScale);
            if (pricesData[i]) {
                const currentHoverText = hoverInfo.box.innerHTML;
                const volumeText = `<br><strong>Volume:</strong> ${formatNumber(pricesData[i].volume, 0)}`;
                if (hoverInfo.box && !currentHoverText.includes(volumeText)) {
                     hoverInfo.box.innerHTML += volumeText;
                }
            }
        }
    }
    
    function drawDataLine(ctx, points, color, width, isDashed = false) {
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = width;
        if(isDashed) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
        let first = true;
        points.forEach(p => {
            if (p !== null) {
                first ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
                first = false;
            } else {
                first = true;
            }
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    function drawCrosshair(ctx, x, y, width, height) {
        ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
    }

    function showHoverBox(box, html, x, y, canvas) {
        if(!box) return;
        box.innerHTML = html;
        box.style.display = 'block';
        const rect = canvas.getBoundingClientRect();
        let left = rect.left + window.scrollX + x + 15;
        let top = rect.top + window.scrollY + y - box.offsetHeight / 2;
        if (left + box.offsetWidth > window.innerWidth) left = rect.left + window.scrollX + x - box.offsetWidth - 15;
        box.style.left = `${left}px`;
        box.style.top = `${top}px`;
    }
    const hideHoverBox = box => { if(box) box.style.display = 'none'; };

    // --- Simulation & Optimization Logic ---
    function getSettings() {
        return {
            initialInvestment: parseFloat(elements.initialInvestment.value),
            taxRate: parseFloat(elements.taxRate.value),
            serviceFee: parseFloat(elements.serviceFee.value),
            shortPeriod: parseInt(elements.shortMA.value),
            longPeriod: parseInt(elements.longMA.value),
            rsiPeriod: parseInt(elements.rsiPeriod.value),
            rsiOverbought: parseInt(elements.rsiOverbought.value),
            rsiOversold: parseInt(elements.rsiOversold.value),
            useRsiFilter: elements.useRsiFilter.checked,
            bbPeriod: parseInt(elements.bbPeriod.value),
            bbStdDev: parseFloat(elements.bbStdDev.value),
            useBBFilter: elements.useBBFilter.checked,
            volumeMAPeriod: parseInt(elements.volumeMAPeriod.value),
            useVolumeFilter: elements.useVolumeFilter.checked,
            stopLoss: parseFloat(elements.stopLoss.value),
            takeProfit: parseFloat(elements.takeProfit.value),
            useSLTP: elements.useSLTP.checked,
            trailingStopLoss: parseFloat(elements.trailingStopLoss.value),
            useTrailingStopLoss: elements.useTrailingStopLoss.checked,
            startDate: elements.startDate.value,
            endDate: elements.endDate.value,
        };
    }

    function renderPerformanceResults(container, perf, settings) {
        const netProfit = perf.finalValue - settings.initialInvestment;
        const profitColor = netProfit >= 0 ? 'text-green-600' : 'text-red-600';
        const trades = perf.signals.filter(s => s.type === 'sell');
        const totalProfit = perf.preTaxFinalValue - settings.initialInvestment;
        const fee = totalProfit > 0 ? totalProfit * (settings.serviceFee / 100) : 0;
        const taxableProfit = totalProfit > 0 ? totalProfit - fee : 0;
        const tax = taxableProfit > 0 ? taxableProfit * (settings.taxRate / 100) : 0;

        showResults(container, `
            <h3>Results:</h3>
            <p>Final Portfolio Value (Pre-Tax/Fee): <span class="font-bold">$${formatNumber(perf.preTaxFinalValue)}</span></p>
            <p>Tax on Gains: <span class="font-bold text-red-600">-$${formatNumber(tax)}</span></p>
             <p>Service Fees: <span class="font-bold text-red-600">-$${formatNumber(fee)}</span></p>
            <p>Final Net Value (Post-Tax/Fee): <span class="font-bold">$${formatNumber(perf.finalValue)}</span></p>
            <p>Net Profit/Loss: <span class="font-bold ${profitColor}">$${formatNumber(netProfit)}</span></p>
            <p>Total completed trades: ${trades.length}</p>
        `);
    }
    
    // --- Main Drawing Functions ---
    function drawCurrentCharts(hoverInfo) {
        if (!currentStrategyData) return;
        const { prices, shortMA, longMA, rsi, bb, volumeSMA, signals, settings, triggers } = currentStrategyData;
        drawChart(elements.currentChartCanvas, prices, shortMA, longMA, bb, signals, settings, hoverInfo, triggers);
        
        const { ctx, width, height } = setupCanvas(elements.rsiChartCanvas);
        drawRSIChart(ctx, width, height, rsi, settings, hoverInfo);
        
        drawVolumeChart(elements.volumeChartCanvas, prices, volumeSMA, hoverInfo);
    }

    function drawRsiFilteredCharts(hoverInfo) {
        if (!rsiFilteredStrategyData) return;
        const { prices, shortMA, longMA, rsi, bb, volumeSMA, signals, settings, triggers } = rsiFilteredStrategyData;
        drawChart(elements.rsiFilteredChartCanvas, prices, shortMA, longMA, bb, signals, settings, hoverInfo, triggers);
        
        const { ctx, width, height } = setupCanvas(elements.rsiFilteredRsiChartCanvas);
        drawRSIChart(ctx, width, height, rsi, settings, hoverInfo);

        drawVolumeChart(elements.filteredVolumeChartCanvas, prices, volumeSMA, hoverInfo);
    }
    
    function runSimulation() {
        const settings = getSettings();
        filteredPrices = filterDataByDateRange(historicalPrices, settings.startDate, settings.endDate);
        updateDataPreviewTable(filteredPrices);
        
        const maxPeriod = Math.max(settings.longPeriod, settings.rsiPeriod, settings.bbPeriod, settings.volumeMAPeriod);
        if (filteredPrices.length < maxPeriod) {
            showResults(elements.currentSimulationResults, `<div class="warning-message">Not enough data. Need ${maxPeriod}, have ${filteredPrices.length}.</div>`);
            return;
        }

        const shortMA = calculateSMA(filteredPrices, settings.shortPeriod, 'price');
        const longMA = calculateSMA(filteredPrices, settings.longPeriod, 'price');
        const rsi = calculateRSI(filteredPrices, settings.rsiPeriod);
        const bb = calculateBollingerBands(filteredPrices, settings.bbPeriod, settings.bbStdDev);
        const volumeSMA = calculateSMA(filteredPrices, settings.volumeMAPeriod, 'volume');
        
        // Normal simulation data
        const performance = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, settings);
        const triggers = calculateNextDayTriggers(filteredPrices, performance, settings, shortMA, longMA);
        currentStrategyData = { prices: filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, signals: performance.signals, settings, performance, triggers };
        renderPerformanceResults(elements.currentSimulationResults, performance, settings);
        renderNextDayTriggerAnalysis(performance, settings, elements.currentNextDayAnalysisContainer, filteredPrices, shortMA, longMA, rsi, bb);
        renderTransactionTable(elements.currentTransactionsContainer, performance, settings, filteredPrices);


        // RSI-Filtered simulation data
        const fullyFilteredSettings = {...settings, useRsiFilter: true, useBBFilter: true, useVolumeFilter: true};
        const fullyFilteredPerformance = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, fullyFilteredSettings);
        const fullyFilteredTriggers = calculateNextDayTriggers(filteredPrices, fullyFilteredPerformance, fullyFilteredSettings, shortMA, longMA);
        rsiFilteredStrategyData = { prices: filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, signals: fullyFilteredPerformance.signals, settings: fullyFilteredSettings, performance: fullyFilteredPerformance, triggers: fullyFilteredTriggers };
        renderPerformanceResults(elements.rsiFilteredSimulationResults, fullyFilteredPerformance, settings);
        renderNextDayTriggerAnalysis(fullyFilteredPerformance, fullyFilteredSettings, elements.filteredNextDayAnalysisContainer, filteredPrices, shortMA, longMA, rsi, bb);
        renderTransactionTable(elements.rsiFilteredTransactionsContainer, fullyFilteredPerformance, fullyFilteredSettings, filteredPrices);

        // Initial draw without hover
        drawCurrentCharts(null);
        drawRsiFilteredCharts(null);
    }
    
    async function findOptimum(isComprehensive = false) {
        const settings = getSettings();
        filteredPrices = filterDataByDateRange(historicalPrices, settings.startDate, settings.endDate);
        const container = isComprehensive ? elements.comprehensiveOptimizationResults : elements.optimizationResults;
        const spinner = isComprehensive ? elements.comprehensiveOptimizationSpinner : elements.optimizationSpinner;
        const progressDiv = elements.comprehensiveOptimizationProgress;
        
        showSpinner(spinner);
        progressDiv.innerHTML = 'Preparing optimization...';
        showResults(container, "<h3>Optimizing...</h3><p>This may take a moment. See progress below.</p>");
        elements.aiAnalysisContainer.classList.add('hidden');
        elements.aiAnalysisResultBox.classList.add('hidden');
        elements.comprehensiveNextDayAnalysisContainer.classList.add('hidden');
        elements.comprehensivePracticalExamples.classList.add('hidden');

        // Use a short timeout to allow the UI to update before the heavy computation begins
        await new Promise(resolve => setTimeout(resolve, 50));

        let bestPerf = { finalValue: -Infinity }, bestShort = 0, bestLong = 0;
        let bestSettings = {};
        const rsi = calculateRSI(filteredPrices, settings.rsiPeriod);
        const bb = calculateBollingerBands(filteredPrices, settings.bbPeriod, settings.bbStdDev);
        const volumeSMA = calculateSMA(filteredPrices, settings.volumeMAPeriod, 'volume');

        const runTest = (short, long, filterSettings) => {
            const testSettings = { ...settings, ...filterSettings, shortPeriod: short, longPeriod: long };
            const shortMA = calculateSMA(filteredPrices, short, 'price');
            const longMA = calculateSMA(filteredPrices, long, 'price');
            const perf = calculateStrategyPerformance(filteredPrices, shortMA, longMA, rsi, bb, volumeSMA, testSettings);
            if (perf.finalValue > bestPerf.finalValue) {
                bestPerf = perf; 
                bestShort = short; 
                bestLong = long;
                bestSettings = testSettings;
            }
        };

        if (isComprehensive) {
            const maxShortComprehensive = 60; 
            const maxLongComprehensive = 120;
            if (maxLongComprehensive > filteredPrices.length) {
                showResults(container, `<div class="warning-message">Not enough data for comprehensive optimization. Need ${maxLongComprehensive} data points, but only have ${filteredPrices.length} in the selected range.</div>`);
                hideSpinner(spinner);
                return;
            }

            const trailingStopValues = [1, 3, 5, 10, 15, 20];
            let combinationsTested = 0;
            let lastUpdateTime = Date.now();

            // Create an async generator to yield combinations without blocking the UI
            async function* generateCombinations() {
                for (let i = 0; i < 32; i++) {
                    const baseFilterSettings = {
                        useSLTP: (i & 1) > 0,
                        useTrailingStopLoss: (i & 2) > 0,
                        useRsiFilter: (i & 4) > 0,
                        useBBFilter: (i & 8) > 0,
                        useVolumeFilter: (i & 16) > 0,
                    };
                    const tslIterator = baseFilterSettings.useTrailingStopLoss ? trailingStopValues : [settings.trailingStopLoss];
                    for (const tsl of tslIterator) {
                         const currentFilterSettings = {...baseFilterSettings, trailingStopLoss: tsl };
                         for (let short = 2; short <= maxShortComprehensive; short++) {
                            for (let long = short + 1; long <= maxLongComprehensive; long++) {
                                yield { short, long, currentFilterSettings };
                            }
                        }
                    }
                }
            }
            
            for await (const combo of generateCombinations()) {
                runTest(combo.short, combo.long, combo.currentFilterSettings);
                combinationsTested++;
                const now = Date.now();
                if (now - lastUpdateTime > 100) { // Update UI every 100ms
                    progressDiv.innerHTML = `Testing combination ${combinationsTested.toLocaleString()}... Best Profit Found: <span class="font-bold text-green-600">$${formatNumber(bestPerf.finalValue - settings.initialInvestment)}</span>`;
                    await new Promise(resolve => setTimeout(resolve, 0)); // Yield to main thread
                    lastUpdateTime = now;
                }
            }

        } else { // Manual Optimization
            const minShort = parseInt(elements.minShortMA.value);
            const maxShort = parseInt(elements.maxShortMA.value);
            const minLong = parseInt(elements.minLongMA.value);
            const maxLong = parseInt(elements.maxLongMA.value);
            if (maxLong > filteredPrices.length) {
                showResults(container, `<div class="warning-message">Not enough data. Need ${maxLong}, have ${filteredPrices.length}.</div>`);
                hideSpinner(spinner);
                return;
            }
            for (let short = minShort; short <= maxShort; short++) {
                for (let long = minLong; long <= maxLong; long++) {
                    if (short >= long) continue;
                    runTest(short, long, settings); // Use UI settings for manual
                }
            }
        }
        
        progressDiv.innerHTML = `Optimization complete. Found best strategy.`;
        hideSpinner(spinner);
        const netProfit = bestPerf.finalValue - settings.initialInvestment;
        const profitColor = netProfit >= 0 ? 'text-green-600' : 'text-red-600';
        
        let enabledFilters = Object.keys(bestSettings).filter(k => k.startsWith('use') && bestSettings[k]).map(k => {
            if (k === 'useSLTP') return 'Fixed SL/TP';
            if (k === 'useTrailingStopLoss') return `Trailing SL (${bestSettings.trailingStopLoss}%)`;
            return k.replace('use', '').replace('Filter', '');
        }).join(', ');

        if(!enabledFilters) enabledFilters = "None";

        showResults(container, `
            <h3>Optimum Strategy Found:</h3>
            <p>Short MA: ${bestShort}, Long MA: ${bestLong}</p>
            <p>Enabled Filters: <span class="font-semibold">${enabledFilters}</span></p>
            <hr class="my-2 border-gray-300">
            <p>Final Value: <span class="font-bold">$${formatNumber(bestPerf.finalValue)}</span></p>
            <p>Net Profit: <span class="font-bold ${profitColor}">$${formatNumber(netProfit)}</span></p>
        `);

        const chartSection = isComprehensive ? elements.comprehensiveOptimumStrategyChartSection : elements.optimumStrategyChartSection;
        const chartCanvas = isComprehensive ? elements.comprehensiveOptimumChartCanvas : elements.optimumChartCanvas;
        chartSection.classList.remove('hidden');
        const bestShortMA = calculateSMA(filteredPrices, bestShort, 'price');
        const bestLongMA = calculateSMA(filteredPrices, bestLong, 'price');
        
        if(isComprehensive){
            const bestTriggers = calculateNextDayTriggers(filteredPrices, bestPerf, bestSettings, bestShortMA, bestLongMA);
            comprehensiveStrategyData = {prices: filteredPrices, shortMA: bestShortMA, longMA: bestLongMA, bb, signals: bestPerf.signals, rsi, volumeSMA, settings: bestSettings, performance: bestPerf, triggers: bestTriggers};
            drawChart(chartCanvas, comprehensiveStrategyData.prices, comprehensiveStrategyData.shortMA, comprehensiveStrategyData.longMA, comprehensiveStrategyData.bb, comprehensiveStrategyData.signals, comprehensiveStrategyData.settings, null, bestTriggers);
            renderTransactionTable(elements.comprehensiveTradesTableContainer, bestPerf, bestSettings, filteredPrices);
            renderNextDayTriggerAnalysis(bestPerf, bestSettings, elements.comprehensiveNextDayAnalysisContainer, filteredPrices, bestShortMA, bestLongMA, rsi, bb);
            renderPracticalExamples(bestPerf, bestSettings, elements.comprehensivePracticalExamples, filteredPrices);
            elements.aiAnalysisContainer.classList.remove('hidden');

        } else {
            const bestTriggers = calculateNextDayTriggers(filteredPrices, bestPerf, bestSettings, bestShortMA, bestLongMA);
            optimumStrategyData = {prices: filteredPrices, shortMA: bestShortMA, longMA: bestLongMA, bb, signals: bestPerf.signals, rsi, volumeSMA, settings: bestSettings, performance: bestPerf, triggers: bestTriggers};
            drawChart(chartCanvas, optimumStrategyData.prices, optimumStrategyData.shortMA, optimumStrategyData.longMA, optimumStrategyData.bb, optimumStrategyData.signals, optimumStrategyData.settings, null, bestTriggers);
            renderTransactionTable(elements.optimumTransactionsContainer, bestPerf, bestSettings, filteredPrices);
        }

        elements.shortMA.value = bestShort;
        elements.longMA.value = bestLong;
        Object.keys(bestSettings).forEach(key => {
            if(elements[key] && elements[key].type === 'checkbox') {
                elements[key].checked = bestSettings[key];
            } else if (elements[key] && elements[key].id === 'trailingStopLoss') {
                elements[key].value = bestSettings[key];
            }
        });

        runSimulation();
    }
    
    function renderTransactionTable(container, perf, settings, pricesData) {
        if (!container) return;

        const signals = perf.signals;
        container.innerHTML = ''; // Clear previous content
        container.classList.add('hidden'); // Hide by default

        const trades = [];
        let buySignal = null;
        for (const signal of signals) {
            if (signal.type === 'buy') {
                buySignal = signal;
            } else if (signal.type === 'sell' && buySignal) {
                trades.push({ buy: buySignal, sell: signal });
                buySignal = null;
            }
        }

        if (trades.length === 0) {
            return; // No trades, keep container hidden
        }

        container.classList.remove('hidden');

        const formatReason = (reason) => {
            if (!reason) return 'N/A';
            return reason.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        };

        let tableHTML = `
            <h4 class="text-lg font-bold text-gray-700 mb-2">Trade Log:</h4>
            <p class="description-box">This table shows a detailed record of every buy and sell transaction executed by this strategy.</p>
            <div class="overflow-x-auto">
                <table class="data-preview-table w-full">
                    <thead>
                        <tr>
                            <th>Buy Date</th><th>Buy Value</th><th>Sell Date</th><th>Sell Value</th><th>Reason</th><th>Return</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        let totalGrossProfit = 0;
        trades.forEach(trade => {
            const buyValue = trade.buy.price * trade.buy.btc;
            const sellValue = trade.sell.price * trade.sell.btc;
            const returnPercent = (trade.sell.grossProfit / buyValue) * 100;
            totalGrossProfit += trade.sell.grossProfit;
            const profitColor = trade.sell.grossProfit >= 0 ? 'text-green-600' : 'text-red-600';
            tableHTML += `
                <tr>
                    <td>${new Date(pricesData[trade.buy.index].date).toLocaleDateString()}</td>
                    <td>$${formatNumber(buyValue)}</td>
                    <td>${new Date(pricesData[trade.sell.index].date).toLocaleDateString()}</td>
                    <td>$${formatNumber(sellValue)}</td>
                    <td>${formatReason(trade.sell.reason)}</td>
                    <td class="${profitColor}">${formatNumber(returnPercent)}%</td>
                </tr>
            `;
        });

        tableHTML += `
                    </tbody>
                </table>
            </div>
        `;
        
        container.innerHTML = tableHTML;

        // Also render the summary for comprehensive section specifically
        if (container.id === 'comprehensiveTradesTableContainer') {
            const fee = totalGrossProfit > 0 ? totalGrossProfit * (settings.serviceFee / 100) : 0;
            const taxableProfit = totalGrossProfit > 0 ? totalGrossProfit - fee : 0;
            const tax = taxableProfit > 0 ? taxableProfit * (settings.taxRate / 100) : 0;
            const netProfit = totalGrossProfit - fee - tax;

            const summaryHTML = `
                <h4 class="text-lg font-bold text-gray-700 mb-2">Trade Summary:</h4>
                <p>Total Gross Profit: <span class="${totalGrossProfit >= 0 ? 'text-green-600' : 'text-red-600'}">$${formatNumber(totalGrossProfit)}</span></p>
                <p>Service Fees: <span class="text-red-600">-$${formatNumber(fee)}</span></p>
                <p>Tax on Gains: <span class="text-red-600">-$${formatNumber(tax)}</span></p>
                <p class="font-bold border-t border-gray-300 mt-1 pt-1">Net Profit: <span class="${netProfit >= 0 ? 'text-green-600' : 'text-red-600'}">$${formatNumber(netProfit)}</span></p>
            `;
            showResults(elements.comprehensiveTradesSummaryContainer, summaryHTML);
            elements.comprehensiveTradesSummaryContainer.classList.remove('hidden');
        } else {
             elements.comprehensiveTradesSummaryContainer.classList.add('hidden');
        }
    }

    function calculateNextDayTriggers(prices, perf, settings, shortMA, longMA) {
        if (!prices || prices.length < settings.longPeriod) return null;

        const triggers = {};

        // --- Crossover Price Calculation ---
        const short = settings.shortPeriod;
        const long = settings.longPeriod;
        
        const sumShort = prices.slice(-short + 1).reduce((sum, p) => sum + p.price, 0);
        const sumLong = prices.slice(-long + 1).reduce((sum, p) => sum + p.price, 0);
        // P = (L*sumS - S*sumL) / (S - L)
        const crossoverPrice = (long * sumShort - short * sumLong) / (short - long);
        triggers.crossoverPrice = crossoverPrice;

        if (perf.inPositionAtEnd) { // --- Currently in a position ---
            const lastBuySignal = perf.signals.filter(s => s.type === 'buy').pop();
            if (lastBuySignal) {
                triggers.buyPrice = lastBuySignal.price;
                triggers.btcAmount = lastBuySignal.btc;
                if (settings.useSLTP) {
                    triggers.stopLossPrice = lastBuySignal.price * (1 - settings.stopLoss / 100);
                    triggers.takeProfitPrice = lastBuySignal.price * (1 + settings.takeProfit / 100);
                }
            }
        } 
        
        // --- Always calculate BB price regardless of position ---
        if (settings.useBBFilter && prices.length >= settings.bbPeriod) {
            const sumBB = prices.slice(-settings.bbPeriod + 1).reduce((sum, p) => sum + p.price, 0);
            // P_buy < (sumBB + P_buy) / K => P_buy < sumBB / (K-1)
            // P_sell > (sumBB + P_sell) / K => P_sell > sumBB / (K-1)
            const bbPrice = sumBB / (settings.bbPeriod - 1);
            triggers.bbBuyPrice = bbPrice;
            triggers.bbSellPrice = bbPrice;
        }

        return triggers;
    }

    function renderNextDayTriggerAnalysis(perf, settings, container, prices, shortMA, longMA, rsi, bb) {
        if (!container || !prices || prices.length === 0) return;
        container.innerHTML = '';
        container.classList.add('hidden');

        const triggers = calculateNextDayTriggers(prices, perf, settings, shortMA, longMA);
        if (!triggers) return;

        const lastIndex = prices.length - 1;
        const lastPrice = prices[lastIndex].price;
        const lastShortMA = shortMA[lastIndex];
        const lastLongMA = longMA[lastIndex];
        const lastRSI = rsi[lastIndex];
        const lastBBUpper = bb.upper[lastIndex];
        const lastBBLower = bb.lower[lastIndex];

        let analysisHTML = `
            <h3>Next Day Trigger Analysis</h3>
            <p class="description-box !mt-2 !mb-3">This section calculates the price needed for a buy or sell signal on the next day, based on the strategy's rules.</p>
            
            <table class="data-preview-table w-full mb-4">
              <thead><tr><th>Indicator</th><th>Last Value</th></tr></thead>
              <tbody>
                <tr><td>Last Price</td><td>$${formatNumber(lastPrice)}</td></tr>
                <tr><td>Short MA (${settings.shortPeriod})</td><td>$${formatNumber(lastShortMA)}</td></tr>
                <tr><td>Long MA (${settings.longPeriod})</td><td>$${formatNumber(lastLongMA)}</td></tr>
                <tr><td>RSI (${settings.rsiPeriod})</td><td>${formatNumber(lastRSI)}</td></tr>
                <tr><td>BB Upper</td><td>$${formatNumber(lastBBUpper)}</td></tr>
                <tr><td>BB Lower</td><td>$${formatNumber(lastBBLower)}</td></tr>
              </tbody>
            </table>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        `;

        const isShortAboveLong = lastShortMA > lastLongMA;

        // --- BUY Column ---
        let buyHTML = `<div><h4 class="text-lg font-bold text-green-700 mb-2">Potential Buy Triggers</h4><ul class="list-disc pl-6 space-y-2">`;
        if (!isShortAboveLong && triggers.crossoverPrice) {
            buyHTML += `<li><strong>Golden Cross:</strong> Price must rise to ~<strong>$${formatNumber(triggers.crossoverPrice)}</strong>.</li>`;
        } else {
            buyHTML += `<li>A Golden Cross is not the next possible crossover.</li>`;
        }
        if (settings.useBBFilter && triggers.bbBuyPrice) {
            buyHTML += `<li><strong>Bollinger Band:</strong> For a buy, price must be below ~<strong>$${formatNumber(triggers.bbBuyPrice)}</strong>.</li>`;
        }
        if (settings.useRsiFilter) {
            buyHTML += `<li><strong>RSI Filter:</strong> For a buy, RSI must be below ${settings.rsiOverbought}. (Currently ${formatNumber(lastRSI)})</li>`;
        }
        buyHTML += `</ul></div>`;

        // --- SELL Column ---
        let sellHTML = `<div><h4 class="text-lg font-bold text-red-700 mb-2">Potential Sell Triggers</h4><ul class="list-disc pl-6 space-y-2">`;
        if (perf.inPositionAtEnd) {
            const { buyPrice, stopLossPrice, takeProfitPrice } = triggers;
            sellHTML += `<li class="font-semibold">Currently in a position bought at $${formatNumber(buyPrice)}.</li>`;
            if (settings.useSLTP) {
                sellHTML += `<li><strong>Stop-Loss:</strong> Price must drop to ~<strong>$${formatNumber(stopLossPrice)}</strong>.</li>`;
                sellHTML += `<li><strong>Take-Profit:</strong> Price must rise to ~<strong>$${formatNumber(takeProfitPrice)}</strong>.</li>`;
            }
        }
        if (isShortAboveLong && triggers.crossoverPrice) {
            sellHTML += `<li><strong>Death Cross:</strong> Price must drop to ~<strong>$${formatNumber(triggers.crossoverPrice)}</strong>.</li>`;
        } else {
            sellHTML += `<li>A Death Cross is not the next possible crossover.</li>`;
        }
        if (settings.useBBFilter && triggers.bbSellPrice) {
             sellHTML += `<li><strong>Bollinger Band:</strong> For a sell, price must be above ~<strong>$${formatNumber(triggers.bbSellPrice)}</strong>.</li>`;
        }
        sellHTML += `</ul></div>`;
        
        analysisHTML += buyHTML + sellHTML + '</div>';
        showResults(container, analysisHTML);
    }

    function renderPracticalExamples(perf, settings, container, prices) {
        if (!container || !prices || prices.length === 0) return;
        container.classList.add('hidden');

        const triggers = calculateNextDayTriggers(prices, perf, settings);
        if (!triggers) return;

        let examplesHTML = `
            <h3 class="text-xl font-bold text-gray-800 mb-2">Practical Examples for This Strategy</h3>
            <p class="description-box">This is a hypothetical guide on how to interpret the 'Next Day Trigger' analysis for the optimal strategy found above.</p>
        `;

        if (perf.inPositionAtEnd) {
            examplesHTML += `
                <p><strong>Scenario: You are currently holding Bitcoin based on this strategy.</strong></p>
                <ol class="list-decimal pl-6 mt-2 space-y-2">
                    <li><strong>Defensive Play (Risk Management):</strong> Your primary risk management rules are checked first. 
                        <ul class="list-disc pl-6 mt-1">
                           ${settings.useSLTP ? `<li>A fixed Stop-Loss sell will occur if the price drops to <strong>$${formatNumber(triggers.stopLossPrice)}</strong>.</li>` : ''}
                           ${settings.useTrailingStopLoss ? `<li>A Trailing Stop-Loss sell will occur if the price drops by ${settings.trailingStopLoss}% from its peak since you bought in.</li>` : ''}
                           ${settings.useSLTP ? `<li>A Take-Profit sell will occur if the price rises to <strong>$${formatNumber(triggers.takeProfitPrice)}</strong>.</li>` : ''}
                           ${!settings.useSLTP && !settings.useTrailingStopLoss ? '<li>No risk management rules are active.</li>' : ''}
                        </ul>
                    </li>
                    <li><strong>Trend-Change Play (Death Cross):</strong> If no risk rules are triggered, you watch for a trend reversal. A sell signal would occur if the price drops to <strong>$${formatNumber(triggers.crossoverPrice)}</strong>. This is the point where the short-term momentum (Short MA) would turn negative compared to the long-term trend (Long MA).</li>
                </ol>
            `;
        } else {
            examplesHTML += `
                <p><strong>Scenario: You are currently in cash, waiting for a signal to buy.</strong></p>
                <ol class="list-decimal pl-6 mt-2 space-y-2">
                    <li><strong>Primary Buy Signal (Golden Cross):</strong> The main condition to enter a trade is for the price to rise to <strong>$${formatNumber(triggers.crossoverPrice)}</strong>. This would signal that short-term momentum is turning positive.</li>
            `;
            if (settings.useRsiFilter || settings.useBBFilter) {
                 examplesHTML += `<li><strong>Confirmation Checks:</strong> However, this isn't enough. For the trade to be valid, the following conditions must ALSO be met on the day of the crossover:`;
                 examplesHTML += `<ul class="list-disc pl-6 mt-1">`;
                 if (settings.useRsiFilter) {
                     examplesHTML += `<li>The RSI must be below ${settings.rsiOverbought}.</li>`;
                 }
                 if (settings.useBBFilter) {
                     examplesHTML += `<li>The price must be below the middle Bollinger Band (approx. <strong>$${formatNumber(triggers.bbBuyPrice)}</strong>).</li>`;
                 }
                 examplesHTML += `</ul></li>`;
                 examplesHTML += `<li><strong>Putting it Together:</strong> You need the price to hit <strong>$${formatNumber(triggers.crossoverPrice)}</strong>. However, if that price is higher than the Bollinger Band trigger of <strong>$${formatNumber(triggers.bbBuyPrice)}</strong>, the conditions are contradictory and a buy signal is impossible on that day. The strategy is essentially saying "the trend is turning bullish, but the price is too overextended from its recent average to safely buy right now."</li>`;
            }
            examplesHTML += `</ol>`;
        }
        showResults(container, examplesHTML);
    }
    
    async function analyzeStrategyWithAI() {
        if (!comprehensiveStrategyData) {
            alert("Please run a Comprehensive Optimization first.");
            return;
        }

        const { settings, performance, prices } = comprehensiveStrategyData;
        const resultBox = elements.aiAnalysisResultBox;
        resultBox.innerHTML = '<div class="loading-spinner" style="display: block;"></div> <p class="text-center">Analyzing strategy...</p>';
        resultBox.classList.remove('hidden');

        const { finalValue } = performance;
        const netProfit = finalValue - settings.initialInvestment;
        const numTrades = performance.signals.filter(s => s.type === 'sell').length;

        const filters = [
            `Stop-Loss/Take-Profit: ${settings.useSLTP ? `Enabled (${settings.stopLoss}% / ${settings.takeProfit}%)` : 'Disabled'}`,
            `Trailing Stop-Loss: ${settings.useTrailingStopLoss ? `Enabled (${settings.trailingStopLoss}%)` : 'Disabled'}`,
            `RSI Filter: ${settings.useRsiFilter ? `Enabled (Period: ${settings.rsiPeriod}, Levels: ${settings.rsiOversold}/${settings.rsiOverbought})` : 'Disabled'}`,
            `Bollinger Bands Filter: ${settings.useBBFilter ? `Enabled (Period: ${settings.bbPeriod}, StdDev: ${settings.bbStdDev})` : 'Disabled'}`,
            `Volume Filter: ${settings.useVolumeFilter ? `Enabled (MA Period: ${settings.volumeMAPeriod})` : 'Disabled'}`
        ].join('\n- ');

        let prompt = `You are a helpful trading strategy analyst.

        Based on the following **optimized** trading strategy parameters and its performance results for Bitcoin (BTC/USD), provide a concise analysis.

        **Strategy Context:**
        - The strategy was tested on historical data from **${settings.startDate} to ${settings.endDate}**.
        - The system found the optimal Moving Average combination to be **Short MA: ${settings.shortPeriod}** and **Long MA: ${settings.longPeriod}**.

        **Strategy Rules & Filters:**
        - ${filters}

        **Performance Results:**
        - Initial Investment: $${formatNumber(settings.initialInvestment)}
        - Final Net Value (after tax/fees): $${formatNumber(finalValue)}
        - Net Profit/Loss: $${formatNumber(netProfit)}
        - Number of Trades: ${numTrades}

        **Your Task:**
        Write a brief, easy-to-understand analysis (2-3 paragraphs) in HTML format. Use <p> tags for paragraphs. Cover:
        1. A summary of the strategy's overall approach, mentioning the core MA crossover and the specific confirmation filters that were applied.
        2. An interpretation of its performance. Was the optimized strategy profitable? Is the number of trades high or low for the period?
        3. Potential strengths and weaknesses based on the **complete set of rules** that were active for this optimization. For example, mention how the combination of MA periods and active filters likely influenced the outcome.

        Do not give financial advice. The analysis should be based *only* on the provided data.`;
        
        const nextDayTriggers = calculateNextDayTriggers(prices, performance, settings);

        if (nextDayTriggers) {
            let triggerText = `\n\n**Additional Context: Next Day Trigger Prices**\nBased on the last price of $${formatNumber(prices[prices.length-1].price)}, here are the approximate prices needed for a transaction tomorrow:\n`;
            if (performance.inPositionAtEnd) {
                triggerText += `- **Sell (Death Cross):** ~$${formatNumber(nextDayTriggers.crossoverPrice)}\n`;
                if(nextDayTriggers.stopLossPrice) triggerText += `- **Sell (Stop-Loss):** ~$${formatNumber(nextDayTriggers.stopLossPrice)}\n`;
                if(nextDayTriggers.takeProfitPrice) triggerText += `- **Sell (Take-Profit):** ~$${formatNumber(nextDayTriggers.takeProfitPrice)}\n`;
            } else {
                triggerText += `- **Buy (Golden Cross):** ~$${formatNumber(nextDayTriggers.crossoverPrice)}\n`;
            }
            triggerText += `\n**New Task:**\nPlease also incorporate these trigger prices into your analysis. Briefly comment on how close the market is to these key levels and what that implies for the strategy's immediate future.`;
            prompt += triggerText;
        }


        try {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // API Key is handled by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            
            if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                let text = result.candidates[0].content.parts[0].text;
                text = text.replace(/```html|```/g, '');
                resultBox.innerHTML = `<h4>✨ AI Strategy Analysis</h4>${text}`;
            } else {
                 resultBox.innerHTML = `<p class="text-red-500">Could not retrieve AI analysis. The response was empty.</p>`;
            }
        } catch (error) {
            console.error("Error calling Gemini API:", error);
            resultBox.innerHTML = `<p class="text-red-500">An error occurred while analyzing the strategy. Please check the console for details.</p>`;
        }
    }
    
    function setDefaults() {
        Object.keys(defaultSettings).forEach(key => {
            if(elements[key] && elements[key].type === 'checkbox') {
                elements[key].checked = defaultSettings[key];
            } else if (elements[key]) {
                elements[key].value = defaultSettings[key];
            }
        });
        runSimulation();
    }

    function setupEventListeners() {
        elements.runSimulationBtn.addEventListener('click', runSimulation);
        elements.findOptimumBtn.addEventListener('click', () => findOptimum(false));
        elements.findComprehensiveOptimumBtn.addEventListener('click', () => findOptimum(true));
        elements.analyzeStrategyBtn.addEventListener('click', analyzeStrategyWithAI);
        elements.resetToDefaultsBtn.addEventListener('click', setDefaults);
        elements.patternSelector.addEventListener('change', () => {
            const selectedPatternKey = elements.patternSelector.value;
            const pattern = patternData[selectedPatternKey];
            drawPatternChart(pattern.data, pattern.name);
        });

        elements.dateRangeSlider.addEventListener('input', () => {
            const range = dateRanges[elements.dateRangeSlider.value];
            elements.dateRangeLabel.textContent = range.label;
            if (range.days !== null) {
                const endDate = new Date(historicalPrices[historicalPrices.length - 1].date);
                const startDate = new Date(endDate);
                if(isFinite(range.days)) {
                    startDate.setDate(endDate.getDate() - range.days);
                } else {
                    startDate.setTime(new Date(historicalPrices[0].date).getTime());
                }
                elements.endDate.value = endDate.toISOString().split('T')[0];
                elements.startDate.value = startDate.toISOString().split('T')[0];
                runSimulation();
            }
        });

        elements.startDate.addEventListener('change', () => {
            elements.dateRangeSlider.value = dateRanges.length - 1; // Set to "Custom"
            elements.dateRangeLabel.textContent = 'Custom';
        });
        elements.endDate.addEventListener('change', () => {
            elements.dateRangeSlider.value = dateRanges.length - 1; // Set to "Custom"
            elements.dateRangeLabel.textContent = 'Custom';
        });
        
        const createHoverListener = (container, redrawFn, getHoverBox) => {
             if (!container) return;
             container.addEventListener('mousemove', e => {
                const rect = container.querySelector('canvas').getBoundingClientRect();
                redrawFn({x: e.clientX - rect.left, y: e.clientY - rect.top, box: getHoverBox()});
            });
            container.addEventListener('mouseout', () => {
                redrawFn(null);
                const hoverBox = getHoverBox();
                if(hoverBox) hideHoverBox(hoverBox);
            });
        };

        createHoverListener(elements.currentSimulationSection, drawCurrentCharts, () => elements.hoverInfoBox);
        createHoverListener(elements.rsiFilteredSimulationSection, drawRsiFilteredCharts, () => elements.rsiFilteredHoverInfoBox);

        createHoverListener(elements.optimumStrategyChartSection, (hover) => {
            if(!optimumStrategyData) return;
            const {prices, shortMA, longMA, bb, signals, settings, triggers} = optimumStrategyData;
            drawChart(elements.optimumChartCanvas, prices, shortMA, longMA, bb, signals, settings, hover, triggers);
        }, () => elements.optimumHoverInfoBox);

        createHoverListener(elements.comprehensiveOptimumStrategyChartSection, (hover) => {
             if(!comprehensiveStrategyData) return;
            const {prices, shortMA, longMA, bb, signals, settings, triggers} = comprehensiveStrategyData;
            drawChart(elements.comprehensiveOptimumChartCanvas, prices, shortMA, longMA, bb, signals, settings, hover, triggers);
        }, () => elements.comprehensiveOptimumHoverInfoBox);
    }

    async function initialize() {
        defaultSettings = getSettings();
        historicalPrices = await fetchCSV('./btc-usd-max.csv');
        if (historicalPrices.length > 0) {
            elements.dateRangeSlider.value = 5; // Default to 1 year
            elements.dateRangeSlider.dispatchEvent(new Event('input'));
        }
        setupEventListeners();
        window.addEventListener('resize', () => {
            // Redraw all charts on resize
            runSimulation();
            const selectedPatternKey = elements.patternSelector.value;
            const pattern = patternData[selectedPatternKey];
            drawPatternChart(pattern.data, pattern.name);
        });

        // Initial draw for pattern chart
        const initialPatternKey = elements.patternSelector.value;
        const initialPattern = patternData[initialPatternKey];
        drawPatternChart(initialPattern.data, initialPattern.name);
    }

    initialize();
});
</script>
</body>
</html>
