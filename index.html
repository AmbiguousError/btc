<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USD/Bitcoin Trading Opportunity Identifier</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better layout on smaller screens */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fdfdfd;
            width: 100%; /* Make canvas responsive */
            height: 400px; /* Fixed height for charting */
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .input-group label {
            font-weight: 600;
            color: #4a5568;
        }
        .input-group input {
            padding: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        .btn-primary {
            background-color: #6366f1;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover {
            background-color: #4f46e5;
            transform: translateY(-1px);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.3);
        }
        .results-box {
            background-color: #edf2f7;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #d1d5db;
        }
        .results-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #2d3748;
        }
        .results-box p {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #4a5568;
        }
        .message-box {
            background-color: #fefcbf;
            border: 1px solid #fbd38d;
            color: #92400e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
            text-align: center;
        }
        .error-message {
            background-color: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .optimization-results {
            background-color: #e0f2fe;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #90cdf4;
            margin-top: 20px;
        }
        .optimization-results h3 {
            color: #2b6cb0;
        }


        /* Responsive adjustments */
        @media (min-width: 768px) {
            .input-section {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-end;
            }
            .input-group {
                flex: 1;
                max-width: 48%; /* Adjust for spacing */
            }
        }
        @media (max-width: 767px) {
            .input-section {
                flex-direction: column;
                align-items: stretch;
            }
            .input-group {
                width: 100%;
            }
            .input-group input {
                width: 100%;
            }
            .btn-primary {
                width: 100%;
            }
            .optimization-inputs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">USD/Bitcoin Trading Opportunity Identifier</h1>
        <p class="text-gray-600 text-center mb-6">
            This model uses **real historical USD/Bitcoin price data from `BTC.csv`** and applies a Moving Average Crossover strategy to identify potential buy and sell signals.
            You can adjust the periods for the short and long moving averages.
        </p>

        <div class="input-section flex flex-col md:flex-row gap-4 mb-6">
            <div class="input-group">
                <label for="shortMA">Short MA Period (e.g., 10):</label>
                <input type="number" id="shortMA" value="10" min="2" max="50">
            </div>
            <div class="input-group">
                <label for="longMA">Long MA Period (e.g., 30):</label>
                <input type="number" id="longMA" value="30" min="3" max="100">
            </div>
            <button id="runSimulationBtn" class="btn-primary mt-auto">Run Simulation</button>
        </div>

        <div class="optimization-section border-t border-gray-200 pt-6 mt-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Strategy Optimization Tool</h2>
            <p class="text-gray-600 text-center mb-6">
                Find the optimum Short and Long Moving Average periods that would have maximized profit
                over the historical data.
            </p>
            <div class="optimization-inputs flex flex-col md:flex-row gap-4 mb-6">
                <div class="input-group">
                    <label for="minShortMA">Min Short MA:</label>
                    <input type="number" id="minShortMA" value="5" min="2" max="40">
                </div>
                <div class="input-group">
                    <label for="maxShortMA">Max Short MA:</label>
                    <input type="number" id="maxShortMA" value="20" min="5" max="50">
                </div>
                <div class="input-group">
                    <label for="minLongMA">Min Long MA:</label>
                    <input type="number" id="minLongMA" value="25" min="10" max="80">
                </div>
                <div class="input-group">
                    <label for="maxLongMA">Max Long MA:</label>
                    <input type="number" id="maxLongMA" value="60" min="30" max="100">
                </div>
                <button id="findOptimumBtn" class="btn-primary mt-auto">Find Optimum Strategy</button>
            </div>
            <div id="optimizationSpinner" class="loading-spinner"></div>
            <div id="optimizationResults" class="optimization-results hidden">
                <h3>Optimum Strategy Found:</h3>
                <p id="optimumShortMA"></p>
                <p id="optimumLongMA"></p>
                <p id="optimumProfit"></p>
                <p id="optimumTotalTrades"></p>
                <p id="optimumWinningTrades"></p>
                <p id="optimumLosingTrades"></p>
                <div id="optimizationMessageBox" class="message-box hidden"></div>
            </div>
        </div>


        <div id="loadingSpinner" class="loading-spinner"></div>
        <canvas id="chartCanvas"></canvas>

        <div id="results" class="results-box hidden">
            <h3>Current Simulation Results:</h3>
            <p id="totalTrades"></p>
            <p id="winningTrades"></p>
            <p id="losingTrades"></p>
            <p id="simulatedProfit"></p>
            <div id="messageBox" class="message-box hidden"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const chartCanvas = document.getElementById('chartCanvas');
            const ctx = chartCanvas.getContext('2d');
            const shortMAPeriodInput = document.getElementById('shortMA');
            const longMAPeriodInput = document.getElementById('longMA');
            const runSimulationBtn = document.getElementById('runSimulationBtn');
            const resultsDiv = document.getElementById('results');
            const totalTradesSpan = document.getElementById('totalTrades');
            const winningTradesSpan = document.getElementById('winningTrades');
            const losingTradesSpan = document.getElementById('losingTrades');
            const simulatedProfitSpan = document.getElementById('simulatedProfit');
            const messageBox = document.getElementById('messageBox');
            const loadingSpinner = document.getElementById('loadingSpinner');

            // Optimization elements
            const minShortMAInput = document.getElementById('minShortMA');
            const maxShortMAInput = document.getElementById('maxShortMA');
            const minLongMAInput = document.getElementById('minLongMA');
            const maxLongMAInput = document.getElementById('maxLongMA');
            const findOptimumBtn = document.getElementById('findOptimumBtn');
            const optimizationSpinner = document.getElementById('optimizationSpinner');
            const optimizationResultsDiv = document.getElementById('optimizationResults');
            const optimumShortMASpan = document.getElementById('optimumShortMA');
            const optimumLongMASpan = document.getElementById('optimumLongMA');
            const optimumProfitSpan = document.getElementById('optimumProfit');
            const optimumTotalTradesSpan = document.getElementById('optimumTotalTrades'); // New element
            const optimumWinningTradesSpan = document.getElementById('optimumWinningTrades'); // New element
            const optimumLosingTradesSpan = document.getElementById('optimumLosingTrades'); // New element
            const optimizationMessageBox = document.getElementById('optimizationMessageBox');


            let historicalPrices = []; // This will hold the real data

            // Set canvas dimensions
            const CHART_HEIGHT = 400;
            let CHART_WIDTH = chartCanvas.offsetWidth; // Get actual width on load
            chartCanvas.height = CHART_HEIGHT;
            chartCanvas.width = CHART_WIDTH;

            // Adjust canvas width on window resize for responsiveness
            window.addEventListener('resize', () => {
                chartCanvas.width = chartCanvas.offsetWidth;
                CHART_WIDTH = chartCanvas.offsetWidth; // Update CHART_WIDTH on resize
                // Re-run simulation to redraw chart with new dimensions
                runSimulation(); // Redraw chart with current MA settings
            });

            // --- Message Box Functions ---
            function showMessageBox(message, type = 'info', targetBox = messageBox) {
                targetBox.textContent = message;
                targetBox.classList.remove('hidden', 'message-box', 'error-message'); // Clear previous classes
                targetBox.classList.add('message-box'); // Add base class

                if (type === 'error') {
                    targetBox.classList.add('error-message');
                } else {
                    targetBox.classList.remove('error-message');
                }
                targetBox.classList.remove('hidden');
            }

            function hideMessageBox(targetBox = messageBox) {
                targetBox.classList.add('hidden');
            }

            // --- CSV Data Fetching and Parsing ---
            async function fetchCSV(filePath) {
                loadingSpinner.style.display = 'block'; // Show spinner for main data load
                showMessageBox('Loading historical data...', 'info');
                try {
                    // Changed to a relative path for local file loading
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }
                    const csvText = await response.text();
                    return parseCSV(csvText);
                } catch (error) {
                    console.error('Error fetching or parsing CSV:', error);
                    showMessageBox(`Failed to load data: ${error.message}. Please ensure 'BTC.csv' is in the same directory as the HTML file.`, 'error'); // Updated message
                    return [];
                } finally {
                    loadingSpinner.style.display = 'none'; // Hide spinner
                }
            }

            function parseCSV(csvText) {
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    showMessageBox('CSV file is empty or has no data rows.', 'error');
                    return [];
                }

                // Updated header splitting to handle potential quotes and then split by semicolon
                // It's safer to remove quotes from the header names before indexing
                const rawHeaders = lines[0].split(';');
                const headers = rawHeaders.map(h => h.trim().replace(/"/g, '')); // Trim and remove quotes

                const closePriceIndex = headers.indexOf('close'); // Assuming 'close' column (lowercase now due to .replace)
                const dateIndex = headers.indexOf('timeClose'); // Using 'timeClose' for date, as it's the timestamp for the close

                if (closePriceIndex === -1) {
                    showMessageBox('CSV missing "close" price column. Please check column headers (expected: "close").', 'error');
                    return [];
                }
                 if (dateIndex === -1) {
                    showMessageBox('CSV missing "timeClose" column. Chart x-axis labels might be less informative (expected: "timeClose").', 'info');
                }

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const columns = lines[i].split(';');
                    const closePrice = parseFloat(columns[closePriceIndex]);
                    // Remove quotes from the date string if present
                    const date = columns[dateIndex] ? columns[dateIndex].replace(/"/g, '') : '';

                    if (!isNaN(closePrice)) {
                        data.push({
                            price: closePrice,
                            date: date
                        });
                    }
                }
                // The CSV seems to be in reverse chronological order (most recent first).
                // Charting usually expects chronological order.
                return data.reverse();
            }

            // --- Technical Analysis Functions ---

            // Calculate Simple Moving Average (SMA)
            function calculateSMA(data, period) {
                if (period <= 0) {
                    // For optimization, we'll handle period validation outside this function
                    return Array(data.length).fill(null);
                }
                if (period > data.length) {
                    return Array(data.length).fill(null);
                }

                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null); // Not enough data for the initial points
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val.price, 0); // Access .price property
                        sma.push(sum / period);
                    }
                }
                return sma;
            }

            // Identify Moving Average Crossover signals and calculate profit
            function calculateStrategyPerformance(pricesData, shortPeriod, longPeriod) {
                const shortMA = calculateSMA(pricesData, shortPeriod);
                const longMA = calculateSMA(pricesData, longPeriod);

                if (shortMA.includes(null) || longMA.includes(null) || shortMA.length === 0 || longMA.length === 0) {
                    // If MAs couldn't be calculated (e.g., period too large), return 0 profit.
                    // This scenario is handled by input validation in runSimulation and findOptimumStrategy,
                    // but a robust function should still handle it.
                    return { totalProfitLoss: 0, tradesCount: 0, winningTrades: 0, losingTrades: 0, signals: [] };
                }

                const signals = [];
                let totalProfitLoss = 0;
                let tradesCount = 0;
                let winningTrades = 0;
                let losingTrades = 0;
                let currentTradeEntryPrice = null;
                let inPosition = false; // Initialize inPosition

                for (let i = 1; i < pricesData.length; i++) {
                    const currentPrice = pricesData[i].price;

                    if (shortMA[i] !== null && longMA[i] !== null && shortMA[i - 1] !== null && longMA[i - 1] !== null) {
                        // Buy Signal: Short MA crosses above Long MA
                        if (shortMA[i - 1] <= longMA[i - 1] && shortMA[i] > longMA[i]) {
                            if (!inPosition) {
                                signals.push({ index: i, type: 'buy', price: currentPrice });
                                inPosition = true;
                                currentTradeEntryPrice = currentPrice;
                            }
                        }
                        // Sell Signal: Short MA crosses below Long MA
                        else if (shortMA[i - 1] >= longMA[i - 1] && shortMA[i] < longMA[i]) {
                            if (inPosition) {
                                signals.push({ index: i, type: 'sell', price: currentPrice, entryPrice: currentTradeEntryPrice });
                                tradesCount++;
                                const profitLoss = currentPrice - currentTradeEntryPrice; // Assuming buying 1 unit of Bitcoin
                                totalProfitLoss += profitLoss;

                                if (profitLoss > 0) {
                                    winningTrades++;
                                } else if (profitLoss < 0) {
                                    losingTrades++;
                                }
                                inPosition = false;
                                currentTradeEntryPrice = 0; // Reset entry price
                            }
                        }
                    }
                }

                // If a buy signal was the last signal and the position is still open, close it at the last price
                if (inPosition && currentTradeEntryPrice !== null) {
                    tradesCount++;
                    const lastPrice = pricesData[pricesData.length - 1].price;
                    const profitLoss = lastPrice - currentTradeEntryPrice;
                    totalProfitLoss += profitLoss;
                    if (profitLoss > 0) {
                        winningTrades++;
                    } else if (profitLoss < 0) {
                        losingTrades++;
                    }
                }

                return { totalProfitLoss, tradesCount, winningTrades, losingTrades, signals };
            }

            // --- Charting Functions (Remains largely the same, but takes signals from calculateStrategyPerformance) ---

            function drawChart(pricesData, shortMA, longMA, signals) {
                ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height); // Clear canvas

                const prices = pricesData.map(d => d.price); // Extract prices array for charting

                // Get min/max prices for scaling
                const allValues = [...prices, ...shortMA.filter(v => v !== null), ...longMA.filter(v => v !== null)];
                const minPrice = Math.min(...allValues);
                const maxPrice = Math.max(...allValues);
                const priceRange = maxPrice - minPrice;

                if (priceRange === 0) { // Avoid division by zero if all prices are identical
                    showMessageBox('Price range is zero. Cannot draw chart.', 'error');
                    return;
                }

                // Scaling factors
                const xScale = chartCanvas.width / (prices.length - 1);
                const yScale = chartCanvas.height / priceRange;

                // Function to convert price to canvas Y coordinate
                const getY = (price) => chartCanvas.height - ((price - minPrice) * yScale);
                const getX = (index) => index * xScale;

                // Draw X and Y axis labels
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Inter';
                // Y-axis labels
                ctx.fillText(`$${maxPrice.toFixed(2)}`, 5, 15);
                ctx.fillText(`$${minPrice.toFixed(2)}`, 5, chartCanvas.height - 5);
                // X-axis (Date labels from real data, simplified for display)
                if (pricesData.length > 0) {
                    // Display start date - using a more robust date parsing
                    const startDate = new Date(pricesData[0].date);
                    ctx.fillText(startDate.toLocaleDateString(), 5, chartCanvas.height - 5);
                    // Display end date
                    const endDate = new Date(pricesData[pricesData.length - 1].date);
                    ctx.fillText(endDate.toLocaleDateString(), chartCanvas.width - ctx.measureText(endDate.toLocaleDateString()).width - 5, chartCanvas.height - 5);
                }


                // Draw Price Line
                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6'; // Blue
                ctx.lineWidth = 2;
                prices.forEach((price, i) => {
                    if (i === 0) {
                        ctx.moveTo(getX(i), getY(price));
                    } else {
                        ctx.lineTo(getX(i), getY(price));
                    }
                });
                ctx.stroke();

                // Draw Short MA Line
                ctx.beginPath();
                ctx.strokeStyle = '#ef4444'; // Red
                ctx.lineWidth = 1.5;
                shortMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (shortMA[i - 1] === null) { // Start a new path if previous was null
                             ctx.moveTo(getX(i), getY(ma));
                        } else {
                             ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                // Draw Long MA Line
                ctx.beginPath();
                ctx.strokeStyle = '#10b981'; // Green
                ctx.lineWidth = 1.5;
                longMA.forEach((ma, i) => {
                    if (ma !== null) {
                        if (longMA[i - 1] === null) { // Start a new path if previous was null
                            ctx.moveTo(getX(i), getY(ma));
                        } else {
                            ctx.lineTo(getX(i), getY(ma));
                        }
                    }
                });
                ctx.stroke();

                // Draw Signals
                signals.forEach(signal => {
                    ctx.beginPath();
                    const x = getX(signal.index);
                    const y = getY(prices[signal.index]); // Signal at price point

                    if (signal.type === 'buy') {
                        ctx.fillStyle = '#22c55e'; // Green for buy
                        ctx.arc(x, y, 6, 0, Math.PI * 2); // Circle
                    } else { // sell
                        ctx.fillStyle = '#ef4444'; // Red for sell
                        ctx.rect(x - 6, y - 6, 12, 12); // Square
                    }
                    ctx.fill();

                    ctx.fillStyle = '#000'; // Text color for labels
                    ctx.font = '10px Inter';
                    ctx.fillText(signal.type.toUpperCase(), x + 8, y - 8);
                });
            }

            // --- Main Simulation Logic (for manual input) ---
            function runSimulation() {
                hideMessageBox(); // Hide any previous messages for current simulation

                const shortPeriod = parseInt(shortMAPeriodInput.value);
                const longPeriod = parseInt(longMAPeriodInput.value);

                // Input validation
                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded. Please ensure data is available.', 'error'); // Updated message
                    resultsDiv.classList.add('hidden');
                    return;
                }

                if (isNaN(shortPeriod) || isNaN(longPeriod) || shortPeriod <= 0 || longPeriod <= 0) {
                    showMessageBox('Please enter valid positive numbers for MA periods.', 'error');
                    resultsDiv.classList.add('hidden');
                    return;
                }
                if (shortPeriod >= longPeriod) {
                    showMessageBox('Short MA period must be less than Long MA period.', 'error');
                    resultsDiv.classList.add('hidden');
                    return;
                }
                if (longPeriod > historicalPrices.length) {
                     showMessageBox(`Long MA period (${longPeriod}) cannot be greater than the number of available data points (${historicalPrices.length}).`, 'error');
                     resultsDiv.classList.add('hidden');
                     return;
                }

                const performance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);
                const shortMAValues = calculateSMA(historicalPrices, shortPeriod);
                const longMAValues = calculateSMA(historicalPrices, longPeriod);


                // Display results
                resultsDiv.classList.remove('hidden');
                totalTradesSpan.textContent = `Total completed trades: ${performance.tradesCount}`;
                winningTradesSpan.textContent = `Winning trades: ${performance.winningTrades}`;
                losingTradesSpan.textContent = `Losing trades: ${performance.losingTrades}`;
                simulatedProfitSpan.textContent = `Simulated Profit/Loss: $${performance.totalProfitLoss.toFixed(2)} USD (for 1 unit of Bitcoin traded)`;
                simulatedProfitSpan.style.color = performance.totalProfitLoss >= 0 ? '#10b981' : '#ef4444'; // Green for profit, red for loss

                // Draw the chart
                chartCanvas.width = chartCanvas.offsetWidth; // Ensure current width is used
                drawChart(historicalPrices, shortMAValues, longMAValues, performance.signals);
            }

            // --- Optimization Logic ---
            async function findOptimumStrategy() {
                hideMessageBox(optimizationMessageBox); // Hide previous optimization messages
                optimizationResultsDiv.classList.add('hidden'); // Hide previous results

                const minShort = parseInt(minShortMAInput.value);
                const maxShort = parseInt(maxShortMAInput.value);
                const minLong = parseInt(minLongMAInput.value);
                const maxLong = parseInt(maxLongMAInput.value);

                // Input validation for optimization ranges
                if (isNaN(minShort) || isNaN(maxShort) || isNaN(minLong) || isNaN(maxLong) ||
                    minShort <= 0 || maxShort <= 0 || minLong <= 0 || maxLong <= 0) {
                    showMessageBox('Please enter valid positive numbers for all optimization ranges.', 'error', optimizationMessageBox);
                    return;
                }
                if (minShort >= maxShort || minLong >= maxLong || maxShort >= minLong) {
                    showMessageBox('Optimization ranges are invalid. Ensure Min < Max for each, and Max Short < Min Long.', 'error', optimizationMessageBox);
                    return;
                }
                if (historicalPrices.length === 0) {
                    showMessageBox('No historical data loaded for optimization. Please ensure data is available.', 'error', optimizationMessageBox); // Updated message
                    return;
                }
                if (maxLong > historicalPrices.length) {
                    showMessageBox(`Max Long MA (${maxLong}) cannot be greater than the number of data points (${historicalPrices.length}). Adjust range.`, 'error', optimizationMessageBox);
                    return;
                }


                optimizationSpinner.style.display = 'block'; // Show optimization spinner
                showMessageBox('Searching for optimum strategy...', 'info', optimizationMessageBox);

                let bestProfit = -Infinity;
                let bestShortMA = 0;
                let bestLongMA = 0;
                let bestPerformance = null; // Store the full performance object


                // Iterate through all combinations of short and long MA periods
                for (let shortPeriod = minShort; shortPeriod <= maxShort; shortPeriod++) {
                    for (let longPeriod = minLong; longPeriod <= maxLong; longPeriod++) {
                        // Ensure short MA is always less than long MA
                        if (shortPeriod >= longPeriod) {
                            continue;
                        }
                        // Ensure periods are valid for the dataset size
                        if (longPeriod > historicalPrices.length) {
                            continue; // Skip if long period is too large for the data
                        }

                        const currentPerformance = calculateStrategyPerformance(historicalPrices, shortPeriod, longPeriod);

                        if (currentPerformance.totalProfitLoss > bestProfit) {
                            bestProfit = currentPerformance.totalProfitLoss;
                            bestShortMA = shortPeriod;
                            bestLongMA = longPeriod;
                            bestPerformance = currentPerformance; // Store the best performance
                        }
                    }
                }

                optimizationSpinner.style.display = 'none'; // Hide optimization spinner
                optimizationResultsDiv.classList.remove('hidden'); // Show optimization results

                optimumShortMASpan.textContent = `Optimum Short MA Period: ${bestShortMA}`;
                optimumLongMASpan.textContent = `Optimum Long MA Period: ${bestLongMA}`;
                optimumProfitSpan.textContent = `Maximum Simulated Profit: $${bestProfit.toFixed(2)} USD`;
                optimumProfitSpan.style.color = bestProfit >= 0 ? '#10b981' : '#ef4444'; // Green for profit, red for loss

                if (bestPerformance) { // Display detailed trade stats for the optimum strategy
                    optimumTotalTradesSpan.textContent = `Total completed trades: ${bestPerformance.tradesCount}`;
                    optimumWinningTradesSpan.textContent = `Winning trades: ${bestPerformance.winningTrades}`;
                    optimumLosingTradesSpan.textContent = `Losing trades: ${bestPerformance.losingTrades}`;
                } else {
                     optimumTotalTradesSpan.textContent = `Total completed trades: 0`;
                    optimumWinningTradesSpan.textContent = `Winning trades: 0`;
                    optimumLosingTradesSpan.textContent = `Losing trades: 0`;
                }

                if (bestProfit <= 0 && bestPerformance && bestPerformance.tradesCount > 0) {
                     showMessageBox(`Optimization complete. While trades were made, no net positive profit strategy was found within the tested ranges for this historical data. The displayed strategy represents the best outcome (least loss or break-even).`, 'info', optimizationMessageBox);
                } else if (bestProfit <= 0 && bestPerformance && bestPerformance.tradesCount === 0) {
                     showMessageBox(`Optimization complete. No trades were made with any strategy within the tested ranges. This typically means the MA periods are too large or the price action was too flat for crossovers.`, 'info', optimizationMessageBox);
                }
                else {
                    showMessageBox('Optimization complete. Best strategy found!', 'info', optimizationMessageBox);
                }


                // Optionally, update the main simulation inputs and run it with the optimum strategy
                shortMAPeriodInput.value = bestShortMA;
                longMAPeriodInput.value = bestLongMA;
                runSimulation();
            }


            // --- Initial Data Load and Setup ---
            // Set the path for the local CSV file
            const csvFilePath = './BTC.csv';

            historicalPrices = await fetchCSV(csvFilePath); // Attempt to fetch the local CSV

            // Initial event listeners
            runSimulationBtn.addEventListener('click', runSimulation);
            findOptimumBtn.addEventListener('click', findOptimumStrategy);

            // Run initial simulation on load only if data was loaded successfully
            if (historicalPrices.length > 0) {
                runSimulation();
            }
        });
    </script>
</body>
</html>
